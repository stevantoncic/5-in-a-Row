<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>5-in-a-Row - Challenge the AI!</title>
  <meta name="description" content="Play 5-in-a-Row against a challenging AI. Unlock achievements and compete for the global best streak!" />
  <meta name="keywords" content="5 in a row, tic tac toe, strategy game, puzzle game, online game" />
  <meta property="og:title" content="5-in-a-Row - Challenge the AI!" />
  <meta property="og:description" content="Play 5-in-a-Row against a challenging AI. Unlock achievements and compete for the global best streak!" />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="5-in-a-Row - Challenge the AI!" />
  <meta name="twitter:description" content="Play 5-in-a-Row against a challenging AI. Unlock achievements and compete for the global best streak!" />
  
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-L08B3D4HTZ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-L08B3D4HTZ');
  </script>
  
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    
    :root {
      --bg-main: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #4facfe 75%, #00f2fe 100%);
      --board-bg: linear-gradient(145deg, #f0f4f8 0%, #e2e8f0 100%);
      --cell-bg: #ffffff;
      --cell-bg-hover: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%);
      --x-color: #ef4444;
      --o-color: #3b82f6;
      --accent: #6366f1;
      --accent-hover: #4f46e5;
      --success: #10b981;
      --success-hover: #059669;
      --error: #ef4444;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.08), 0 1px 2px rgba(0, 0, 0, 0.06);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      --shadow-glow: 0 0 20px rgba(99, 102, 241, 0.3);
      --shadow-soft: 0 8px 32px rgba(0, 0, 0, 0.08);
      --shadow-soft-inner: inset 0 2px 4px rgba(0, 0, 0, 0.06);
      --text-primary: #0f172a;
      --text-secondary: #64748b;
      --app-bg: rgba(255, 255, 255, 0.85);
      --app-border: rgba(255, 255, 255, 0.3);
      --glass-bg: rgba(255, 255, 255, 0.7);
      --glass-border: rgba(255, 255, 255, 0.5);
      --player-tag-bg: rgba(255, 255, 255, 0.9);
      --player-tag-border: rgba(226, 232, 240, 0.8);
      --input-bg: rgba(255, 255, 255, 0.95);
      --input-border: rgba(226, 232, 240, 0.8);
      --radius-sm: 8px;
      --radius-md: 14px;
      --radius-lg: 20px;
      --radius-xl: 28px;
      --radius-full: 9999px;
    }

    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    [data-theme="dark"] {
      --bg-main: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 25%, #252b45 50%, #1e2338 75%, #0f1428 100%);
      --board-bg: linear-gradient(145deg, #1a2332 0%, #1e293b 100%);
      --cell-bg: linear-gradient(145deg, #334155 0%, #2d3748 100%);
      --cell-bg-hover: linear-gradient(145deg, #475569 0%, #3d4757 100%);
      --x-color: #ff6b6b;
      --o-color: #4dabf7;
      --accent: #5c7cfa;
      --accent-hover: #4c6ef5;
      --success: #51cf66;
      --success-hover: #40c057;
      --error: #ff6b6b;
      --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.4), 0 1px 2px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.5), 0 2px 4px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.05);
      --shadow-lg: 0 10px 20px rgba(0, 0, 0, 0.6), 0 4px 8px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.08);
      --shadow-xl: 0 20px 40px rgba(0, 0, 0, 0.7), 0 8px 16px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.1);
      --shadow-glow: 0 0 30px rgba(92, 124, 250, 0.4), 0 0 60px rgba(92, 124, 250, 0.2);
      --shadow-soft: 0 8px 32px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.08);
      --shadow-soft-inner: inset 0 2px 4px rgba(0, 0, 0, 0.4), inset 0 0 0 1px rgba(255, 255, 255, 0.05);
      --text-primary: #f1f5f9;
      --text-secondary: #cbd5e1;
      --app-bg: rgba(15, 23, 42, 0.92);
      --app-border: rgba(148, 163, 184, 0.2);
      --glass-bg: rgba(30, 41, 59, 0.7);
      --glass-border: rgba(148, 163, 184, 0.15);
      --player-tag-bg: rgba(30, 41, 59, 0.8);
      --player-tag-border: rgba(148, 163, 184, 0.2);
      --input-bg: rgba(30, 41, 59, 0.8);
      --input-border: rgba(148, 163, 184, 0.25);
    }

    [data-theme="dark"] .cell {
      border-color: rgba(203, 213, 225, 0.3);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.12), 0 2px 4px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.08);
    }

    [data-theme="dark"] .cell:hover {
      border-color: rgba(92, 124, 250, 0.7);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 4px 12px rgba(92, 124, 250, 0.4), 0 0 0 2px rgba(92, 124, 250, 0.5);
      transform: translateY(-1px);
    }

    [data-theme="dark"] .cell::after {
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.25), transparent 70%);
    }

    [data-theme="dark"] .cell.win {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 50%, #b45309 100%);
      color: #fef3c7;
      box-shadow: 0 0 20px rgba(245, 158, 11, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.2);
      border-color: rgba(245, 158, 11, 0.6);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg-main);
      background-size: 400% 400%;
      animation: gradientShift 15s ease infinite;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      color: var(--text-primary);
      transition: background 0.3s ease, color 0.3s ease;
      overflow-x: hidden;
    }

    .app {
      background: var(--glass-bg);
      border-radius: var(--radius-xl);
      padding: 12px 8px 14px;
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      transition: all 0.3s ease;
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
      box-sizing: border-box;
      position: relative;
      overflow: hidden;
    }

    /* Mode Toggle Switch */
    #modeToggleSwitch,
    #modeToggleSwitchMultiplayer {
      display: flex;
      align-items: center;
      background: var(--cell-bg);
      border: 1px solid var(--app-border);
      border-radius: var(--radius-full);
      padding: 2px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      min-width: 64px;
      height: 24px;
      flex-shrink: 0;
      box-sizing: border-box;
      opacity: 1;
      pointer-events: auto;
      position: relative;
      overflow: hidden;
      isolation: isolate;
    }
    
    /* Temporarily disable multiplayer toggle for production - uncomment below to disable */
    /*
    #modeToggleSwitchMultiplayer {
      cursor: not-allowed;
      opacity: 0.5;
      pointer-events: none;
    }
    */

    #modeToggleSwitch:hover,
    #modeToggleSwitchMultiplayer:hover {
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      transform: translateX(-50%);
    }

    /* Toggle is now outside the bars */

    /* Hide multiplayer elements by default until JS loads */
    #multiplayer-score-bar {
      display: none;
    }
    
    /* Note: Toggle inside hidden parent won't be accessible - use the training toggle instead */


    #modeToggleSwitch:hover,
    #modeToggleSwitchMultiplayer:hover {
      border-color: var(--accent);
      box-shadow: var(--shadow-md);
    }

    .mode-option {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      padding: 3px 5px;
      z-index: 2;
      transition: color 0.3s ease;
      user-select: none;
      height: 100%;
      box-sizing: border-box;
    }

    .mode-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: calc(50% - 2px);
      height: calc(100% - 4px);
      background: linear-gradient(135deg, var(--accent), rgba(37, 99, 235, 0.8));
      border-radius: var(--radius-full);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1;
      box-shadow: 0 1px 3px rgba(37, 99, 235, 0.25);
    }

    #modeToggleSwitch.multiplayer .mode-slider,
    #modeToggleSwitchMultiplayer.multiplayer .mode-slider {
      transform: translateX(100%);
    }

    #modeToggleSwitch.multiplayer .mode-option[data-mode="multiplayer"],
    #modeToggleSwitchMultiplayer.multiplayer .mode-option[data-mode="multiplayer"] {
      color: white;
    }

    #modeToggleSwitch:not(.multiplayer) .mode-option[data-mode="training"],
    #modeToggleSwitchMultiplayer:not(.multiplayer) .mode-option[data-mode="training"] {
      color: white;
    }

    h1 {
      margin: 0 0 8px;
      margin-top: -8px;
      font-size: 24px;
      font-weight: 700;
      letter-spacing: -0.03em;
      text-align: center;
      background: linear-gradient(135deg, var(--accent), #8b5cf6, #ec4899);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      background-size: 200% 200%;
      animation: gradientShift 8s ease infinite;
      font-family: 'Inter', system-ui, sans-serif;
    }

    #streak-bar {
      position: relative;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      margin-top: 0;
      gap: 8px;
      font-size: 12px;
      color: var(--text-secondary);
      min-height: 32px;
      overflow: hidden;
    }

    #streak-bar #modeToggleSwitch {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }

    #bestStreakDisplay {
      font-weight: 600;
      white-space: nowrap;
      font-size: 13px;
      font-family: 'Inter', system-ui, sans-serif;
      color: var(--text-primary);
      background: rgba(251, 191, 36, 0.1);
      padding: 5px 12px;
      border-radius: var(--radius-md);
      border: 1px solid rgba(251, 191, 36, 0.2);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
      box-sizing: border-box;
      box-shadow: var(--shadow-sm);
    }

    #bestStreakDisplay:hover {
      background: rgba(251, 191, 36, 0.15);
      border-color: rgba(251, 191, 36, 0.3);
    }

    #currentStreakDisplay {
      margin-left: auto;
      font-weight: 600;
      font-size: 13px;
      font-family: 'Inter', system-ui, sans-serif;
      color: var(--text-primary);
      background: rgba(37, 99, 235, 0.1);
      padding: 5px 12px;
      border-radius: var(--radius-md);
      border: 1px solid rgba(37, 99, 235, 0.2);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex-shrink: 0;
      box-sizing: border-box;
      box-shadow: var(--shadow-sm);
    }

    #currentStreakDisplay:hover {
      background: rgba(37, 99, 235, 0.15);
      border-color: rgba(37, 99, 235, 0.3);
    }

    /* Waiting player prompt - overlays from right, hidden until room found */
    #waitingPlayerPromptContainer {
      position: absolute;
      top: 0;
      right: 0;
      width: 100%;
      height: 100%;
      overflow: visible;
      pointer-events: none;
      z-index: 1000;
      visibility: hidden;
    }

    #waitingPlayerPromptContainer.has-room #waitingPlayerPrompt {
      pointer-events: auto;
    }

    #waitingPlayerPromptContainer.has-room {
      visibility: visible;
    }

    #waitingPlayerPrompt {
      position: absolute;
      right: 12px;
      top: 72px;
      transform: translateX(calc(100% + 12px));
      transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
      pointer-events: none;
      white-space: nowrap;
    }

    #waitingPlayerPrompt.visible {
      transform: translateX(0);
      pointer-events: auto;
    }

    #waitingPlayerPrompt.slide-out {
      transform: translateX(calc(100% + 12px));
    }

    #joinWaitingRoomBtn {
      font-family: 'Inter', system-ui, sans-serif;
      font-size: 16px;
      font-weight: 700;
      padding: 14px 24px;
      border-radius: var(--radius-lg);
      border: 2px solid rgba(37, 99, 235, 0.7);
      background: linear-gradient(135deg, rgba(37, 99, 235, 0.75), rgba(37, 99, 235, 0.65));
      backdrop-filter: blur(12px) saturate(180%);
      -webkit-backdrop-filter: blur(12px) saturate(180%);
      color: white;
      cursor: pointer;
      white-space: nowrap;
      box-shadow: 0 6px 20px rgba(37, 99, 235, 0.5), 0 3px 8px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.2);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      animation: prominentPulse 1.5s ease-in-out infinite;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    @keyframes prominentPulse {
      0%, 100% {
        box-shadow: 0 6px 20px rgba(37, 99, 235, 0.5), 0 3px 8px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        transform: scale(1);
      }
      50% {
        box-shadow: 0 8px 28px rgba(37, 99, 235, 0.65), 0 4px 12px rgba(0, 0, 0, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.25);
        transform: scale(1.02);
      }
    }

    #joinWaitingRoomBtn:hover {
      background: linear-gradient(135deg, rgba(37, 99, 235, 0.85), rgba(37, 99, 235, 0.75));
      border-color: rgba(37, 99, 235, 0.9);
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 10px 32px rgba(37, 99, 235, 0.6), 0 5px 14px rgba(0, 0, 0, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      animation: none;
    }

    #joinWaitingRoomBtn:active {
      transform: translateY(0);
      box-shadow: 0 2px 8px rgba(37, 99, 235, 0.25), 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    #joinWaitingRoomBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      animation: none;
    }

    [data-theme="dark"] #joinWaitingRoomBtn {
      background: linear-gradient(135deg, rgba(92, 124, 250, 0.4), rgba(92, 124, 250, 0.3));
      border-color: rgba(92, 124, 250, 0.6);
      box-shadow: 0 6px 20px rgba(92, 124, 250, 0.45), 0 3px 8px rgba(0, 0, 0, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.15);
      animation: prominentPulseDark 1.5s ease-in-out infinite;
    }

    [data-theme="dark"] #joinWaitingRoomBtn:hover {
      background: linear-gradient(135deg, rgba(92, 124, 250, 0.5), rgba(92, 124, 250, 0.4));
      border-color: rgba(92, 124, 250, 0.8);
      box-shadow: 0 10px 32px rgba(92, 124, 250, 0.55), 0 5px 14px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }

    @keyframes prominentPulseDark {
      0%, 100% {
        box-shadow: 0 6px 20px rgba(92, 124, 250, 0.45), 0 3px 8px rgba(0, 0, 0, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.15);
        transform: scale(1);
      }
      50% {
        box-shadow: 0 8px 28px rgba(92, 124, 250, 0.6), 0 4px 12px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        transform: scale(1.02);
      }
    }

    #multiplayer-score-bar {
      position: relative;
      margin-bottom: 12px;
      margin-top: 0;
      min-height: 32px;
      width: 100%;
    }

    /* Make the toggle always visible and clickable even when parent is hidden */
    #modeToggleSwitchMultiplayer {
      display: flex !important;
      visibility: visible !important;
      pointer-events: auto !important;
    }

    /* 3 cells: left | center | right - all in one line */
    .player-score-row {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto minmax(0, 1fr);
      align-items: center;
      min-height: 32px;
      margin-top: 0;
      padding-top: 0;
      width: 100%;
    }

    .player-score-item-left {
      grid-column: 1;
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: flex-start;
      min-width: 0;
    }

    #multiplayer-score-bar .player-score-row #modeToggleSwitchMultiplayer {
      grid-column: 2;
      justify-self: center;
    }

    /* Prevent hover transform from moving multiplayer toggle - keep it centered */
    #multiplayer-score-bar #modeToggleSwitchMultiplayer:hover {
      transform: none;
    }

    .player-score-item-right {
      grid-column: 3;
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: flex-end;
      min-width: 0;
    }

    .player-name-display {
      font-weight: 500;
      font-size: 12px;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 120px;
      min-width: 0;
      transition: color 0.2s ease;
      box-sizing: border-box;
    }

    .player-score-value {
      font-weight: 700;
      font-size: 18px;
      font-family: 'Inter', system-ui, sans-serif;
      color: var(--accent);
      background: linear-gradient(135deg, rgba(37, 99, 235, 0.15), rgba(37, 99, 235, 0.08));
      padding: 5px 12px;
      border-radius: var(--radius-md);
      border: 1px solid rgba(37, 99, 235, 0.25);
      box-shadow: var(--shadow-sm);
      min-width: 40px;
      text-align: center;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      flex-shrink: 0;
      box-sizing: border-box;
      overflow: hidden;
    }

    .player-score-value:hover {
      background: linear-gradient(135deg, rgba(37, 99, 235, 0.2), rgba(37, 99, 235, 0.12));
      border-color: rgba(37, 99, 235, 0.35);
      transform: translateY(-1px);
      box-shadow: 0 3px 6px rgba(37, 99, 235, 0.15);
    }

    /* Loading dots animation */
    .loading-dots {
      display: inline-block;
      width: 1.5em;
      text-align: left;
      font-family: monospace;
    }

    .loading-dots::after {
      content: '...';
      animation: pulseDots 1.5s ease-in-out infinite;
    }

    @keyframes pulseDots {
      0%, 100% {
        opacity: 0.3;
      }
      50% {
        opacity: 1;
      }
    }

    .name-button {
      border-radius: var(--radius-md);
      border: 1px solid var(--input-border);
      background: var(--cell-bg);
      padding: 6px 14px;
      font-size: 12px;
      font-weight: 600;
      font-family: 'Inter', system-ui, sans-serif;
      cursor: pointer;
      color: var(--text-primary);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: var(--shadow-sm);
    }

    .name-button:hover {
      background: var(--cell-bg-hover);
      border-color: var(--accent);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    #players {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-bottom: 4px;
      flex-wrap: wrap;
      align-items: center;
    }

    .name-bar-info {
      min-width: 36px;
      padding: 0 10px;
    }

    .player-tag {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .player-dot {
      width: 20px;
      height: 20px;
      border-radius: var(--radius-md);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .player-dot.X-dot {
      background: rgba(220, 38, 38, 0.12);
      border: 1px solid rgba(220, 38, 38, 0.4);
      color: var(--x-color);
    }

    .player-dot.O-dot {
      background: rgba(37, 99, 235, 0.12);
      border: 1px solid rgba(37, 99, 235, 0.4);
      color: var(--o-color);
    }

    .player-name-input {
      border-radius: var(--radius-md);
      border: 1px solid var(--input-border);
      padding: 8px 14px;
      font-size: 13px;
      font-family: 'Inter', system-ui, sans-serif;
      min-width: 130px;
      outline: none;
      background: var(--input-bg);
      color: var(--text-primary);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: var(--shadow-sm);
    }

    .player-name-input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15), var(--shadow-md);
      transform: translateY(-1px);
    }

    .player-name-input:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    #statusRow {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-bottom: 6px;
      min-height: 40px;
      text-align: center;
      padding: 8px 14px;
      border-radius: var(--radius-md);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      width: calc(9 * 44px + 8 * 4px);
      margin-left: auto;
      margin-right: auto;
      max-width: calc(100% - 16px);
      box-sizing: border-box;
      overflow: hidden;
      font-family: 'Inter', system-ui, sans-serif;
    }

    #statusRow.status-your-turn {
      background: rgba(34, 197, 94, 0.1);
      border: 1px solid rgba(34, 197, 94, 0.25);
      animation: statusPulse 2.5s ease-in-out infinite;
    }

    @keyframes statusPulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.2); }
      50% { box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.08); }
    }

    #statusRow.status-computer-turn {
      background: rgba(148, 163, 184, 0.12);
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    #statusRow.status-neutral {
      background: transparent;
      border: 1px solid transparent;
    }

    [data-theme="dark"] #statusRow.status-your-turn {
      background: linear-gradient(135deg, rgba(81, 207, 102, 0.2), rgba(64, 192, 87, 0.15));
      border-color: rgba(81, 207, 102, 0.4);
      box-shadow: 0 0 15px rgba(81, 207, 102, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    [data-theme="dark"] #statusRow.status-computer-turn {
      background: linear-gradient(135deg, rgba(148, 163, 184, 0.15), rgba(100, 116, 139, 0.1));
      border-color: rgba(148, 163, 184, 0.3);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    /* Enhanced dark mode styles for buttons and UI elements */
    [data-theme="dark"] button:not(.icon-button):not(.name-button) {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 0 2px 4px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    [data-theme="dark"] button:not(.icon-button):not(.name-button):hover {
      box-shadow: 0 6px 16px rgba(92, 124, 250, 0.4), 0 4px 8px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.15);
    }

    [data-theme="dark"] .icon-button {
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    [data-theme="dark"] .icon-button:hover {
      box-shadow: 0 4px 8px rgba(92, 124, 250, 0.3), 0 2px 4px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    [data-theme="dark"] .player-score-value {
      background: linear-gradient(135deg, rgba(92, 124, 250, 0.25), rgba(92, 124, 250, 0.15));
      border-color: rgba(92, 124, 250, 0.4);
      box-shadow: 0 2px 6px rgba(92, 124, 250, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    [data-theme="dark"] .player-score-value:hover {
      background: linear-gradient(135deg, rgba(92, 124, 250, 0.35), rgba(92, 124, 250, 0.2));
      border-color: rgba(92, 124, 250, 0.5);
      box-shadow: 0 4px 12px rgba(92, 124, 250, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.15);
    }

    [data-theme="dark"] #bestStreakDisplay {
      background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(245, 158, 11, 0.15));
      border-color: rgba(245, 158, 11, 0.4);
      box-shadow: 0 2px 6px rgba(245, 158, 11, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    [data-theme="dark"] #bestStreakDisplay:hover {
      background: linear-gradient(135deg, rgba(245, 158, 11, 0.25), rgba(245, 158, 11, 0.2));
      border-color: rgba(245, 158, 11, 0.5);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.15);
    }

    [data-theme="dark"] #currentStreakDisplay {
      background: linear-gradient(135deg, rgba(92, 124, 250, 0.2), rgba(92, 124, 250, 0.15));
      border-color: rgba(92, 124, 250, 0.4);
      box-shadow: 0 2px 6px rgba(92, 124, 250, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    [data-theme="dark"] #currentStreakDisplay:hover {
      background: linear-gradient(135deg, rgba(92, 124, 250, 0.25), rgba(92, 124, 250, 0.2));
      border-color: rgba(92, 124, 250, 0.5);
      box-shadow: 0 4px 12px rgba(92, 124, 250, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.15);
    }

    [data-theme="dark"] input[type="text"],
    [data-theme="dark"] input[type="password"] {
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    [data-theme="dark"] input[type="text"]:focus,
    [data-theme="dark"] input[type="password"]:focus {
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 0 0 3px rgba(92, 124, 250, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.08);
    }

    [data-theme="dark"] .app {
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), 0 8px 24px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    [data-theme="dark"] #board-wrapper {
      box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.4), 0 4px 12px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(203, 213, 225, 0.15);
    }

    #status {
      font-size: 15px;
      text-align: center;
      font-weight: 600;
      font-family: 'Inter', system-ui, sans-serif;
      flex: 1;
      width: 100%;
    }

    #shareGameResultBtn {
      visibility: hidden;
      pointer-events: none;
      width: 0;
      min-width: 0;
      padding: 0;
      margin: 0;
      overflow: hidden;
      border: none;
    }

    #shareGameResultBtn.visible {
      visibility: visible;
      pointer-events: auto;
      width: auto;
      min-width: 36px;
      padding: 0 10px;
      margin: 0;
      overflow: visible;
      border: 1px solid var(--accent);
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    #shareGameResultBtn.visible:hover {
      background: var(--accent-hover);
      border-color: var(--accent-hover);
    }

    #status .mark-X {
      color: var(--x-color);
      font-weight: 700;
    }

    #status .mark-O {
      color: var(--o-color);
      font-weight: 700;
    }

    #controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 6px;
      flex-wrap: wrap;
      align-items: center;
    }

    #restartBtn.forfeit-button {
      background: linear-gradient(135deg, #dc2626, #b91c1c);
      border-color: #991b1b;
      color: white;
      font-weight: 600;
      box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }

    #restartBtn.forfeit-button:hover {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      border-color: #b91c1c;
      box-shadow: 0 4px 12px rgba(220, 38, 38, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }

    #restartBtn.forfeit-button:active {
      transform: translateY(0);
      box-shadow: 0 2px 6px rgba(220, 38, 38, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    [data-theme="dark"] #restartBtn.forfeit-button {
      background: linear-gradient(135deg, rgba(220, 38, 38, 0.9), rgba(185, 28, 28, 0.85));
      border-color: rgba(153, 27, 27, 0.6);
      box-shadow: 0 2px 8px rgba(220, 38, 38, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    [data-theme="dark"] #restartBtn.forfeit-button:hover {
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.95), rgba(220, 38, 38, 0.9));
      border-color: rgba(185, 28, 28, 0.8);
      box-shadow: 0 4px 12px rgba(220, 38, 38, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.15);
    }

    .icon-button {
      padding: 8px;
      border-radius: var(--radius-md);
      border: 1px solid var(--input-border);
      background: var(--cell-bg);
      color: var(--text-primary);
      font-size: 16px;
      cursor: pointer;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: var(--shadow-sm);
      display: flex;
      align-items: center;
      justify-content: center;
      height: 36px;
      min-width: 36px;
      box-sizing: border-box;
    }

    .icon-button.name-bar-info {
      height: auto;
      min-height: 34px;
      align-self: stretch;
    }

    .icon-button:hover {
      background: var(--cell-bg-hover);
      border-color: var(--accent);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .icon-button:active {
      transform: scale(0.95);
    }

    .icon-button:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .icon-button.muted {
      opacity: 0.5;
    }

    .icon-button.muted:hover {
      opacity: 0.7;
    }

    /* Stats Modal */
    #statsModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.4);
      z-index: 2000;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      opacity: 0;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #statsModal.show {
      display: flex;
      opacity: 1;
    }

    #statsContent {
      background: var(--glass-bg);
      border-radius: var(--radius-xl);
      padding: 28px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      color: var(--text-primary);
      box-sizing: border-box;
      -webkit-overflow-scrolling: touch;
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #statsModal.show #statsContent {
      transform: scale(1);
    }

    #statsContent h2 {
      margin: 0 0 20px 0;
      font-size: 20px;
      font-weight: 700;
      text-align: center;
      background: linear-gradient(135deg, var(--accent), #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    #statsColumns {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    .stats-column h3 {
      margin: 0 0 14px 0;
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
      text-align: center;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--input-border);
    }

    .stat-item {
      display: flex;
      justify-content: space-between;
      padding: 12px 0;
      border-bottom: 1px solid var(--input-border);
      transition: background 0.2s ease;
      border-radius: var(--radius-sm);
      padding-left: 8px;
      padding-right: 8px;
    }

    .stat-item:hover {
      background: rgba(99, 102, 241, 0.05);
    }

    .stat-item:last-child {
      border-bottom: none;
    }

    .stat-label {
      color: var(--text-secondary);
      font-weight: 500;
    }

    .stat-value {
      color: var(--text-primary);
      font-weight: 700;
      font-size: 16px;
    }

    #closeStats {
      margin-top: 16px;
      width: 100%;
    }

    /* Leaderboard Modal */
    #leaderboardModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 2800;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      opacity: 0;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #leaderboardModal.show {
      display: flex;
      opacity: 1;
    }

    #leaderboardModalContent {
      background: var(--glass-bg);
      border-radius: var(--radius-xl);
      padding: 0;
      max-width: 420px;
      width: 90%;
      max-height: 75vh;
      box-shadow: var(--shadow-xl), 0 0 40px rgba(99, 102, 241, 0.15);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      color: var(--text-primary);
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      transform: scale(0.95);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden;
    }

    #leaderboardModal.show #leaderboardModalContent {
      transform: scale(1);
    }

    #leaderboardModalHeader {
      padding: 20px 24px;
      border-bottom: 1px solid var(--input-border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.05));
    }

    #leaderboardModalHeader h2 {
      margin: 0;
      font-size: 20px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent), #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    #leaderboardModalClose {
      width: 36px;
      height: 36px;
      min-width: 36px;
      min-height: 36px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      border-radius: var(--radius-md);
      border: 1px solid var(--input-border);
      background: var(--cell-bg);
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    #leaderboardModalClose:hover {
      background: var(--cell-bg-hover);
      color: var(--text-primary);
      border-color: var(--accent);
    }

    #leaderboardContent {
      overflow-y: auto;
      overflow-x: hidden;
      flex: 1;
      min-height: 0;
      padding: 12px;
      -webkit-overflow-scrolling: touch;
    }

    .leaderboard-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 16px;
      margin-bottom: 6px;
      border-radius: var(--radius-md);
      transition: background 0.2s ease;
      border: 1px solid transparent;
    }

    .leaderboard-row:hover {
      background: rgba(99, 102, 241, 0.06);
    }

    .leaderboard-row.you {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.15), rgba(139, 92, 246, 0.1));
      border-color: rgba(99, 102, 241, 0.3);
      box-shadow: 0 0 0 1px rgba(99, 102, 241, 0.2);
    }

    .leaderboard-rank {
      font-weight: 700;
      font-size: 18px;
      width: 40px;
      text-align: center;
      flex-shrink: 0;
    }

    .leaderboard-rank.gold { color: #f59e0b; }
    .leaderboard-rank.silver { color: #94a3b8; }
    .leaderboard-rank.bronze { color: #b45309; }

    .leaderboard-player {
      flex: 1;
      min-width: 0;
      padding: 0 16px;
    }

    .leaderboard-player-name {
      font-weight: 600;
      font-size: 15px;
    }

    .leaderboard-player-stats {
      font-size: 12px;
      color: var(--text-secondary);
      margin-top: 2px;
    }

    .leaderboard-points {
      text-align: right;
      flex-shrink: 0;
    }

    .leaderboard-points-value {
      font-weight: 700;
      font-size: 18px;
      color: var(--accent);
    }

    .leaderboard-points-label {
      font-size: 11px;
      color: var(--text-secondary);
    }

    /* Achievements */
    .achievements-section {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 2px solid var(--input-border);
    }

    .achievements-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }

    .achievement-item {
      background: var(--player-tag-bg);
      border: 1px solid var(--input-border);
      border-radius: var(--radius-lg);
      padding: 14px;
      text-align: center;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: var(--shadow-sm);
    }

    .achievement-item.unlocked {
      border-color: rgba(251, 191, 36, 0.5);
      background: rgba(251, 191, 36, 0.08);
      box-shadow: var(--shadow-md);
      position: relative;
      overflow: hidden;
    }

    .achievement-item.unlocked::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      animation: shimmer 3s infinite;
    }

    @keyframes shimmer {
      0% { left: -100%; }
      100% { left: 100%; }
    }

    .achievement-item:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .achievement-item.locked {
      opacity: 0.45;
      filter: grayscale(100%);
    }

    .achievement-icon {
      font-size: 32px;
      margin-bottom: 6px;
    }

    .achievement-name {
      font-weight: 600;
      font-size: 12px;
      color: var(--text-primary);
      margin-bottom: 4px;
    }

    .achievement-desc {
      font-size: 10px;
      color: var(--text-secondary);
      line-height: 1.3;
    }

    /* Achievements Modal */
    #trophyModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.4);
      z-index: 2000;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      opacity: 0;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #trophyModal.show {
      display: flex;
      opacity: 1;
    }

    #trophyContent {
      background: var(--glass-bg);
      border-radius: var(--radius-xl);
      padding: 28px;
      max-width: 700px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      color: var(--text-primary);
      box-sizing: border-box;
      -webkit-overflow-scrolling: touch;
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #trophyModal.show #trophyContent {
      transform: scale(1);
    }

    #trophyContent h2 {
      margin: 0 0 20px 0;
      font-size: 20px;
      font-weight: 700;
      text-align: center;
      background: linear-gradient(135deg, #fbbf24, #f59e0b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .achievement-notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--glass-bg);
      border: 1px solid rgba(251, 191, 36, 0.5);
      border-radius: var(--radius-lg);
      padding: 16px 20px;
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      z-index: 3000;
      animation: slideInRight 0.5s ease-out;
      max-width: 300px;
    }

    @keyframes slideInRight {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .achievement-notification-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 6px;
    }

    .achievement-notification-icon {
      font-size: 24px;
    }

    .achievement-notification-title {
      font-weight: 700;
      color: var(--text-primary);
      font-size: 14px;
    }

    .achievement-notification-desc {
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* Share modal (fallback when Web Share API unavailable) */
    #shareModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.4);
      z-index: 2500;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      opacity: 0;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #shareModal.show {
      display: flex;
      opacity: 1;
    }

    #shareModalContent {
      background: var(--glass-bg);
      border-radius: var(--radius-xl);
      padding: 28px;
      max-width: 360px;
      width: 90%;
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      color: var(--text-primary);
      box-sizing: border-box;
      -webkit-overflow-scrolling: touch;
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #shareModal.show #shareModalContent {
      transform: scale(1);
    }

    #shareModalContent h3 {
      margin: 0 0 16px 0;
      font-size: 16px;
      text-align: center;
      background: linear-gradient(135deg, var(--accent), #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    /* Name Selection Modal (shown when no cached name) */
    #nameSelectionModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 3000;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      opacity: 0;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #nameSelectionModal.show {
      display: flex;
      opacity: 1;
    }

    #nameSelectionModalContent {
      background: var(--glass-bg);
      border-radius: var(--radius-xl);
      padding: 28px;
      max-width: 480px;
      width: 90%;
      max-width: min(480px, calc(100vw - 32px));
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      color: var(--text-primary);
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin: 0 auto;
      align-items: center;
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #nameSelectionModal.show #nameSelectionModalContent {
      transform: scale(1);
    }

    #nameSelectionModalContent h3 {
      margin: 0;
      font-size: 20px;
      font-weight: 700;
      text-align: center;
      background: linear-gradient(135deg, var(--accent), #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    #nameSelectionInput,
    #nameSelectionPassword {
      width: 100% !important;
      max-width: 100% !important;
      box-sizing: border-box;
      text-align: center;
    }

    #nameSelectionPasswordSection {
      width: 100%;
    }

    /* Registration/Login Modal */
    #registerModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.4);
      z-index: 2500;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      opacity: 0;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #registerModal.show {
      display: flex;
      opacity: 1;
    }

    #registerModalContent {
      background: var(--glass-bg);
      border-radius: var(--radius-xl);
      padding: 24px;
      max-width: 480px;
      width: 90%;
      max-width: min(480px, calc(100vw - 32px));
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      color: var(--text-primary);
      box-sizing: border-box;
      -webkit-overflow-scrolling: touch;
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin: 0 auto;
      align-items: center;
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #registerModal.show #registerModalContent {
      transform: scale(1);
    }

    #registerModalContent h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      text-align: center;
      background: linear-gradient(135deg, var(--accent), #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    #registerModalMessage {
      margin: 0 !important;
      padding: 0;
      line-height: 1.4;
      word-wrap: break-word;
    }

    #registerPassword {
      width: 100% !important;
      max-width: 100% !important;
      margin-bottom: 0 !important;
      box-sizing: border-box;
      text-align: center;
    }

    #registerModalContent > div[style*="display: flex"] {
      display: flex !important;
      gap: 8px;
      flex-direction: column;
      width: 100%;
      align-items: stretch;
    }

    #registerModalContent > div[style*="display: flex"] > div[style*="display: flex"] {
      display: flex !important;
      gap: 8px;
      flex-direction: row;
      width: 100%;
    }

    #registerModalContent button:not(#registerSkipBtn) {
      flex: 1;
      min-width: 0;
      box-sizing: border-box;
    }

    #registerSkipBtn {
      width: 100% !important;
      background: rgba(34, 197, 94, 0.1) !important;
      border-color: rgba(34, 197, 94, 0.3) !important;
      color: rgb(34, 197, 94) !important;
      font-weight: 600 !important;
      margin-top: 4px !important;
      font-size: 12px !important;
      padding: 8px 16px !important;
      transition: all 0.2s ease !important;
    }

    #registerSkipBtn:hover {
      background: rgba(34, 197, 94, 0.2) !important;
      border-color: rgba(34, 197, 94, 0.5) !important;
      color: rgb(22, 163, 74) !important;
      transform: translateY(-1px) !important;
    }

    #registerSkipBtn:active {
      transform: translateY(0) !important;
    }

    #nameSelectionStartBtn {
      background: rgb(34, 197, 94) !important;
      border-color: rgb(34, 197, 94) !important;
      color: white !important;
      font-weight: 700 !important;
    }

    #nameSelectionStartBtn:hover {
      background: rgb(22, 163, 74) !important;
      border-color: rgb(22, 163, 74) !important;
      color: white !important;
      transform: translateY(-1px);
    }

    #nameSelectionStartBtn:active {
      transform: translateY(0);
    }

    #nameSelectionRegisterBtn {
      background: var(--accent) !important;
      color: white !important;
      border-color: var(--accent) !important;
      font-weight: 700 !important;
    }

    #nameSelectionRegisterBtn:hover {
      background: var(--accent-hover) !important;
      border-color: var(--accent-hover) !important;
      color: white !important;
      transform: translateY(-1px);
    }

    #nameSelectionRegisterBtn:active {
      transform: translateY(0);
    }

    /* Multiplayer Room Modal */
    #roomModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.4);
      z-index: 2500;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      opacity: 0;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #roomModal.show {
      display: flex;
      opacity: 1;
    }

    #roomModalContent {
      background: var(--glass-bg);
      border-radius: var(--radius-xl);
      padding: 24px;
      max-width: 400px;
      width: 90%;
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      color: var(--text-primary);
      box-sizing: border-box;
      -webkit-overflow-scrolling: touch;
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #roomModal.show #roomModalContent {
      transform: scale(1);
    }

    #roomModalContent h3 {
      margin: 0 0 16px 0;
      font-size: 18px;
      font-weight: 600;
      text-align: center;
      background: linear-gradient(135deg, var(--accent), #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    #modeToggle.multiplayer {
      background: rgba(34, 197, 94, 0.9);
      border-color: rgba(34, 197, 94, 1);
    }

    #modeToggle.multiplayer:hover {
      background: rgba(34, 197, 94, 1);
    }

    .share-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin-bottom: 12px;
    }

    .share-buttons a,
    .share-buttons button {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 16px;
      border-radius: var(--radius-md);
      font-size: 14px;
      font-weight: 500;
      text-decoration: none;
      color: var(--text-primary);
      background: var(--cell-bg);
      border: 1px solid var(--input-border);
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: var(--shadow-sm);
    }

    .share-buttons a:hover,
    .share-buttons button:hover {
      background: var(--cell-bg-hover);
      border-color: var(--accent);
    }

    #shareModalClose {
      display: block;
      width: 100%;
      margin-top: 12px;
    }

    #roomModalLeaderboardBtn {
      width: 100%;
      margin-top: 12px;
      padding: 12px 16px;
      border-radius: var(--radius-md);
      border: 2px solid #d97706;
      background: linear-gradient(135deg, #fbbf24, #f59e0b);
      color: #78350f;
      font-weight: 700;
      font-size: 15px;
      cursor: pointer;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 3px 10px rgba(217, 119, 6, 0.35), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-family: 'Inter', system-ui, sans-serif;
    }

    #roomModalLeaderboardBtn:hover {
      background: linear-gradient(135deg, #fcd34d, #f59e0b);
      border-color: #b45309;
      transform: translateY(-2px);
      box-shadow: 0 5px 16px rgba(217, 119, 6, 0.45), inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }

    #roomModalLeaderboardBtn:active {
      transform: translateY(0);
      box-shadow: 0 2px 8px rgba(217, 119, 6, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }

    [data-theme="dark"] #roomModalLeaderboardBtn {
      border-color: rgba(251, 191, 36, 0.6);
      background: linear-gradient(135deg, rgba(251, 191, 36, 0.15), rgba(245, 158, 11, 0.1));
      color: #fbbf24;
      box-shadow: 0 2px 8px rgba(251, 191, 36, 0.25);
    }

    [data-theme="dark"] #roomModalLeaderboardBtn:hover {
      background: linear-gradient(135deg, rgba(251, 191, 36, 0.25), rgba(245, 158, 11, 0.15));
      border-color: rgba(251, 191, 36, 0.8);
      box-shadow: 0 4px 12px rgba(251, 191, 36, 0.35);
    }

    /* Forfeit Modal - Popup above game (aligned with roomModal) */
    #forfeitModal,
    #playAgainModal,
    #setCompleteModal,
    #matchResultModal,
    #rematchDeclineResultModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.4);
      z-index: 3000;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      opacity: 0;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #forfeitModal.show,
    #playAgainModal.show,
    #setCompleteModal.show,
    #matchResultModal.show,
    #rematchDeclineResultModal.show {
      display: flex;
      opacity: 1;
    }

    #forfeitModal .modal-content,
    #playAgainModal .modal-content,
    #setCompleteModal .modal-content,
    #matchResultModal .modal-content,
    #rematchDeclineResultModal .modal-content {
      background: var(--glass-bg);
      border-radius: var(--radius-xl);
      padding: 28px;
      max-width: min(500px, calc(100vw - 32px));
      width: 90%;
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      color: var(--text-primary);
      box-sizing: border-box;
      -webkit-overflow-scrolling: touch;
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #forfeitModal.show .modal-content,
    #playAgainModal.show .modal-content,
    #setCompleteModal.show .modal-content,
    #matchResultModal.show .modal-content,
    #rematchDeclineResultModal.show .modal-content {
      transform: scale(1);
    }

    #setCompleteModal .modal-content h3.you-win {
      color: var(--success);
      text-shadow: 0 0 10px rgba(34, 197, 94, 0.3);
    }
    #setCompleteModal .modal-content h3.you-lose {
      color: var(--error);
      text-shadow: 0 0 10px rgba(239, 68, 68, 0.3);
    }
    #setCompleteModal .modal-content h3.draw {
      color: var(--text-secondary);
    }

    #matchResultModal .modal-content h3 {
      text-align: center;
      margin-bottom: 16px;
    }

    #matchResultModal .modal-content h3.you-win {
      color: var(--success);
      text-shadow: 0 0 10px rgba(34, 197, 94, 0.3);
    }

    #matchResultModal .modal-content h3.you-lose {
      color: var(--error);
      text-shadow: 0 0 10px rgba(239, 68, 68, 0.3);
    }

    #matchResultModal .modal-content h3.draw {
      color: var(--text-secondary);
    }


    /* Confetti container */
    #confettiContainer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1500;
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #ffd700;
      animation: confettiFall linear forwards;
    }

    @keyframes confettiFall {
      to {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
      }
    }

    /* Smooth piece placement */
    .cell.placing {
      animation: placePiece 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      will-change: transform;
    }

    @keyframes placePiece {
      0% {
        transform: scale(0);
      }
      50% {
        transform: scale(1.15);
      }
      100% {
        transform: scale(1);
      }
    }

    button:not(.icon-button):not(.name-button) {
      padding: 10px 20px;
      border-radius: var(--radius-md);
      border: none;
      background: linear-gradient(135deg, var(--accent), var(--accent-hover));
      color: white;
      font-size: 14px;
      font-weight: 600;
      font-family: 'Inter', system-ui, sans-serif;
      cursor: pointer;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: var(--shadow-md);
      display: flex;
      align-items: center;
      justify-content: center;
      height: 40px;
      box-sizing: border-box;
      letter-spacing: 0.01em;
      position: relative;
      overflow: hidden;
    }

    button:not(.icon-button):not(.name-button)::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.3);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }

    button:not(.icon-button):not(.name-button):active::before {
      width: 300px;
      height: 300px;
    }

    button:not(.icon-button):not(.name-button):hover {
      background: linear-gradient(135deg, var(--accent-hover), var(--accent));
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    button:not(.icon-button):not(.name-button):active {
      transform: translateY(0) scale(0.98);
      box-shadow: var(--shadow-md);
    }

    button:not(.icon-button):not(.name-button):focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    #board-wrapper {
      background: var(--board-bg);
      padding: 8px;
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-soft-inner), var(--shadow-md);
      width: fit-content;
      max-width: 100%;
      margin: 0 auto;
      box-sizing: border-box;
      overflow: hidden;
    }

    #board {
      display: grid;
      grid-template-columns: repeat(9, minmax(0, 1fr));
      grid-template-rows: repeat(9, minmax(0, 1fr));
      gap: 5px;
      width: min(412px, calc(100vw - 32px));
      aspect-ratio: 1;
      box-sizing: border-box;
      isolation: isolate;
    }

    .cell {
      width: 100%;
      height: 100%;
      min-width: 0;
      min-height: 0;
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--cell-bg);
      cursor: pointer;
      font-size: 26px;
      font-weight: 700;
      font-family: 'Inter', system-ui, sans-serif;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-sm);
      border: 1px solid rgba(0, 0, 0, 0.08);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      user-select: none;
      position: relative;
      overflow: hidden;
      box-sizing: border-box;
      isolation: isolate;
    }

    .cell::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.6), transparent 70%);
      opacity: 0;
      transition: opacity 0.2s ease;
      pointer-events: none;
    }

    .cell:hover {
      background: var(--cell-bg-hover);
      transform: scale(1.03);
      box-shadow: var(--shadow-md);
      z-index: 1;
      border-color: rgba(99, 102, 241, 0.2);
    }

    .cell:hover::after {
      opacity: 1;
    }

    .cell.X {
      color: var(--x-color);
      animation: popIn 0.2s ease-out;
    }

    .cell.O {
      color: var(--o-color);
      animation: popIn 0.2s ease-out;
    }

    .cell.last-move {
      box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.6);
    }

    .cell.preview-X::before,
    .cell.preview-O::before {
      content: attr(data-preview);
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 26px;
      font-weight: 700;
      opacity: 0.25;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    .cell.preview-X {
      border-color: rgba(239, 68, 68, 0.4);
      box-shadow: 0 0 0 1px rgba(239, 68, 68, 0.2), 0 2px 4px rgba(239, 68, 68, 0.1);
    }

    .cell.preview-X::before {
      color: var(--x-color);
    }

    .cell.preview-O {
      border-color: rgba(59, 130, 246, 0.4);
      box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.2), 0 2px 4px rgba(59, 130, 246, 0.1);
    }

    .cell.preview-O::before {
      color: var(--o-color);
    }

    .cell.win {
      background: linear-gradient(135deg, #fef3c7, #fde68a, #fbbf24);
      background-size: 200% 200%;
      box-shadow: 0 0 0 2px rgba(217, 119, 6, 0.5);
      color: #92400e;
      animation: pulseWin 1s ease-in-out infinite, gradientShiftWin 3s ease infinite;
      position: relative;
    }

    .cell.win::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(135deg, rgba(251, 191, 36, 0.4), transparent);
      animation: glowOverlay 2s ease-in-out infinite;
    }

    @keyframes pulseWin {
      0%, 100% {
        transform: scale(1);
        box-shadow: 0 0 0 2px rgba(217, 119, 6, 0.85), 0 5px 14px rgba(180, 83, 9, 0.6), 0 0 20px rgba(251, 191, 36, 0.4);
      }
      50% {
        transform: scale(1.05);
        box-shadow: 0 0 0 3px rgba(217, 119, 6, 1), 0 7px 20px rgba(180, 83, 9, 0.8), 0 0 30px rgba(251, 191, 36, 0.6);
      }
    }

    @keyframes gradientShiftWin {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    @keyframes glowOverlay {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.6; }
    }

    #contactLink {
      display: block;
      text-align: center;
      margin-top: 8px;
      font-size: 12px;
      color: var(--text-secondary);
      text-decoration: none;
      opacity: 0.75;
      transition: opacity 0.2s ease;
    }

    #contactLink:hover {
      text-decoration: underline;
      opacity: 1;
    }

    #themeToggle {
      padding: 8px;
      border-radius: var(--radius-md);
      border: 1px solid var(--input-border);
      background: var(--cell-bg);
      color: var(--text-primary);
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: var(--shadow-sm);
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 36px;
      height: 36px;
    }

    #themeToggle:hover {
      background: var(--cell-bg-hover);
      border-color: var(--accent);
    }

    #themeToggle:active {
      transform: scale(0.98);
    }

    @keyframes popIn {
      from {
        transform: scale(0.2);
        opacity: 0;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    @keyframes glow {
      from {
        box-shadow: 0 0 0 2px rgba(217, 119, 6, 0.3), 0 6px 16px rgba(180, 83, 9, 0.5);
      }
      to {
        box-shadow: 0 0 0 3px rgba(217, 119, 6, 0.8), 0 7px 20px rgba(180, 83, 9, 0.75);
      }
    }

    /* Responsive design */
    @media (max-width: 600px) {
      body {
        padding: 8px;
        align-items: flex-start;
        padding-top: 12px;
      }

      .app {
        padding: 6px 6px;
        border-radius: 16px;
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
      }

      h1 {
        font-size: 18px;
        margin-bottom: 6px;
      }

      #streak-bar {
        font-size: 10px;
        gap: 6px;
        flex-wrap: nowrap;
        margin-bottom: 10px;
        overflow: hidden;
      }

      #streak-bar #modeToggleSwitch {
        position: absolute;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
      }

      #bestStreakDisplay {
        flex: 0 1 auto;
        min-width: 0;
        max-width: calc(50% - 40px);
        overflow: hidden;
        text-overflow: ellipsis;
        font-size: 11px;
        padding: 3px 6px;
      }

      #currentStreakDisplay {
        margin-left: auto;
        flex-shrink: 0;
        font-size: 11px;
        padding: 3px 6px;
        max-width: calc(50% - 40px);
      }

      #multiplayer-score-bar {
        overflow: hidden;
      }

      .player-score-row {
        grid-template-columns: 1fr auto 1fr;
        gap: 6px;
        overflow: hidden;
      }

      .player-score-item-left,
      .player-score-item-right {
        min-width: 0;
      }

      .player-name-display {
        font-size: 11px;
        max-width: 80px;
      }

      .player-score-value {
        font-size: 16px;
        padding: 3px 8px;
        min-width: 32px;
      }

      #board-wrapper {
        padding: 6px;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        max-width: 100%;
        box-sizing: border-box;
      }

      #board {
        width: min(360px, calc(100vw - 32px));
        gap: 4px;
      }

      .cell {
        font-size: clamp(16px, 4vw, 20px);
        border-radius: 6px;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.06);
      }

      .cell:hover {
        box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);
      }

      #statusRow {
        width: min(360px, calc(100vw - 32px));
        max-width: calc(100% - 12px);
        padding: 6px 8px;
        gap: 8px;
      }

      #status {
        font-size: 13px;
        padding: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      button:not(.icon-button):not(.name-button) {
        padding: 8px 14px;
        font-size: 13px;
        min-height: 36px;
        width: auto;
      }
      
      .icon-button {
        min-width: 36px;
        min-height: 36px;
        padding: 8px;
      }

      .player-name-input {
        min-width: 100px;
        max-width: 150px;
        font-size: 12px;
        padding: 6px 8px;
        min-height: 32px;
        box-sizing: border-box;
      }

      .name-button {
        font-size: 11px;
        padding: 4px 8px;
        min-height: 32px;
        flex-shrink: 0;
      }
      
      #players {
        gap: 6px;
        flex-wrap: wrap;
        justify-content: center;
      }

      #modeToggleSwitch,
      #modeToggleSwitchMultiplayer {
        min-width: 56px;
        height: 22px;
        padding: 2px;
      }

      .mode-option {
        font-size: 11px;
        padding: 2px 4px;
      }

      .mode-slider {
        top: 2px;
        left: 2px;
        width: calc(50% - 2px);
        height: calc(100% - 4px);
      }

      .modal-content {
        max-width: calc(100vw - 32px);
        margin: 20px auto;
        padding: 16px;
        max-height: calc(100vh - 40px);
        overflow-y: auto;
      }


      .achievements-grid {
        grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
        gap: 8px;
      }

      .achievement-item {
        padding: 8px;
      }

      .achievement-icon {
        font-size: 24px;
      }

      .achievement-name {
        font-size: 11px;
      }

      .achievement-desc {
        font-size: 9px;
      }


      #trophyContent,
      #shareModalContent,
      #registerModalContent,
      #roomModalContent,
      #nameSelectionModalContent {
        max-width: calc(100vw - 20px);
        width: calc(100vw - 20px);
        padding: 16px;
        max-height: calc(100vh - 20px);
      }

      #registerModalContent {
        padding: 16px;
        gap: 10px;
        max-width: min(480px, calc(100vw - 20px));
        width: calc(100vw - 20px);
      }

      #nameSelectionModalContent {
        padding: 20px;
        gap: 12px;
      }

      #nameSelectionModalContent h3 {
        font-size: 18px;
      }

      #nameSelectionInput,
      #nameSelectionPassword {
        font-size: 14px;
        padding: 10px;
        min-height: 44px;
      }

      #nameSelectionStartBtn,
      #nameSelectionRegisterBtn,
      #nameSelectionLoginBtn {
        min-height: 44px;
        font-size: 15px;
      }

      #nameSelectionMessage {
        font-size: 13px !important;
      }

      #nameSelectionWarning {
        font-size: 12px !important;
      }

      #registerModalContent h3 {
        font-size: 16px;
      }

      #registerModalMessage {
        font-size: 12px !important;
      }

      #registerPassword {
        font-size: 14px;
        padding: 8px 10px;
        min-height: 40px;
        text-align: center;
      }

      #registerModalContent button:not(#registerSkipBtn) {
        min-height: 40px;
        font-size: 14px;
      }

      #registerSkipBtn {
        min-height: 40px;
        font-size: 13px !important;
        padding: 8px 12px !important;
      }

      #statsContent {
        padding: 12px;
      }
    }

    @media (max-width: 400px) {
      body {
        padding: 6px;
      }

      .app {
        padding: 4px 4px;
      }

      h1 {
        font-size: 16px;
        margin-bottom: 4px;
      }

      #streak-bar {
        font-size: 9px;
        gap: 4px;
        margin-bottom: 8px;
      }

      #bestStreakDisplay {
        font-size: 10px;
        padding: 2px 5px;
        max-width: calc(50% - 35px);
      }

      #currentStreakDisplay {
        font-size: 10px;
        padding: 2px 5px;
        max-width: calc(50% - 35px);
      }

      .player-name-display {
        font-size: 10px;
        max-width: 70px;
      }

      .player-score-value {
        font-size: 14px;
        padding: 2px 6px;
        min-width: 28px;
      }

      #board-wrapper {
        padding: 6px;
      }

      #board {
        width: min(286px, calc(100vw - 24px));
        gap: 3px;
      }
      
      .cell {
        font-size: clamp(14px, 3.5vw, 16px);
        box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
      }

      .cell:hover {
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
      }

      #statusRow {
        width: min(286px, calc(100vw - 24px));
        max-width: calc(100% - 8px);
        padding: 5px 6px;
        gap: 6px;
        min-height: 32px;
      }

      #status {
        font-size: 12px;
      }

      button:not(.icon-button):not(.name-button) {
        padding: 6px 12px;
        font-size: 12px;
        min-height: 32px;
      }

      .icon-button {
        min-width: 32px;
        min-height: 32px;
        padding: 6px;
      }

      .player-name-input {
        min-width: 90px;
        max-width: 120px;
        font-size: 11px;
        padding: 5px 6px;
        min-height: 30px;
      }

      .name-button {
        font-size: 10px;
        padding: 4px 6px;
        min-height: 30px;
      }

      #modeToggleSwitch,
      #modeToggleSwitchMultiplayer {
        min-width: 52px;
        height: 20px;
        padding: 1px;
      }

      .mode-option {
        font-size: 10px;
        padding: 2px 3px;
      }

      .mode-slider {
        top: 1px;
        left: 1px;
        width: calc(50% - 1px);
        height: calc(100% - 2px);
      }
    }

    @media (min-width: 601px) and (max-width: 900px) {
      .app {
        max-width: 480px;
      }

      #board-wrapper {
        padding: 6px;
      }

      #board {
        width: min(366px, calc(100vw - 48px));
        gap: 3px;
      }

      .cell {
        font-size: clamp(20px, 2.5vw, 22px);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.07);
      }

      .cell:hover {
        box-shadow: 0 2px 3px rgba(0, 0, 0, 0.11);
      }

      #statusRow {
        width: min(366px, calc(100vw - 48px));
        max-width: calc(100% - 16px);
      }
    }

    @media (min-width: 901px) and (max-width: 1199px) {
      .app {
        max-width: 520px;
      }
    }

    @media (min-width: 1200px) {
      .app {
        max-width: 500px;
      }
    }

    /* Prevent text overflow and ensure proper scaling */
    * {
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Ensure modals are responsive */
    @media (max-width: 600px) {
      .modal {
        padding: 10px;
      }

      .modal-content {
        width: calc(100vw - 20px);
        max-width: calc(100vw - 20px);
        margin: 10px auto;
        padding: 12px;
      }

      #forfeitModal .modal-content {
        width: calc(100vw - 40px);
        max-width: calc(100vw - 40px);
        padding: 20px;
      }
    }
  </style>
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
</head>
<body>
  <div class="app">
    <div id="streak-bar">
      <div id="bestStreakDisplay">Best streak: none</div>
      <div id="modeToggleSwitch" class="mode-toggle"></div>
      <div id="currentStreakDisplay">Streak: 0</div>
    </div>
    
    <!-- Waiting player prompt - slides in when open room waits 10+ sec (training mode only) -->
    <div id="waitingPlayerPromptContainer">
      <div id="waitingPlayerPrompt">
        <button id="joinWaitingRoomBtn" type="button">Opponent is waiting!</button>
      </div>
    </div>
    
    <!-- Multiplayer Score Display -->
    <div id="multiplayer-score-bar" style="display: none;">
      <div class="player-score-row">
        <div class="player-score-item-left">
          <div id="player1ScoreDisplay" class="player-score-value">0</div>
          <div id="player1NameDisplay" class="player-name-display">-</div>
        </div>
        <div id="modeToggleSwitchMultiplayer" class="mode-toggle"></div>
        <div class="player-score-item-right">
          <div id="player2NameDisplay" class="player-name-display">
            Waiting <span class="loading-dots"></span>
          </div>
          <div id="player2ScoreDisplay" class="player-score-value">0</div>
        </div>
      </div>
    </div>

    <h1>5-in-a-Row</h1>

    <div id="players">
      <div class="player-tag">
        <div class="player-dot X-dot"></div>
        <input
          id="humanName"
          class="player-name-input"
          type="text"
          placeholder="Your name"
        />
        <button id="applyHumanName" class="name-button" type="button">Set</button>
      </div>
      <button id="shareGameResultBtn" class="icon-button name-bar-info" aria-label="Share result" type="button"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><path d="m8.59 13.51 6.82 3.98"/><path d="m15.41 6.51-6.82 3.98"/></svg></button>
    </div>

    <!-- Multiplayer Room Modal -->
    <div id="roomModal">
      <div id="roomModalContent">
        <h3 id="roomModalTitle">Multiplayer</h3>
        <div id="roomModalBody">
          <div style="display: flex; flex-direction: column; gap: 10px;">
            <button id="quickMatchBtn" class="button" style="width: 100%;">Quick Match</button>
            <button id="createRoomBtn" class="button" style="width: 100%;">Create Room</button>
            <button id="joinRoomBtn" class="button" style="width: 100%;">Join Room</button>
          </div>
          <div id="roomIdSection" style="display: none; margin-top: 16px;">
            <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Room ID:</div>
            <div id="roomIdDisplay" style="font-size: 18px; font-weight: 700; font-family: monospace; background: var(--cell-bg); padding: 8px; border-radius: var(--radius-md); text-align: center; border: 1px solid var(--input-border);"></div>
            <button id="copyRoomIdBtn" class="icon-button" style="width: 100%; margin-top: 8px;"> Copy Room ID</button>
          </div>
          <div id="waitingRoomSection" style="display: none; margin-top: 16px; text-align: center;">
            <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 12px;">Waiting for opponent...</div>
            <div id="roomPlayers" style="display: flex; justify-content: space-around; gap: 16px;">
              <div>
                <div style="font-size: 12px; color: var(--text-secondary);">Player 1</div>
                <div id="roomPlayer1" style="font-weight: 600;">-</div>
              </div>
              <div>
                <div style="font-size: 12px; color: var(--text-secondary);">Player 2</div>
                <div id="roomPlayer2" style="font-weight: 600;">-</div>
              </div>
            </div>
          </div>
          <div id="joinRoomSection" style="display: none; margin-top: 16px;">
            <input id="joinRoomIdInput" type="text" class="player-name-input" placeholder="Enter Room ID" style="width: 100%; margin-bottom: 10px;" />
            <button id="joinRoomConfirmBtn" class="button" style="width: 100%;">Join</button>
          </div>
        </div>
        <button id="roomModalLeaderboardBtn"> Leaderboard</button>
        <button id="roomModalClose" class="icon-button" style="margin-top: 12px; width: 100%;">Close</button>
      </div>
    </div>

    <!-- Name Selection Modal (shown when no cached name) -->
    <div id="nameSelectionModal">
      <div id="nameSelectionModalContent">
        <h3>Welcome to 5-in-a-Row!</h3>
        <div id="nameSelectionMessage" style="font-size: 14px; color: var(--text-secondary); margin-bottom: 16px; text-align: center;">
          Enter your name to start playing (minimum 3 characters)
        </div>
        <input
          id="nameSelectionInput"
          type="text"
          class="player-name-input"
          placeholder="Your name"
          style="width: 100%; margin-bottom: 12px; text-align: center; font-size: 16px; padding: 10px;"
          autofocus
          minlength="3"
        />
        <div id="nameSelectionWarning" style="display: none; font-size: 13px; color: #dc2626; margin-bottom: 12px; text-align: center; font-weight: 500;">
          If you register your username, no one can claim your streaks!
        </div>
        <div id="nameSelectionPasswordSection" style="display: none; width: 100%; margin-bottom: 12px;">
          <input
            id="nameSelectionPassword"
            type="password"
            class="player-name-input"
            placeholder="Enter password"
            style="width: 100%; text-align: center; font-size: 16px; padding: 10px;"
          />
        </div>
        <div id="nameSelectionButtons" style="display: flex; gap: 8px; flex-direction: column;">
          <button id="nameSelectionStartBtn" class="button" style="width: 100%; display: none;">Play Unregistered</button>
          <button id="nameSelectionRegisterBtn" class="button" style="width: 100%; display: none;">Register Name</button>
          <button id="nameSelectionLoginBtn" class="button" style="width: 100%; display: none;">Login</button>
        </div>
      </div>
    </div>

    <!-- Registration/Login Modal -->
    <div id="registerModal">
      <div id="registerModalContent">
        <h3 id="registerModalTitle">Register Name</h3>
        <div id="registerModalMessage" style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px; text-align: center;"></div>
        <input
          id="registerPassword"
          type="password"
          class="player-name-input"
          placeholder="Enter password"
          style="width: 100%; margin-bottom: 10px;"
        />
        <div style="display: flex; gap: 8px; flex-direction: column;">
          <div style="display: flex; gap: 8px;">
            <button id="registerConfirmBtn" class="button" style="flex: 1;">Register</button>
            <button id="registerCancelBtn" class="icon-button" style="flex: 1;">Cancel</button>
          </div>
          <button id="registerSkipBtn" class="icon-button" style="margin-top: 4px; font-size: 12px; padding: 4px 8px;">Play without registering</button>
        </div>
      </div>
    </div>

    <div id="statusRow">
      <div id="status">Ready to play</div>
    </div>

    <div id="controls">
      <button id="restartBtn" title="Restart game (R or Space)">Restart game</button>
      <button id="statsBtn" class="icon-button" aria-label="Statistics"></button>
      <button id="leaderboardBtn" class="icon-button" aria-label="Leaderboard" style="display: none;"></button>
      <button id="trophyBtn" class="icon-button" aria-label="Achievements"></button>
      <button id="soundToggle" class="icon-button" aria-label="Toggle sound"></button>
      <button id="themeToggle" class="icon-button" aria-label="Toggle theme"></button>
    </div>

    <div id="board-wrapper">
      <div id="board"></div>
    </div>

    <a id="contactLink" href="mailto:stevan.toncic@gmail.com"> Contact</a>
  </div>

  <!-- Achievements Modal -->
  <div id="trophyModal">
    <div id="trophyContent">
      <h2> Achievements</h2>
      <div style="text-align: center; margin-bottom: 16px; color: var(--text-secondary); font-size: 13px;">
        Unlocked: <span id="trophyUnlockedCount">0</span>/8
      </div>
      <div class="achievements-grid" id="trophyAchievementsGrid"></div>
      <div id="achievementsShareRow" style="display: flex; gap: 8px; margin-top: 16px; flex-wrap: wrap; justify-content: center;">
        <button id="shareAchievementsBtn" class="button" type="button">Share my achievements</button>
      </div>
      <button id="closeTrophy" class="icon-button" style="margin-top: 16px; width: 100%;">Close</button>
    </div>
  </div>

  <!-- Achievement Notification -->
  <div id="achievementNotification" style="display: none;"></div>

  <!-- Share Modal (fallback when native share unavailable) -->
  <div id="shareModal">
    <div id="shareModalContent">
      <h3 id="shareModalTitle">Share</h3>
      <div class="share-buttons" id="shareButtons"></div>
      <button id="shareModalClose" class="icon-button">Close</button>
    </div>
  </div>

  <!-- Stats Modal -->
  <div id="statsModal">
    <div id="statsContent">
      <h2>Statistics</h2>
      <div id="statsColumns">
        <div class="stats-column">
          <h3 id="currentPlayerName">Current Player</h3>
          <div class="stat-item">
            <span class="stat-label">Games Played:</span>
            <span class="stat-value" id="statCurrentGamesPlayed">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Wins:</span>
            <span class="stat-value" id="statCurrentWins">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Losses:</span>
            <span class="stat-value" id="statCurrentLosses">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Draws:</span>
            <span class="stat-value" id="statCurrentDraws">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Win Rate:</span>
            <span class="stat-value" id="statCurrentWinRate">0%</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Current Streak:</span>
            <span class="stat-value" id="statCurrentStreak">0</span>
          </div>
        </div>
        <div class="stats-column">
          <h3>All Players</h3>
          <div class="stat-item">
            <span class="stat-label">Games Played:</span>
            <span class="stat-value" id="statGlobalGamesPlayed">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Wins:</span>
            <span class="stat-value" id="statGlobalWins">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Losses:</span>
            <span class="stat-value" id="statGlobalLosses">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Draws:</span>
            <span class="stat-value" id="statGlobalDraws">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Win Rate:</span>
            <span class="stat-value" id="statGlobalWinRate">0%</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Best Streak:</span>
            <span class="stat-value" id="statGlobalBestStreak">0</span>
          </div>
        </div>
      </div>
      <button id="closeStats" class="icon-button" style="margin-top: 16px; width: 100%;">Close</button>
    </div>
  </div>

  <!-- Leaderboard Modal -->
  <div id="leaderboardModal">
    <div id="leaderboardModalContent">
      <div id="leaderboardModalHeader">
        <h2> Leaderboard</h2>
        <button id="leaderboardModalClose" type="button" aria-label="Close"></button>
      </div>
      <div id="leaderboardContent"></div>
    </div>
  </div>

  <!-- Forfeit Modal -->
  <div id="forfeitModal">
    <div class="modal-content">
      <h3 style="margin-top: 0; margin-bottom: 16px;"> Game In Progress</h3>
      <p id="forfeitModalMessage" style="margin-bottom: 20px; color: var(--text-secondary);">
        You have an active game. Closing or refreshing the page will count as a forfeit (loss).
      </p>
      <div style="display: flex; gap: 10px; justify-content: flex-end;">
        <button id="forfeitContinueBtn" class="button" style="background: var(--accent);">Continue Playing</button>
        <button id="forfeitConfirmBtn" class="button" style="background: #dc2626;">Forfeit (Counts as Loss)</button>
      </div>
    </div>
  </div>

  <!-- Play Again Modal (when computer goes first) -->
  <div id="playAgainModal">
    <div class="modal-content">
      <h3 style="margin-top: 0; margin-bottom: 16px;"> Play it again!</h3>
      <p style="margin-bottom: 20px; color: var(--text-secondary);">
        Computer goes first this round. Click the "Start Game" button above when you're ready to play!
      </p>
      <div style="display: flex; gap: 10px; justify-content: flex-end;">
        <button id="playAgainStartBtn" class="button" style="background: var(--accent);">Start Game</button>
      </div>
    </div>
  </div>

  <!-- Set Complete Modal (shown to BOTH players after set 1  win, lose, or draw) -->
  <div id="setCompleteModal">
    <div class="modal-content">
      <h3 id="setCompleteModalTitle" style="margin-top: 0; margin-bottom: 16px; font-size: 24px; font-weight: 700;"></h3>
      <p style="margin-bottom: 20px; color: var(--text-secondary); font-size: 14px; text-align: center;">
        Set 2 will start shortly. Good luck!
      </p>
    </div>
  </div>

  <!-- Match Result Modal -->
  <div id="matchResultModal">
    <div class="modal-content" style="max-width: 500px;">
      <h3 id="matchResultTitle" style="margin-top: 0; margin-bottom: 16px; font-size: 24px; font-weight: 700;"></h3>
      <div id="matchResultDetails" style="margin-bottom: 20px; color: var(--text-secondary); font-size: 14px; line-height: 1.6;"></div>
      <div id="matchResultScore" style="margin-bottom: 20px; padding: 16px; background: var(--cell-bg); border-radius: var(--radius-md); border: 1px solid var(--input-border);">
        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
          <span id="matchResultPlayer1Name"></span>
          <span id="matchResultPlayer1Score" style="font-weight: 700; color: var(--accent);"></span>
        </div>
        <div style="display: flex; justify-content: space-between;">
          <span id="matchResultPlayer2Name"></span>
          <span id="matchResultPlayer2Score" style="font-weight: 700; color: var(--accent);"></span>
        </div>
      </div>
      <div id="rematchStatus" style="margin-bottom: 20px; padding: 12px; background: var(--cell-bg); border-radius: var(--radius-md); border: 1px solid var(--input-border); font-size: 13px; color: var(--text-secondary); text-align: center; display: none;">
        <span id="rematchStatusText"></span>
      </div>
      <div style="display: flex; gap: 10px; justify-content: flex-end; flex-wrap: wrap;">
        <button id="matchResultRematchBtn" class="button" style="background: var(--accent); flex: 1; min-width: 120px;">Rematch</button>
        <button id="matchResultDeclineBtn" class="button" style="background: rgba(148, 163, 184, 0.2); border-color: rgba(148, 163, 184, 0.3); color: var(--text-primary); flex: 1; min-width: 120px;">Decline</button>
      </div>
    </div>
  </div>

  <!-- Rematch Decline/Forfeit Result Modal -->
  <div id="rematchDeclineResultModal">
    <div class="modal-content" style="max-width: 500px;">
      <h3 id="rematchDeclineResultTitle" style="margin-top: 0; margin-bottom: 16px; font-size: 24px; font-weight: 700;"></h3>
      <div id="rematchDeclineResultDetails" style="margin-bottom: 20px; color: var(--text-secondary); font-size: 14px; line-height: 1.6;"></div>
      <div id="rematchDeclineResultScore" style="margin-bottom: 20px; padding: 16px; background: var(--cell-bg); border-radius: var(--radius-md); border: 1px solid var(--input-border);">
        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
          <span id="rematchDeclinePlayer1Name"></span>
          <span id="rematchDeclinePlayer1Score" style="font-weight: 700; color: var(--accent);"></span>
        </div>
        <div style="display: flex; justify-content: space-between;">
          <span id="rematchDeclinePlayer2Name"></span>
          <span id="rematchDeclinePlayer2Score" style="font-weight: 700; color: var(--accent);"></span>
        </div>
      </div>
      <div style="display: flex; gap: 10px; justify-content: flex-end;">
        <button id="rematchDeclineBackBtn" class="button" style="background: var(--accent); width: 100%;">Back to Multiplayer</button>
      </div>
    </div>
  </div>

  <!-- Confetti Container -->
  <div id="confettiContainer"></div>

  <script>
    // Google Analytics helper function
    function trackEvent(eventName, eventParams = {}) {
      if (typeof gtag !== 'undefined') {
        gtag('event', eventName, eventParams);
      }
    }
    
    const BOARD_SIZE = 9;
    const WIN_LENGTH = 5;

    // ============================================
    // FIREBASE CONFIGURATION
    // ============================================
    // TODO: Replace this with your Firebase config from Firebase Console
    // Get it from: Firebase Console  Project Settings  Your apps  Config
    const firebaseConfig = {
      apiKey: "AIzaSyBaQxN7VV8RGpSOExbfpluFaaGKPu0NfGY",
      authDomain: "in-a-row-5.firebaseapp.com",
      projectId: "in-a-row-5",
      storageBucket: "in-a-row-5.firebasestorage.app",
      messagingSenderId: "615966800813",
      appId: "1:615966800813:web:197850ee1fda2366833f24",
      measurementId: "G-L08B3D4HTZ"
    };

    // Initialize Firebase (only if config is provided)
    let db = null;
    let firebaseInitialized = false;
    
    if (firebaseConfig.apiKey && firebaseConfig.apiKey !== "YOUR_API_KEY_HERE") {
      try {
        firebase.initializeApp(firebaseConfig);
        db = firebase.firestore();
        firebaseInitialized = true;
      } catch (error) {
        console.error("Firebase initialization error:", error);
      }
    } else {
      console.warn("Firebase not configured. Global best streak will use localStorage.");
    }

    const boardElem = document.getElementById("board");
    const statusElem = document.getElementById("status");
    const statusRow = document.getElementById("statusRow");
    const restartBtn = document.getElementById("restartBtn");
    const themeToggleBtn = document.getElementById("themeToggle");
    const statsBtn = document.getElementById("statsBtn");
    const leaderboardBtn = document.getElementById("leaderboardBtn");
    const trophyBtn = document.getElementById("trophyBtn");
    const soundToggleBtn = document.getElementById("soundToggle");
    const statsModal = document.getElementById("statsModal");
    const closeStatsBtn = document.getElementById("closeStats");
    const trophyModal = document.getElementById("trophyModal");
    const closeTrophyBtn = document.getElementById("closeTrophy");
    const confettiContainer = document.getElementById("confettiContainer");
    const achievementNotification = document.getElementById("achievementNotification");
    const shareGameResultBtn = document.getElementById("shareGameResultBtn");
    const shareAchievementsBtn = document.getElementById("shareAchievementsBtn");
    const shareModal = document.getElementById("shareModal");
    const shareModalClose = document.getElementById("shareModalClose");
    const shareButtons = document.getElementById("shareButtons");
    const shareModalTitle = document.getElementById("shareModalTitle");
    const humanNameInput = document.getElementById("humanName");
    const currentStreakElem = document.getElementById("currentStreakDisplay");
    const bestStreakElem = document.getElementById("bestStreakDisplay");
    const applyHumanNameBtn = document.getElementById("applyHumanName");
    const nameSelectionModal = document.getElementById("nameSelectionModal");
    const nameSelectionInput = document.getElementById("nameSelectionInput");
    const nameSelectionPassword = document.getElementById("nameSelectionPassword");
    const nameSelectionMessage = document.getElementById("nameSelectionMessage");
    const nameSelectionWarning = document.getElementById("nameSelectionWarning");
    const nameSelectionPasswordSection = document.getElementById("nameSelectionPasswordSection");
    const nameSelectionButtons = document.getElementById("nameSelectionButtons");
    const nameSelectionStartBtn = document.getElementById("nameSelectionStartBtn");
    const nameSelectionRegisterBtn = document.getElementById("nameSelectionRegisterBtn");
    const nameSelectionLoginBtn = document.getElementById("nameSelectionLoginBtn");
    
    let nameCheckTimeout = null;
    
    const registerModal = document.getElementById("registerModal");
    const registerModalContent = document.getElementById("registerModalContent");
    const registerModalTitle = document.getElementById("registerModalTitle");
    const registerModalMessage = document.getElementById("registerModalMessage");
    const registerPassword = document.getElementById("registerPassword");
    const registerConfirmBtn = document.getElementById("registerConfirmBtn");
    const registerCancelBtn = document.getElementById("registerCancelBtn");
    const registerSkipBtn = document.getElementById("registerSkipBtn");
    const roomModal = document.getElementById("roomModal");
    const roomModalContent = document.getElementById("roomModalContent");
    const roomModalTitle = document.getElementById("roomModalTitle");
    const roomModalBody = document.getElementById("roomModalBody");
    const createRoomBtn = document.getElementById("createRoomBtn");
    const joinRoomBtn = document.getElementById("joinRoomBtn");
    const quickMatchBtn = document.getElementById("quickMatchBtn");
    const roomIdSection = document.getElementById("roomIdSection");
    const roomIdDisplay = document.getElementById("roomIdDisplay");
    const copyRoomIdBtn = document.getElementById("copyRoomIdBtn");
    const waitingRoomSection = document.getElementById("waitingRoomSection");
    const roomPlayer1 = document.getElementById("roomPlayer1");
    const roomPlayer2 = document.getElementById("roomPlayer2");
    const joinRoomSection = document.getElementById("joinRoomSection");
    const joinRoomIdInput = document.getElementById("joinRoomIdInput");
    const joinRoomConfirmBtn = document.getElementById("joinRoomConfirmBtn");
    const roomModalClose = document.getElementById("roomModalClose");
    const roomModalLeaderboardBtn = document.getElementById("roomModalLeaderboardBtn");
    const modeToggleSwitch = document.getElementById("modeToggleSwitch");
    const modeToggleSwitchMultiplayer = document.getElementById("modeToggleSwitchMultiplayer");
    const multiplayerScoreBar = document.getElementById("multiplayer-score-bar");
    const forfeitModal = document.getElementById("forfeitModal");
    const forfeitModalMessage = document.getElementById("forfeitModalMessage");
    const forfeitContinueBtn = document.getElementById("forfeitContinueBtn");
    const forfeitConfirmBtn = document.getElementById("forfeitConfirmBtn");
    const playAgainModal = document.getElementById("playAgainModal");
    const playAgainStartBtn = document.getElementById("playAgainStartBtn");
    const setCompleteModal = document.getElementById("setCompleteModal");
    const setCompleteModalTitle = document.getElementById("setCompleteModalTitle");
    const matchResultModal = document.getElementById("matchResultModal");
    const matchResultTitle = document.getElementById("matchResultTitle");
    const matchResultDetails = document.getElementById("matchResultDetails");
    const matchResultPlayer1Name = document.getElementById("matchResultPlayer1Name");
    const matchResultPlayer1Score = document.getElementById("matchResultPlayer1Score");
    const matchResultPlayer2Name = document.getElementById("matchResultPlayer2Name");
    const matchResultPlayer2Score = document.getElementById("matchResultPlayer2Score");
    const rematchStatus = document.getElementById("rematchStatus");
    const rematchStatusText = document.getElementById("rematchStatusText");
    const matchResultRematchBtn = document.getElementById("matchResultRematchBtn");
    const matchResultDeclineBtn = document.getElementById("matchResultDeclineBtn");
    const rematchDeclineResultModal = document.getElementById("rematchDeclineResultModal");
    const rematchDeclineResultTitle = document.getElementById("rematchDeclineResultTitle");
    const rematchDeclineResultDetails = document.getElementById("rematchDeclineResultDetails");
    const rematchDeclinePlayer1Name = document.getElementById("rematchDeclinePlayer1Name");
    const rematchDeclinePlayer1Score = document.getElementById("rematchDeclinePlayer1Score");
    const rematchDeclinePlayer2Name = document.getElementById("rematchDeclinePlayer2Name");
    const rematchDeclinePlayer2Score = document.getElementById("rematchDeclinePlayer2Score");
    const rematchDeclineBackBtn = document.getElementById("rematchDeclineBackBtn");

    let pendingName = "";
    let isLoginMode = false;

    async function hashPassword(password) {
      const encoder = new TextEncoder();
      const data = encoder.encode(password);
      const hashBuffer = await crypto.subtle.digest("SHA-256", data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
    }

    async function checkNameRegistered(name) {
      if (!firebaseInitialized || !db) return false;
      if (!name || !name.trim()) return false;
      try {
        const nameLower = name.toLowerCase().trim();
        if (!nameLower) return false;
        const doc = await db.collection("registeredNames").doc(nameLower).get();
        return doc.exists;
      } catch (error) {
        console.error("Error checking name:", error);
        return false;
      }
    }

    async function registerName(name, password) {
      if (!firebaseInitialized || !db) {
        alert("Registration requires Firebase. Please configure Firebase to use this feature.");
        return false;
      }
      try {
        const nameLower = name.toLowerCase();
        const passwordHash = await hashPassword(password);
        await db.collection("registeredNames").doc(nameLower).set({
          name: name,
          passwordHash: passwordHash,
          createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        return true;
      } catch (error) {
        console.error("Error registering name:", error);
        alert("Failed to register name. Please try again.");
        return false;
      }
    }

    async function verifyPassword(name, password) {
      if (!firebaseInitialized || !db) return false;
      try {
        const nameLower = name.toLowerCase();
        const doc = await db.collection("registeredNames").doc(nameLower).get();
        if (!doc.exists) return false;
        const passwordHash = await hashPassword(password);
        return doc.data().passwordHash === passwordHash;
      } catch (error) {
        console.error("Error verifying password:", error);
        return false;
      }
    }

    function showRegisterModal(name, isLogin = false) {
      pendingName = name;
      isLoginMode = isLogin;
      registerModalTitle.textContent = isLogin ? "Login" : "Register Name";
      registerModalMessage.textContent = isLogin
        ? `The name "${name}" is already registered. Enter password to play.`
        : `Register "${name}" with a password to protect it.`;
      registerPassword.value = "";
      registerPassword.focus();
      registerSkipBtn.style.display = "none";
      registerModal.classList.add("show");
    }

    function showNameSelectionModal() {
      nameSelectionModal.classList.add("show");
      nameSelectionInput.value = "";
      nameSelectionPassword.value = "";
      nameSelectionPasswordSection.style.display = "none";
      nameSelectionWarning.style.display = "none";
      nameSelectionMessage.textContent = "Enter your name to start playing (minimum 3 characters)";
      nameSelectionMessage.style.color = "var(--text-secondary)";
      nameSelectionStartBtn.style.display = "none";
      nameSelectionRegisterBtn.style.display = "none";
      nameSelectionLoginBtn.style.display = "none";
      nameSelectionStartBtn.textContent = "Play Unregistered";
      setTimeout(() => {
        nameSelectionInput.focus();
      }, 100);
    }

    function hideNameSelectionModal() {
      nameSelectionModal.classList.remove("show");
      nameSelectionInput.value = "";
      nameSelectionPassword.value = "";
      nameSelectionPasswordSection.style.display = "none";
      nameSelectionWarning.style.display = "none";
      if (nameCheckTimeout) {
        clearTimeout(nameCheckTimeout);
        nameCheckTimeout = null;
      }
    }

    async function checkNameAndUpdateModal() {
      const name = nameSelectionInput.value.trim();
      
      // Validate minimum length
      if (name.length < 3) {
        nameSelectionPasswordSection.style.display = "none";
        nameSelectionWarning.style.display = "none";
        nameSelectionStartBtn.style.display = "none";
        nameSelectionRegisterBtn.style.display = "none";
        nameSelectionLoginBtn.style.display = "none";
        if (name.length > 0) {
          nameSelectionMessage.textContent = "Name must be at least 3 characters long";
          nameSelectionMessage.style.color = "#dc2626";
        } else {
          nameSelectionMessage.textContent = "Enter your name to start playing (minimum 3 characters)";
          nameSelectionMessage.style.color = "var(--text-secondary)";
        }
        return;
      }
      
      nameSelectionMessage.style.color = "var(--text-secondary)";
      
      // Show "Play Unregistered" button immediately for valid names (optimistic UI)
      // This will be updated after Firebase check completes
      nameSelectionStartBtn.style.display = "block";
      nameSelectionStartBtn.textContent = "Play Unregistered";
      nameSelectionPasswordSection.style.display = "none";
      nameSelectionLoginBtn.style.display = "none";
      
      // Check if name is registered
      if (firebaseInitialized && db) {
        const isRegistered = await checkNameRegistered(name);
        if (isRegistered) {
          // Name is registered - hide play button, show password field and login button
          nameSelectionStartBtn.style.display = "none";
          nameSelectionRegisterBtn.style.display = "none";
          nameSelectionPasswordSection.style.display = "block";
          nameSelectionWarning.style.display = "none";
          nameSelectionLoginBtn.style.display = "block";
          nameSelectionMessage.textContent = `"${name}" is already registered. Enter password to login, or choose a different name.`;
          setTimeout(() => {
            nameSelectionPassword.focus();
          }, 100);
        } else {
          // Name is not registered - show play and register options WITH warning
          nameSelectionPasswordSection.style.display = "none";
          nameSelectionWarning.style.display = "block";
          nameSelectionStartBtn.style.display = "block";
          nameSelectionRegisterBtn.style.display = "block";
          nameSelectionLoginBtn.style.display = "none";
          nameSelectionStartBtn.textContent = "Play Unregistered";
          nameSelectionMessage.textContent = `"${name}" is available. Choose to play now or register it.`;
        }
      } else {
        // Firebase not configured - just show play button (NO warning)
        nameSelectionPasswordSection.style.display = "none";
        nameSelectionWarning.style.display = "none";
        nameSelectionStartBtn.style.display = "block";
        nameSelectionRegisterBtn.style.display = "none";
        nameSelectionLoginBtn.style.display = "none";
        nameSelectionStartBtn.textContent = "Play Unregistered";
        nameSelectionMessage.textContent = "Enter your name to start playing (minimum 3 characters)";
      }
    }

    function hideRegisterModal() {
      registerModal.classList.remove("show");
      pendingName = "";
      registerPassword.value = "";
    }

    function escapeHtml(str) {
      const div = document.createElement("div");
      div.textContent = str;
      return div.innerHTML;
    }

    function setStatusWithMark(name, player, suffix) {
      const mark = (player === "X" || player === "O") ? player : "?";
      const cls = mark === "X" ? "mark-X" : "mark-O";
      statusElem.innerHTML = escapeHtml(name) + ` (<span class="${cls}">${mark}</span>)${suffix}`;
    }

    let board;
    let currentPlayer;
    let gameOver;
    let gameStarted = false; // Track if a game has been started
    let humanPlayer;
    let computerPlayer;
    let nextHumanPlayer = "X"; // alternates between X and O each game
    let computerThinking = false;
    let computerMoveTimeoutId = null;
    let currentStreak = 0;
    let bestStreak = 0;
    let bestStreakName = "";
    let soundEnabled = true;
    let currentPlayerName = "";
    let gameMode = "training";
    
    let currentPlayerStats = {
      gamesPlayed: 0,
      wins: 0,
      losses: 0,
      draws: 0,
      currentStreak: 0
    };
    
    let globalStats = {
      gamesPlayed: 0,
      wins: 0,
      losses: 0,
      draws: 0,
      bestStreak: 0
    };
    let currentRoomId = null;
    let roomListener = null;
    let isPlayer1 = false;
    let matchGameNumber = 0; // 0 = first game, 1 = second game
    let matchResults = { player1Wins: 0, draws: 0, player2Wins: 0 };
    let opponentName = "";
    let myMarkInMatch = "X"; // X in first game, O in second game
    let player1Name = "";
    let player2Name = "";
    let currentMatchScore = { player1: 0, player2: 0 };
    let loadingDotsInterval = null;
    let waitingRoomCheckInterval = null;
    let waitingRoomListenerUnsub = null;
    let currentWaitingRoomId = null;
    let waitingRoomsFirstSeen = {}; // roomId -> firstSeenTimestamp (client-side)
    let waitingPromptAutoHideTimeout = null;
    let waitingPromptReappearTimeout = null;
    let matchCompletionProcessed = false; // Track if match completion has been processed
    

    // Achievements
    const achievements = {
      firstWin: { id: "firstWin", name: "First Win", description: "Win your first game", icon: "", unlocked: false },
      perfectGame: { id: "perfectGame", name: "Perfect Game", description: "Win without opponent getting 4 in a row", icon: "", unlocked: false },
      comebackKing: { id: "comebackKing", name: "Comeback King", description: "Win after opponent had 4 in a row", icon: "", unlocked: false },
      streakMaster: { id: "streakMaster", name: "Streak Master", description: "Reach 5+ win streak", icon: "", unlocked: false },
      speedDemon: { id: "speedDemon", name: "Speed Demon", description: "Win in under 20 moves", icon: "", unlocked: false },
      defender: { id: "defender", name: "Defender", description: "Block 3+ winning attempts in one game", icon: "", unlocked: false },
      centurion: { id: "centurion", name: "Centurion", description: "Play 100 games", icon: "", unlocked: false },
      unstoppable: { id: "unstoppable", name: "Unstoppable", description: "Win 10 games in a row", icon: "", unlocked: false }
    };

    // Game state for achievement tracking
    let gameState = {
      moveCount: 0,
      blocksThisGame: 0,
      opponentMaxInRow: 0,
      opponentHad4InRow: false,
      playerHad4InRow: false
    };

    let lastGameResultText = ""; // For sharing game result

    function createEmptyBoard() {
      return Array.from({ length: BOARD_SIZE }, () =>
        Array.from({ length: BOARD_SIZE }, () => "")
      );
    }

    // Convert 2D board array to Firestore-compatible format (flat array)
    function boardToFirestore(board) {
      const flat = [];
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          flat.push(board[r][c] || "");
        }
      }
      return flat;
    }

    // Convert Firestore flat array back to 2D board array
    function boardFromFirestore(flat) {
      const board = [];
      for (let r = 0; r < BOARD_SIZE; r++) {
        board[r] = [];
        for (let c = 0; c < BOARD_SIZE; c++) {
          const index = r * BOARD_SIZE + c;
          board[r][c] = flat[index] || "";
        }
      }
      return board;
    }

    function initBoardUI() {
      boardElem.innerHTML = "";
      // Grid sizing is handled by CSS for responsiveness

      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.addEventListener("click", onCellClick);
          cell.addEventListener("mouseenter", onCellMouseEnter);
          cell.addEventListener("mouseleave", onCellMouseLeave);
          boardElem.appendChild(cell);
        }
      }
    }

    function clearHighlights() {
      document
        .querySelectorAll(".cell.last-move, .cell.win")
        .forEach(cell => {
          cell.classList.remove("last-move", "win");
        });
      // Also clear all preview classes
      document
        .querySelectorAll(".cell.preview-X, .cell.preview-O")
        .forEach(cell => {
          cell.classList.remove("preview-X", "preview-O");
          delete cell.dataset.preview;
        });
    }

    function onCellClick(e) {
      console.log("Cell clicked!", {
        computerThinking,
        gameStarted,
        gameOver,
        humanPlayer,
        currentPlayer,
        hasHumanName: hasHumanName(),
        gameMode
      });
      
      // Don't allow clicks if computer is thinking
      if (computerThinking) {
        console.log("Blocked: computer thinking");
        return;
      }
      
      // Ensure game state is initialized
      if (humanPlayer === undefined || currentPlayer === undefined) {
        console.log("Game state not initialized, initializing...");
        if (gameMode === "training" && hasHumanName()) {
          startNewRound();
          // After initializing, re-check conditions
          if (humanPlayer === undefined || currentPlayer === undefined) {
            console.log("Still not initialized after startNewRound");
            return; // Still not initialized, can't proceed
          }
        } else {
          console.log("Blocked: cannot initialize - gameMode:", gameMode, "hasHumanName:", hasHumanName());
          return;
        }
      }
      
      // Allow clicks when game hasn't started (to start the game)
      // Only block clicks if game has started AND game is over
      // If game hasn't started yet, allow clicks to start the game (even if gameOver was true from init)
      if (gameStarted && gameOver) {
        console.log("Blocked: game started and over");
        return;
      }
      
      // Clear preview classes when clicking
      const cell = e.currentTarget;
      cell.classList.remove("preview-X", "preview-O");
      delete cell.dataset.preview;

      // Allow clicks if:
      // 1. Game has started and it's human's turn, OR
      // 2. Game hasn't started yet but human goes first (currentPlayer === humanPlayer)
      if (!gameStarted && currentPlayer !== humanPlayer) {
        console.log("Blocked: game not started and not human's turn", { currentPlayer, humanPlayer });
        return;
      }
      if (gameStarted && currentPlayer !== humanPlayer) {
        console.log("Blocked: game started but not human's turn", { currentPlayer, humanPlayer });
        return;
      }
      if (!hasHumanName()) {
        console.log("Blocked: no human name");
        return;
      }
      
      console.log("Click allowed, proceeding to handleMove");

      const r = parseInt(cell.dataset.row, 10);
      const c = parseInt(cell.dataset.col, 10);
      
      console.log("Cell coordinates:", r, c, "Board value:", board[r] ? board[r][c] : "row undefined");

      if (!board || !board[r] || board[r][c] !== "") {
        console.log("Blocked: cell already occupied or board invalid");
        return;
      }

      // If game hasn't started yet and human goes first, start it now
      if (!gameStarted && currentPlayer === humanPlayer) {
        console.log("Starting game...");
        gameStarted = true;
        gameOver = false; // Ensure game is not over when starting
        updateRestartButtonText();
        setStatusForTurn();
      }

      console.log("Calling handleMove with:", r, c);
      handleMove(r, c, false);
    }

    function onCellMouseEnter(e) {
      const cell = e.currentTarget;
      const r = parseInt(cell.dataset.row, 10);
      const c = parseInt(cell.dataset.col, 10);
      
      // Allow preview if:
      // 1. Game hasn't started yet AND human goes first (currentPlayer === humanPlayer), OR
      // 2. Game has started AND it's human's turn AND game not over
      const canPreview = (!gameStarted && currentPlayer === humanPlayer) || 
                         (gameStarted && !gameOver && currentPlayer === humanPlayer);
      
      if (!board || board[r][c] !== "" || gameOver || !canPreview || computerThinking || !hasHumanName()) return;
      if (gameMode === "multiplayer" && currentPlayer !== humanPlayer) return;
      
      const cls = humanPlayer === "X" ? "preview-X" : "preview-O";
      cell.classList.add(cls);
      cell.dataset.preview = humanPlayer;
    }

    function onCellMouseLeave(e) {
      const cell = e.currentTarget;
      cell.classList.remove("preview-X", "preview-O");
      delete cell.dataset.preview;
    }

    function getHumanDisplayName() {
      const raw = humanNameInput.value.trim();
      return raw || "You";
    }

    function getComputerDisplayName() {
      return "Computer";
    }

    function hasHumanName() {
      return humanNameInput.value.trim().length > 0;
    }

    async function handleMove(r, c, isComputer) {
      console.log("handleMove called:", { r, c, isComputer, gameOver, gameStarted });
      if (gameOver || !gameStarted) {
        console.log("handleMove blocked:", { gameOver, gameStarted });
        return;
      }
      
      // In multiplayer mode, only allow moves for current player
      if (gameMode === "multiplayer" && !isComputer) {
        if (currentPlayer !== humanPlayer) {
          return; // Not your turn
        }
        if (!currentRoomId) {
          return; // Not in a room
        }
      }

      // Track if this is a blocking move (check before placing)
      if (isComputer && currentPlayer === computerPlayer) {
        // Check if computer is blocking human's potential win
        if (checkIfBlockingMove(board, r, c, humanPlayer)) {
          gameState.blocksThisGame++;
        }
      }

      board[r][c] = currentPlayer;
      gameState.moveCount++;

      // Track max line lengths
      if (isComputer) {
        const computerMax = getMaxLineLength(board, computerPlayer);
        gameState.opponentMaxInRow = Math.max(gameState.opponentMaxInRow, computerMax);
        if (computerMax >= 4) {
          gameState.opponentHad4InRow = true;
        }
      } else {
        const humanMax = getMaxLineLength(board, humanPlayer);
        if (humanMax >= 4) {
          gameState.playerHad4InRow = true;
        }
      }

      clearHighlights();
      const allCells = document.querySelectorAll(".cell");
      allCells.forEach(cell => {
        if (!cell.classList.contains("win")) {
          cell.classList.remove("last-move");
        }
        // Clear preview classes from all cells
        cell.classList.remove("preview-X", "preview-O");
        delete cell.dataset.preview;
      });

      const cell = document.querySelector(
        `.cell[data-row="${r}"][data-col="${c}"]`
      );
      if (cell) {
        // Capture the player value before any async operations
        const playerToDisplay = currentPlayer;
        
        // Clear any existing content, classes, and preview classes
        cell.textContent = "";
        cell.classList.remove("X", "O", "last-move", "placing", "preview-X", "preview-O");
        delete cell.dataset.preview;
        
        // Set content and class immediately
        cell.textContent = playerToDisplay;
        cell.classList.add(playerToDisplay, "last-move");
        
        // Force a reflow to ensure DOM is updated
        void cell.offsetHeight;
        
        // Add placing class to trigger animation
        cell.classList.add("placing");
        
        // Remove placing class after animation completes
        setTimeout(() => {
          cell.classList.remove("placing");
        }, 400);
        
        // Play placement sound
        playSound("place");
      }

      const winLine = getWinningLine(board, r, c, currentPlayer);
      if (winLine) {
        gameOver = true;
        highlightWinningLine(winLine);
        
        if (gameMode === "multiplayer") {
          // Multiplayer win handling
          const winner = currentPlayer;
          await handleMultiplayerGameEnd(winner, null);
        } else {
          // Training mode win handling
          if (isComputer) {
            setStatusWithMark(getComputerDisplayName(), currentPlayer, " wins!");
            statusRow.className = "status-neutral";
            lastGameResultText = `I just lost in 5-in-a-Row. My streak was ${currentStreak}. Can you do better?`;
            currentStreak = 0;
            playSound("aw");
            // Update statistics for loss
            currentPlayerStats.gamesPlayed++;
            currentPlayerStats.losses++;
            currentPlayerStats.currentStreak = 0;
            globalStats.gamesPlayed++;
            globalStats.losses++;
            saveStats();
            // Track training mode loss
            trackEvent('game_complete', {
              'game_mode': 'training',
              'result': 'loss'
            });
          } else {
            const winnerName = getHumanDisplayName();
            setStatusWithMark(winnerName, currentPlayer, " wins!");
            statusRow.className = "status-neutral";
            currentStreak += 1;
            if (currentStreak > bestStreak) {
              bestStreak = currentStreak;
              bestStreakName = winnerName;
              saveBestStreak();
            }
            playSound("applause");
            createConfetti();
            lastGameResultText = `I just won in 5-in-a-Row! Streak: ${currentStreak}. Try to beat me!`;
            checkWinAchievements();
            // Update statistics for win
            currentPlayerStats.gamesPlayed++;
            currentPlayerStats.wins++;
            currentPlayerStats.currentStreak = currentStreak;
            globalStats.gamesPlayed++;
            globalStats.wins++;
            saveStats();
            // Track training mode win
            trackEvent('game_complete', {
              'game_mode': 'training',
              'result': 'win',
              'streak': currentStreak,
              'best_streak': bestStreak
            });
          }
          checkAchievements();
          if (gameMode === "training") {
            updateStreakDisplays();
          }
          shareGameResultBtn.classList.add("visible");
          computerThinking = false;
          resetGameState();
          clearGameState(); // Clear saved game state when game ends
        }
        return;
      }

      if (boardFull(board)) {
        gameOver = true;
        
        if (gameMode === "multiplayer") {
          // Multiplayer draw handling
          await handleMultiplayerGameEnd(null, "draw");
        } else {
          // Training mode draw handling
          statusElem.textContent = "It's a draw!";
          statusRow.className = "status-neutral";
          playSound("draw");
          lastGameResultText = `I just played a draw in 5-in-a-Row. Streak: ${currentStreak}. Give it a try!`;
          checkAchievements();
          shareGameResultBtn.classList.add("visible");
          computerThinking = false;
          resetGameState();
          clearGameState(); // Clear saved game state when game ends
          // Update statistics for draw
          currentPlayerStats.gamesPlayed++;
          currentPlayerStats.draws++;
          globalStats.gamesPlayed++;
          globalStats.draws++;
          saveStats();
          // Track training mode draw
          trackEvent('game_complete', {
            'game_mode': 'training',
            'result': 'draw'
          });
        }
        return;
      }

      // Switch turns
      currentPlayer = currentPlayer === "X" ? "O" : "X";

      // In multiplayer mode, sync to Firestore
      if (gameMode === "multiplayer" && currentRoomId && firebaseInitialized && db) {
        await syncMoveToFirestore(r, c);
        return; // Don't continue with computer move logic
      }

      // Decide whose turn it is next and update status with names (training mode)
      if (currentPlayer === humanPlayer) {
        const name = getHumanDisplayName();
        setStatusWithMark(name, currentPlayer, "  your turn");
        statusRow.className = "status-your-turn";
        computerThinking = false;
      } else {
        setStatusWithMark(getComputerDisplayName(), currentPlayer, " is thinking...");
        statusRow.className = "status-computer-turn";
        computerThinking = true;
        // 1 second delay before computer moves
        if (computerMoveTimeoutId !== null) {
          clearTimeout(computerMoveTimeoutId);
        }
        computerMoveTimeoutId = setTimeout(computerMove, 1000);
      }
      
      // Save game state after move (for forfeit detection on refresh)
      saveGameState();
    }

    async function syncMoveToFirestore(r, c) {
      if (!currentRoomId || !firebaseInitialized || !db) return;

      try {
        const roomRef = db.collection("gameRooms").doc(currentRoomId);
        const winner = gameOver ? (currentPlayer === humanPlayer ? humanPlayer : computerPlayer) : null;
        await roomRef.update({
          board: boardToFirestore(board), // Convert 2D array to flat array
          currentPlayer: currentPlayer,
          gameOver: gameOver,
          winner: winner,
          lastMove: firebase.firestore.FieldValue.serverTimestamp()
        });
      } catch (error) {
        console.error("Error syncing move:", error);
      }
    }

    function computerMove() {
      if (gameOver) {
        computerThinking = false;
        return;
      }

      // Don't let computer move if game hasn't started yet (waiting for player confirmation)
      if (!gameStarted) {
        computerThinking = false;
        return;
      }

      // Don't let computer move if human name not set yet
      if (!hasHumanName()) {
        computerThinking = false;
        return;
      }

      const moves = [];
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          if (board[r][c] === "") {
            moves.push([r, c]);
          }
        }
      }

      if (moves.length === 0) {
        computerThinking = false;
        return;
      }

      // First, always take immediate wins if available
      for (const [r, c] of moves) {
        board[r][c] = computerPlayer;
        const winNow = getWinningLine(board, r, c, computerPlayer);
        board[r][c] = "";
        if (winNow) {
          handleMove(r, c, true);
          return;
        }
      }

      // Then, always block immediate human wins if possible
      for (const [r, c] of moves) {
        board[r][c] = humanPlayer;
        const humanWin = getWinningLine(board, r, c, humanPlayer);
        board[r][c] = "";
        if (humanWin) {
          handleMove(r, c, true);
          return;
        }
      }

      let bestScore = -Infinity;
      let bestMoves = [];
      for (const [r, c] of moves) {
        const score = scoreMove(r, c);
        if (score > bestScore) {
          bestScore = score;
          bestMoves = [[r, c]];
        } else if (score === bestScore) {
          bestMoves.push([r, c]);
        }
      }

      // Maximum difficulty: always choose the strongest move
      const [r, c] = bestMoves[Math.floor(Math.random() * bestMoves.length)];
      handleMove(r, c, true);
    }

    function inBounds(r, c) {
      return r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE;
    }

    function collectLine(board, r, c, dr, dc, player) {
      const cells = [[r, c]];

      let nr = r + dr;
      let nc = c + dc;
      while (inBounds(nr, nc) && board[nr][nc] === player) {
        cells.push([nr, nc]);
        nr += dr;
        nc += dc;
      }

      nr = r - dr;
      nc = c - dc;
      while (inBounds(nr, nc) && board[nr][nc] === player) {
        cells.unshift([nr, nc]);
        nr -= dr;
        nc -= dc;
      }

      return cells;
    }

    function getWinningLine(board, r, c, player) {
      const directions = [
        [0, 1],  // horizontal
        [1, 0],  // vertical
        [1, 1],  // diagonal down-right
        [1, -1], // diagonal down-left
      ];

      for (const [dr, dc] of directions) {
        const cells = collectLine(board, r, c, dr, dc, player);
        if (cells.length >= WIN_LENGTH) {
          // limit to exactly WIN_LENGTH contiguous cells around last move
          // (purely visual; game already won)
          return cells.slice(0, WIN_LENGTH);
        }
      }
      return null;
    }

    function highlightWinningLine(cells) {
      cells.forEach(([r, c]) => {
        const cell = document.querySelector(
          `.cell[data-row="${r}"][data-col="${c}"]`
        );
        if (cell) {
          cell.classList.add("win");
        }
      });
    }

    function boardFull(board) {
      return board.every(row => row.every(cell => cell !== ""));
    }

    // ---- Achievement helpers ----

    function getMaxLineLength(board, player) {
      let maxLength = 0;
      const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];

      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          if (board[r][c] === player) {
            for (const [dr, dc] of directions) {
              const length = collectLine(board, r, c, dr, dc, player).length;
              maxLength = Math.max(maxLength, length);
            }
          }
        }
      }
      return maxLength;
    }

    function checkIfBlockingMove(board, r, c, threatenedPlayer) {
      // Check if placing threatenedPlayer's piece here would create a win
      // This means the current move is blocking that win
      if (board[r][c] !== "") return false;
      
      board[r][c] = threatenedPlayer;
      const wouldWin = getWinningLine(board, r, c, threatenedPlayer) !== null;
      board[r][c] = "";
      
      return wouldWin;
    }

    function resetGameState() {
      gameState = {
        moveCount: 0,
        blocksThisGame: 0,
        opponentMaxInRow: 0,
        opponentHad4InRow: false,
        playerHad4InRow: false
      };
    }

    // ---- Game State Persistence (for forfeit detection) ----
    
    function saveGameState() {
      // Only save in training mode and if game is not over
      if (gameMode !== "training" || gameOver) {
        clearGameState();
        return;
      }
      
      // Don't save if board is not initialized or empty (no moves made yet)
      if (!board || !Array.isArray(board)) {
        clearGameState();
        return;
      }
      
      const hasMoves = board.some(row => row.some(cell => cell !== ""));
      if (!hasMoves) {
        clearGameState();
        return;
      }
      
      try {
        const gameStateToSave = {
          board: board,
          currentPlayer: currentPlayer,
          gameOver: gameOver,
          humanPlayer: humanPlayer,
          computerPlayer: computerPlayer,
          gameState: gameState,
          playerName: currentPlayerName || humanNameInput.value.trim()
        };
        localStorage.setItem("tictac9x9_activeGame", JSON.stringify(gameStateToSave));
      } catch (e) {
        // ignore storage errors
      }
    }
    
    function loadGameState() {
      try {
        const saved = localStorage.getItem("tictac9x9_activeGame");
        if (!saved) return null;
        const data = JSON.parse(saved);
        
        // Validate saved data
        if (!data.board || !Array.isArray(data.board) || 
            !data.currentPlayer || !data.humanPlayer || !data.computerPlayer) {
          return null;
        }
        
        return data;
      } catch (e) {
        return null;
      }
    }
    
    function clearGameState() {
      try {
        localStorage.removeItem("tictac9x9_activeGame");
      } catch (e) {
        // ignore errors
      }
    }
    
    function restoreGameState(savedState) {
      if (!savedState) return false;
      
      board = savedState.board;
      currentPlayer = savedState.currentPlayer;
      gameOver = savedState.gameOver || false;
      humanPlayer = savedState.humanPlayer;
      computerPlayer = savedState.computerPlayer;
      gameStarted = true; // Game was started if we're restoring state
      gameState = savedState.gameState || {
        moveCount: 0,
        blocksThisGame: 0,
        opponentMaxInRow: 0,
        opponentHad4InRow: false,
        playerHad4InRow: false
      };
      
      // Restore UI
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
          if (cell) {
            cell.textContent = board[r][c] || "";
            cell.classList.remove("X", "O", "last-move", "win");
            if (board[r][c]) {
              cell.classList.add(board[r][c]);
            }
          }
        }
      }
      
      // Update button text since game is started
      updateRestartButtonText();
      
      // Update status
      if (gameOver) {
        statusElem.textContent = "Game over";
        statusRow.className = "status-neutral";
      } else {
        setStatusForTurn();
        // If it's computer's turn, trigger computer move
        if (currentPlayer === computerPlayer && !gameOver) {
          computerThinking = true;
          if (computerMoveTimeoutId !== null) {
            clearTimeout(computerMoveTimeoutId);
          }
          computerMoveTimeoutId = setTimeout(computerMove, 1000);
        }
      }
      
      return true;
    }
    
    async function handleForfeit() {
      // Check if this is a multiplayer forfeit
      if (gameMode === "multiplayer" && currentRoomId && firebaseInitialized && db) {
        try {
          const roomRef = db.collection("gameRooms").doc(currentRoomId);
          const roomDoc = await roomRef.get();
          if (roomDoc.exists) {
            const roomData = roomDoc.data();
            const totalGames = (roomData.matchResults?.player1Wins || 0) + (roomData.matchResults?.player2Wins || 0) + (roomData.matchResults?.draws || 0);
            const matchFinished = roomData.gameOver && totalGames >= 2;
            // If match is not finished and both players are present, handle as multiplayer forfeit
            if (!matchFinished && roomData.player1 && roomData.player2) {
              await handleMultiplayerForfeit();
              return;
            }
          }
        } catch (error) {
          console.error("Error checking room state in handleForfeit:", error);
        }
      }

      // Reset streak
      currentStreak = 0;

      // Update status
      setStatusWithMark(getComputerDisplayName(), computerPlayer, " wins! (Forfeit)");
      statusRow.className = "status-neutral";
      playSound("aw");

      // Update statistics for forfeit (counts as loss in training mode)
      if (gameMode === "training") {
        currentPlayerStats.gamesPlayed++;
        currentPlayerStats.losses++;
        currentPlayerStats.currentStreak = 0;
        globalStats.gamesPlayed++;
        globalStats.losses++;
        saveStats();
      }

      // Update displays
      if (gameMode === "training") {
        updateStreakDisplays();
      }

      // Clear saved game state
      clearGameState();
      
      // Reset game started flag
      gameStarted = false;
      updateRestartButtonText();

      // Don't automatically start new round here - let the caller decide
      // (for restart action, we'll start new round after forfeit)
    }

    async function handleMultiplayerForfeit() {
      if (!currentRoomId || !firebaseInitialized || !db) return;

      try {
        const roomRef = db.collection("gameRooms").doc(currentRoomId);
        const roomDoc = await roomRef.get();
        if (!roomDoc.exists) return;

        const roomData = roomDoc.data();
        let updatedMatchResults = { ...matchResults };

        // Award 2 wins (4 points) to the opponent
        if (isPlayer1) {
          updatedMatchResults.player2Wins += 2;
        } else {
          updatedMatchResults.player1Wins += 2;
        }

        matchResults = updatedMatchResults;
        updateMultiplayerScoreDisplay();

        // Update Firestore with forfeit result
        await roomRef.update({
          board: boardToFirestore(board),
          gameOver: true,
          winner: isPlayer1 ? "O" : "X", // Opponent wins
          matchResults: updatedMatchResults,
          forfeit: true,
          forfeitedBy: isPlayer1 ? "player1" : "player2",
          lastMove: firebase.firestore.FieldValue.serverTimestamp()
        });

        // Update status
        setStatusWithMark(opponentName, isPlayer1 ? "O" : "X", " wins! (Forfeit)");
        statusRow.className = "status-neutral";
        playSound("aw");

        // Check if match is complete (2 games played)
        const totalGames = updatedMatchResults.player1Wins + updatedMatchResults.player2Wins + updatedMatchResults.draws;
        
        // Complete the match by awarding remaining wins if needed
        const remainingWinsNeeded = 2 - (updatedMatchResults.player1Wins + updatedMatchResults.player2Wins);
        if (remainingWinsNeeded > 0) {
          if (isPlayer1) {
            updatedMatchResults.player2Wins += remainingWinsNeeded;
          } else {
            updatedMatchResults.player1Wins += remainingWinsNeeded;
          }
          matchResults = updatedMatchResults;
          await roomRef.update({ matchResults: updatedMatchResults });
        }
        
        // Calculate final scores and update leaderboard
        const player1Name = roomData.player1?.name || "";
        const player2Name = roomData.player2?.name || "";
        const scores = calculateMatchScore(updatedMatchResults.player1Wins, updatedMatchResults.draws, updatedMatchResults.player2Wins);
        await updateLeaderboard(player1Name, player2Name, scores, updatedMatchResults);
        
        // Show forfeit result modal (we forfeited, so we lost)
        showForfeitResultModal(player1Name, player2Name, true);

        gameOver = true;
        gameStarted = false;
        resetGameState();
        clearGameState();
        updateRestartButtonText();
        // Track forfeit
        trackEvent('multiplayer_forfeit', {
          'forfeited_by': 'me',
          'opponent_received_points': 4
        });
      } catch (error) {
        console.error("Error handling multiplayer forfeit:", error);
      }
    }
    
    function showForfeitModal(action = "") {
      // Set message based on action
      if (action === "restart") {
        forfeitModalMessage.textContent = "You have an active game. Restarting will count as a forfeit (loss).";
      } else if (action === "forfeit-button") {
        forfeitModalMessage.textContent = "You are about to forfeit the match. Your opponent will receive 4 points. Are you sure?";
      } else if (action === "leave-room" || (action === "" && gameMode === "multiplayer")) {
        forfeitModalMessage.textContent = "You have an active multiplayer game. Leaving will forfeit the match and award 4 points to your opponent.";
      } else if (action === "switch-mode" && gameMode === "multiplayer") {
        forfeitModalMessage.textContent = "You have an active multiplayer game. Switching to training mode will forfeit the match and award 4 points to your opponent.";
      } else {
        forfeitModalMessage.textContent = "You have an active game. Closing or refreshing the page will count as a forfeit (loss).";
      }
      forfeitModal.dataset.action = action;
      forfeitModal.classList.add("show");
    }
    
    function hideForfeitModal() {
      forfeitModal.classList.remove("show");
    }

    function showPlayAgainModal() {
      playAgainModal.classList.add("show");
    }
    
    function hidePlayAgainModal() {
      playAgainModal.classList.remove("show");
    }

    function startGameWithComputerFirst() {
      // Hide the modal
      hidePlayAgainModal();
      
      // Start the game
      gameStarted = true;
      updateRestartButtonText();
      
      // Update status
      setStatusForTurn();
      
      // Trigger computer's first move after a short delay
      if (currentPlayer === computerPlayer && !gameOver) {
        computerThinking = true;
        if (computerMoveTimeoutId !== null) {
          clearTimeout(computerMoveTimeoutId);
        }
        computerMoveTimeoutId = setTimeout(computerMove, 1000);
      }
    }

    // ---- Sound Effects ----

    function playSound(type) {
      if (!soundEnabled) return;

      const audioContext = new (window.AudioContext || window.webkitAudioContext)();

      if (type === "applause") {
        // Create a pleasant triumphant fanfare - ascending chord sequence
        const notes = [
          { freq: 523.25, delay: 0.0, duration: 0.15 },   // C5
          { freq: 659.25, delay: 0.1, duration: 0.15 },   // E5
          { freq: 783.99, delay: 0.2, duration: 0.15 },   // G5
          { freq: 1046.50, delay: 0.3, duration: 0.25 },  // C6
        ];
        
        notes.forEach((note, index) => {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          oscillator.frequency.value = note.freq;
          oscillator.type = "sine";
          
          const volume = 0.25;
          const startTime = audioContext.currentTime + note.delay;
          
          gainNode.gain.setValueAtTime(0, startTime);
          gainNode.gain.linearRampToValueAtTime(volume, startTime + 0.02);
          gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + note.duration);
          
          oscillator.start(startTime);
          oscillator.stop(startTime + note.duration);
        });
        return;
      }

      if (type === "aw") {
        // Create disappointed "aw" sound - descending tone
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.type = "sawtooth";
        oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.5);
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.5);
        return;
      }

      // Regular sounds
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      let frequency, duration, volume;

      switch (type) {
        case "place":
          frequency = 440;
          duration = 0.1;
          volume = 0.3;
          break;
        case "win":
          frequency = 523.25; // C5
          duration = 0.3;
          volume = 0.5;
          break;
        case "lose":
          frequency = 220;
          duration = 0.4;
          volume = 0.4;
          break;
        case "draw":
          frequency = 330;
          duration = 0.25;
          volume = 0.3;
          break;
        default:
          return;
      }

      oscillator.frequency.value = frequency;
      oscillator.type = "sine";

      gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + duration);
    }

    function toggleSound() {
      soundEnabled = !soundEnabled;
      soundToggleBtn.classList.toggle("muted", !soundEnabled);
      localStorage.setItem("tictac9x9_sound", soundEnabled);
    }

    // ---- Confetti Animation ----

    function createConfetti() {
      const colors = ["#ffd700", "#ff6b6b", "#4ecdc4", "#45b7d1", "#f9ca24", "#f0932b", "#eb4d4b", "#6c5ce7"];
      const confettiCount = 100;

      for (let i = 0; i < confettiCount; i++) {
        const confetti = document.createElement("div");
        confetti.className = "confetti";
        confetti.style.left = Math.random() * 100 + "%";
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDuration = (Math.random() * 3 + 2) + "s";
        confetti.style.animationDelay = Math.random() * 0.5 + "s";
        confetti.style.opacity = "1";
        confettiContainer.appendChild(confetti);

        setTimeout(() => {
          confetti.remove();
        }, 5000);
      }
    }

    // ---- Achievements ----

    function loadAchievements() {
      try {
        const saved = localStorage.getItem("tictac9x9_achievements");
        if (saved) {
          const savedAchievements = JSON.parse(saved);
          Object.keys(achievements).forEach(key => {
            if (savedAchievements[key] !== undefined) {
              achievements[key].unlocked = savedAchievements[key];
            }
          });
        }
      } catch (e) {
        // ignore errors
      }
    }

    function saveAchievements() {
      try {
        const toSave = {};
        Object.keys(achievements).forEach(key => {
          toSave[key] = achievements[key].unlocked;
        });
        localStorage.setItem("tictac9x9_achievements", JSON.stringify(toSave));
      } catch (e) {
        // ignore errors
      }
    }

    function checkAchievements() {
      const newlyUnlocked = [];


      // Streak Master
      if (!achievements.streakMaster.unlocked && currentStreak >= 5) {
        achievements.streakMaster.unlocked = true;
        newlyUnlocked.push(achievements.streakMaster);
      }

      // Defender - checked after game
      if (!achievements.defender.unlocked && gameState.blocksThisGame >= 3) {
        achievements.defender.unlocked = true;
        newlyUnlocked.push(achievements.defender);
      }


      // Unstoppable
      if (!achievements.unstoppable.unlocked && currentStreak >= 10) {
        achievements.unstoppable.unlocked = true;
        newlyUnlocked.push(achievements.unstoppable);
      }

      // Show notifications for newly unlocked achievements
      newlyUnlocked.forEach(achievement => {
        showAchievementNotification(achievement);
        // Track achievement unlock
        trackEvent('achievement_unlocked', {
          'achievement_id': achievement.id,
          'achievement_name': achievement.name
        });
      });

      if (newlyUnlocked.length > 0) {
        saveAchievements();
        updateAchievementsDisplay();
      }
    }

    function checkWinAchievements() {
      const newlyUnlocked = [];

      // Perfect Game - win without opponent getting 4 in a row
      if (!achievements.perfectGame.unlocked && gameState.opponentMaxInRow < 4) {
        achievements.perfectGame.unlocked = true;
        newlyUnlocked.push(achievements.perfectGame);
      }

      // Comeback King - win after opponent had 4 in a row
      if (!achievements.comebackKing.unlocked && gameState.opponentHad4InRow) {
        achievements.comebackKing.unlocked = true;
        newlyUnlocked.push(achievements.comebackKing);
      }

      // Speed Demon - win in under 20 moves
      if (!achievements.speedDemon.unlocked && gameState.moveCount < 20) {
        achievements.speedDemon.unlocked = true;
        newlyUnlocked.push(achievements.speedDemon);
      }

      newlyUnlocked.forEach(achievement => {
        showAchievementNotification(achievement);
        // Track achievement unlock
        trackEvent('achievement_unlocked', {
          'achievement_id': achievement.id,
          'achievement_name': achievement.name
        });
      });

      if (newlyUnlocked.length > 0) {
        saveAchievements();
        updateAchievementsDisplay();
      }
    }

    function showAchievementNotification(achievement) {
      const notification = document.createElement("div");
      notification.className = "achievement-notification";
      notification.innerHTML = `
        <div class="achievement-notification-header">
          <span class="achievement-notification-icon">${achievement.icon}</span>
          <span class="achievement-notification-title">Achievement Unlocked!</span>
        </div>
        <div class="achievement-notification-desc">
          <strong>${achievement.name}</strong><br>${achievement.description}
        </div>
      `;
      document.body.appendChild(notification);

      setTimeout(() => {
        notification.style.animation = "slideInRight 0.5s ease-out reverse";
        setTimeout(() => {
          notification.remove();
        }, 500);
      }, 3000);
    }

    function updateAchievementsDisplay() {
      const unlockedCount = Object.values(achievements).filter(a => a.unlocked).length;
      document.getElementById("trophyUnlockedCount").textContent = unlockedCount;

      // Update achievements grid
      const trophyGrid = document.getElementById("trophyAchievementsGrid");
      trophyGrid.innerHTML = "";
      Object.values(achievements).forEach(achievement => {
        const item = createAchievementItem(achievement);
        trophyGrid.appendChild(item);
      });
    }

    function createAchievementItem(achievement) {
      const item = document.createElement("div");
      item.className = `achievement-item ${achievement.unlocked ? "unlocked" : "locked"}`;
      item.innerHTML = `
        <div class="achievement-icon">${achievement.icon}</div>
        <div class="achievement-name">${achievement.name}</div>
        <div class="achievement-desc">${achievement.description}</div>
      `;
      return item;
    }

    function showTrophyCabinet() {
      updateAchievementsDisplay();
      trophyModal.classList.add("show");
    }

    function hideTrophyCabinet() {
      trophyModal.classList.remove("show");
    }

    // ---- Share ----
    function getShareUrl() {
      return window.location.href || "";
    }

    async function openShare(text, url) {
      const shareUrl = url || getShareUrl();
      const fullText = text ? `${text} ${shareUrl}` : shareUrl;

      if (navigator.share) {
        try {
          await navigator.share({
            title: "5-in-a-Row",
            text: text || "Check out 5-in-a-Row!",
            url: shareUrl
          });
          return;
        } catch (err) {
          if (err.name === "AbortError") return;
        }
      }
      showShareFallback(text, shareUrl);
    }

    function showShareFallback(title, url) {
      const fullText = title ? `${title} ${url}` : url;
      shareModalTitle.textContent = "Share";
      shareButtons.innerHTML = "";

      const networks = [
        { name: "Twitter / X", icon: "", href: `https://twitter.com/intent/tweet?text=${encodeURIComponent(fullText)}` },
        { name: "Facebook", icon: "f", href: `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}` },
        { name: "WhatsApp", icon: "WhatsApp", href: `https://wa.me/?text=${encodeURIComponent(fullText)}` }
      ];

      networks.forEach(({ name, icon, href }) => {
        const a = document.createElement("a");
        a.href = href;
        a.target = "_blank";
        a.rel = "noopener noreferrer";
        a.textContent = `${icon} ${name}`;
        shareButtons.appendChild(a);
      });

      const copyBtn = document.createElement("button");
      copyBtn.type = "button";
      copyBtn.textContent = " Copy link";
      copyBtn.addEventListener("click", () => {
        navigator.clipboard.writeText(fullText).then(() => {
          copyBtn.textContent = " Copied!";
          setTimeout(() => { copyBtn.textContent = " Copy link"; }, 2000);
        });
      });
      shareButtons.appendChild(copyBtn);

      shareModal.classList.add("show");
    }

    function hideShareModal() {
      shareModal.classList.remove("show");
    }

    // ---- Streak helpers ----

    function updateStreakDisplays() {
      currentStreakElem.textContent = `Streak: ${currentStreak}`;
      if (bestStreak > 0 && bestStreakName) {
        bestStreakElem.textContent = `Best streak: ${bestStreak} (${bestStreakName})`;
      } else {
        bestStreakElem.textContent = "Best streak: none";
      }
    }

    async function saveBestStreak() {
      // Only save to Firebase if it's a new record
      if (firebaseInitialized && db && bestStreak > 0) {
        try {
          const recordRef = db.collection("globalBestStreak").doc("record");
          const doc = await recordRef.get();
          
          // Only update if this is a new record
          if (!doc.exists || doc.data().streak < bestStreak) {
            await recordRef.set({
              streak: bestStreak,
              name: bestStreakName,
              timestamp: firebase.firestore.FieldValue.serverTimestamp()
            });
            console.log("Global best streak updated in Firebase!");
          }
        } catch (error) {
          console.error("Error saving to Firebase:", error);
          // Fallback to localStorage
          saveBestStreakLocal();
        }
      } else {
        // Fallback to localStorage if Firebase not configured
        saveBestStreakLocal();
      }
    }

    function saveBestStreakLocal() {
      try {
        const data = { name: bestStreakName, streak: bestStreak };
        localStorage.setItem("tictac9x9_best_streak", JSON.stringify(data));
      } catch (e) {
        // ignore storage errors
      }
    }

    async function loadBestStreak() {
      if (firebaseInitialized && db) {
        try {
          const doc = await db.collection("globalBestStreak").doc("record").get();
          if (doc.exists) {
            const data = doc.data();
            if (data && typeof data.streak === "number" && typeof data.name === "string") {
              bestStreak = data.streak;
              bestStreakName = data.name;
              updateStreakDisplays();
              console.log("Global best streak loaded from Firebase:", data);
              return;
            }
          }
        } catch (error) {
          console.error("Error loading from Firebase:", error);
          // Fallback to localStorage
          loadBestStreakLocal();
        }
      } else {
        // Fallback to localStorage if Firebase not configured
        loadBestStreakLocal();
      }
    }

    function loadBestStreakLocal() {
      try {
        const raw = localStorage.getItem("tictac9x9_best_streak");
        if (!raw) return;
        const data = JSON.parse(raw);
        if (typeof data.streak === "number" && typeof data.name === "string") {
          bestStreak = data.streak;
          bestStreakName = data.name;
        }
      } catch (e) {
        // ignore parse errors
      }
    }

    // ---- Stats helpers ----

    function saveStats() {
      try {
        localStorage.setItem("tictac9x9_currentPlayerStats", JSON.stringify(currentPlayerStats));
        localStorage.setItem("tictac9x9_globalStats", JSON.stringify(globalStats));
      } catch (e) {
        // ignore storage errors
      }
    }

    function loadStats() {
      try {
        const currentStatsRaw = localStorage.getItem("tictac9x9_currentPlayerStats");
        if (currentStatsRaw) {
          const data = JSON.parse(currentStatsRaw);
          if (data && typeof data.gamesPlayed === "number") {
            currentPlayerStats = {
              gamesPlayed: data.gamesPlayed || 0,
              wins: data.wins || 0,
              losses: data.losses || 0,
              draws: data.draws || 0,
              currentStreak: data.currentStreak || 0
            };
          }
        }
        
        const globalStatsRaw = localStorage.getItem("tictac9x9_globalStats");
        if (globalStatsRaw) {
          const data = JSON.parse(globalStatsRaw);
          if (data && typeof data.gamesPlayed === "number") {
            globalStats = {
              gamesPlayed: data.gamesPlayed || 0,
              wins: data.wins || 0,
              losses: data.losses || 0,
              draws: data.draws || 0,
              bestStreak: data.bestStreak || 0
            };
          }
        }
      } catch (e) {
        // ignore parse errors
      }
    }

    function updateStatsDisplay() {
      if (!statsModal) return;
      
      const name = currentPlayerName || humanNameInput?.value?.trim() || "Current Player";
      const currentPlayerNameEl = document.getElementById("currentPlayerName");
      if (currentPlayerNameEl) currentPlayerNameEl.textContent = name;
      
      const winRate = currentPlayerStats.gamesPlayed > 0 
        ? Math.round((currentPlayerStats.wins / currentPlayerStats.gamesPlayed) * 100) 
        : 0;
      
      document.getElementById("statCurrentGamesPlayed").textContent = currentPlayerStats.gamesPlayed;
      document.getElementById("statCurrentWins").textContent = currentPlayerStats.wins;
      document.getElementById("statCurrentLosses").textContent = currentPlayerStats.losses;
      document.getElementById("statCurrentDraws").textContent = currentPlayerStats.draws;
      document.getElementById("statCurrentWinRate").textContent = `${winRate}%`;
      document.getElementById("statCurrentStreak").textContent = currentStreak;
      
      const globalWinRate = globalStats.gamesPlayed > 0 
        ? Math.round((globalStats.wins / globalStats.gamesPlayed) * 100) 
        : 0;
      
      document.getElementById("statGlobalGamesPlayed").textContent = globalStats.gamesPlayed;
      document.getElementById("statGlobalWins").textContent = globalStats.wins;
      document.getElementById("statGlobalLosses").textContent = globalStats.losses;
      document.getElementById("statGlobalDraws").textContent = globalStats.draws;
      document.getElementById("statGlobalWinRate").textContent = `${globalWinRate}%`;
      
      const globalBestStreakDisplay = bestStreak > 0 && bestStreakName 
        ? `${bestStreak} (${bestStreakName})`
        : bestStreak;
      document.getElementById("statGlobalBestStreak").textContent = globalBestStreakDisplay;
    }

    function showStats() {
      updateStatsDisplay();
      if (statsModal) statsModal.classList.add("show");
    }

    function hideStats() {
      if (statsModal) statsModal.classList.remove("show");
    }

    async function loadLeaderboard() {
      if (!firebaseInitialized || !db) return [];
      
      try {
        const snapshot = await db.collection("multiplayerLeaderboard")
          .orderBy("totalPoints", "desc")
          .limit(10)
          .get();
        
        return snapshot.docs.map(doc => {
          const data = doc.data();
          return {
            name: data.name || "Unknown",
            totalPoints: data.totalPoints || 0,
            matchesPlayed: data.matchesPlayed || 0,
            wins: data.wins || 0,
            draws: data.draws || 0,
            losses: data.losses || 0
          };
        });
      } catch (error) {
        console.error("Error loading leaderboard:", error);
        return [];
      }
    }

    function hideLeaderboardModal() {
      const leaderboardModal = document.getElementById("leaderboardModal");
      if (leaderboardModal) leaderboardModal.classList.remove("show");
    }

    async function showLeaderboardModal() {
      const leaderboard = await loadLeaderboard();
      const leaderboardModal = document.getElementById("leaderboardModal");
      const leaderboardContent = document.getElementById("leaderboardContent");
      if (!leaderboardModal || !leaderboardContent) return;
      
      // Track leaderboard view
      trackEvent('leaderboard_viewed', {
        'total_players': leaderboard.length
      });

      if (leaderboard.length === 0) {
        leaderboardContent.innerHTML = '<div style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">No multiplayer matches yet. Play a match to appear here!</div>';
      } else {
        const myName = (currentPlayerName || humanNameInput?.value?.trim() || "").toLowerCase();
        leaderboardContent.innerHTML = leaderboard.map((player, index) => {
          const rank = index + 1;
          const rankClass = rank === 1 ? "gold" : rank === 2 ? "silver" : rank === 3 ? "bronze" : "";
          const isYou = player.name.toLowerCase() === myName;
          const winRate = player.matchesPlayed > 0 ? Math.round((player.wins / player.matchesPlayed) * 100) : 0;
          
          return `
            <div class="leaderboard-row ${isYou ? 'you' : ''}">
              <div class="leaderboard-rank ${rankClass}">${rank}</div>
              <div class="leaderboard-player">
                <div class="leaderboard-player-name">${escapeHtml(player.name)}${isYou ? ' (You)' : ''}</div>
                <div class="leaderboard-player-stats">${player.matchesPlayed} matches  ${player.wins}W ${player.draws}D ${player.losses}L  ${winRate}% win</div>
              </div>
              <div class="leaderboard-points">
                <div class="leaderboard-points-value">${player.totalPoints}</div>
                <div class="leaderboard-points-label">points</div>
              </div>
            </div>
          `;
        }).join("");
      }

      leaderboardModal.classList.add("show");
    }

    // ---- AI evaluation helpers ----

    function simulateLineLength(r, c, player, dr, dc) {
      // Temporarily treat (r,c) as player's stone without mutating board
      let count = 1;

      let nr = r + dr;
      let nc = c + dc;
      while (inBounds(nr, nc) && (board[nr][nc] === player || (nr === r && nc === c))) {
        if (board[nr][nc] !== "" || (nr === r && nc === c)) {
          count++;
        }
        nr += dr;
        nc += dc;
      }

      nr = r - dr;
      nc = c - dc;
      while (inBounds(nr, nc) && (board[nr][nc] === player || (nr === r && nc === c))) {
        if (board[nr][nc] !== "" || (nr === r && nc === c)) {
          count++;
        }
        nr -= dr;
        nc -= dc;
      }

      return count;
    }

    function scoreMove(r, c) {
      // Higher is better for computer
      if (board[r][c] !== "") return -Infinity;

      // 1) Immediate win for computer
      board[r][c] = computerPlayer;
      const winNow = getWinningLine(board, r, c, computerPlayer);
      board[r][c] = "";
      if (winNow) return 1_000_000;

      // 2) Immediate block of human win
      board[r][c] = humanPlayer;
      const blockHumanWin = getWinningLine(board, r, c, humanPlayer);
      board[r][c] = "";
      if (blockHumanWin) return 900_000;

      // 3) Positional heuristic: extend our lines and block opponent's
      const directions = [
        [0, 1],
        [1, 0],
        [1, 1],
        [1, -1],
      ];

      let score = 0;

      for (const [dr, dc] of directions) {
        const ourLen = simulateLineLength(r, c, computerPlayer, dr, dc);
        const theirLen = simulateLineLength(r, c, humanPlayer, dr, dc);

        // Offensive weights: strongly prefer building 4s and 3s
        if (ourLen >= WIN_LENGTH) {
          score += 100_000;
        } else if (ourLen === 4) {
          score += 8_000;
        } else if (ourLen === 3) {
          score += 1_500;
        } else if (ourLen === 2) {
          score += 400;
        } else if (ourLen === 1) {
          score += 50;
        }

        // Defensive weights: block strong human lines
        if (theirLen >= WIN_LENGTH) {
          score += 90_000;
        } else if (theirLen === 4) {
          score += 7_000;
        } else if (theirLen === 3) {
          score += 1_200;
        } else if (theirLen === 2) {
          score += 350;
        } else if (theirLen === 1) {
          score += 40;
        }
      }

      // Slight preference toward the center of the board
      const center = (BOARD_SIZE - 1) / 2;
      const distFromCenter = Math.abs(r - center) + Math.abs(c - center);
      score += (BOARD_SIZE * 2 - distFromCenter) * 5;

      return score;
    }

    function updateRestartButtonText() {
      // In multiplayer mode with active game, show "Forfeit" button
      if (gameMode === "multiplayer" && currentRoomId && gameStarted && !gameOver) {
        restartBtn.textContent = "Forfeit";
        restartBtn.title = "Forfeit match (opponent gets 4 points)";
        restartBtn.classList.add("forfeit-button");
      } else {
        restartBtn.classList.remove("forfeit-button");
        if (!gameStarted) {
          restartBtn.textContent = "Start Game";
          restartBtn.title = "Start game (R or Space)";
        } else {
          restartBtn.textContent = "Restart game";
          restartBtn.title = "Restart game (R or Space)";
        }
      }
    }

    function restartGame() {
      // In multiplayer mode with active game, handle as forfeit
      if (gameMode === "multiplayer" && currentRoomId && gameStarted && !gameOver) {
        // Show forfeit modal
        showForfeitModal("forfeit-button");
        return;
      }
      
      if (gameMode === "multiplayer" && currentRoomId) {
        alert("Cannot restart in multiplayer mode. Please leave the room first.");
        return;
      }
      
      // Hide play again modal if it's showing (in case it was somehow shown)
      hidePlayAgainModal();
      
      // Check if there's an active game that hasn't ended
      // An active game means: game has started, not over, and has moves on the board
      const hasMovesOnBoard = board.some(row => row.some(cell => cell !== ""));
      const hasActiveGame = !gameOver && gameStarted && hasMovesOnBoard;
      
      if (hasActiveGame) {
        // Show forfeit modal for restart
        showForfeitModal("restart");
        return;
      }
      
      // If game not started and computer goes first: user is clicking "Start Game" to begin
      if (!gameStarted && currentPlayer === computerPlayer && hasHumanName()) {
        startGameWithComputerFirst();
        return;
      }
      
      // Otherwise start a new round (human goes first: they click board; computer first: status says "click Start Game")
      startNewRound();
    }

    function setStatusForTurn() {
      if (!hasHumanName()) {
        statusElem.textContent = "Enter your name above to start playing";
        statusRow.className = "status-neutral";
        return;
      }

      if (gameMode === "multiplayer" && currentRoomId) {
        if (currentPlayer === humanPlayer) {
          const name = getHumanDisplayName();
          setStatusWithMark(name, currentPlayer, "  your turn");
          statusRow.className = "status-your-turn";
        } else {
          setStatusWithMark(opponentName || "Opponent", currentPlayer, " is thinking...");
          statusRow.className = "status-computer-turn";
        }
      } else {
        // Training mode
        if (currentPlayer === humanPlayer) {
          const name = getHumanDisplayName();
          setStatusWithMark(name, currentPlayer, "  your turn");
          statusRow.className = "status-your-turn";
          computerThinking = false;
        } else {
          setStatusWithMark(getComputerDisplayName(), currentPlayer, " is thinking...");
          statusRow.className = "status-computer-turn";
          computerThinking = true;
        }
      }
    }

    // ---- Theme management ----

    function getTheme() {
      return localStorage.getItem("tictac9x9_theme") || "light";
    }

    function setTheme(theme) {
      document.documentElement.setAttribute("data-theme", theme);
      localStorage.setItem("tictac9x9_theme", theme);
      themeToggleBtn.textContent = theme === "dark" ? "" : "";
    }

    function toggleTheme() {
      const currentTheme = getTheme();
      const newTheme = currentTheme === "light" ? "dark" : "light";
      setTheme(newTheme);
    }

    // Initialize theme
    setTheme(getTheme());
    themeToggleBtn.addEventListener("click", toggleTheme);

    // ---- Multiplayer Mode ----

    function generateRoomId() {
      return Math.random().toString(36).substring(2, 8).toUpperCase();
    }

    function loadGameMode() {
      try {
        const saved = localStorage.getItem("tictac9x9_gameMode");
        if (saved === "multiplayer" || saved === "training") {
          gameMode = saved;
        }
      } catch (e) {
        // ignore errors
        gameMode = "training"; // Default to training on error
      }
    }

    function saveGameMode() {
      try {
        localStorage.setItem("tictac9x9_gameMode", gameMode);
      } catch (e) {
        // ignore errors
      }
    }

    function updateModeToggle() {
      // Ensure elements exist before trying to update them
      const toggleSwitch = document.getElementById("modeToggleSwitch");
      const toggleSwitchMultiplayer = document.getElementById("modeToggleSwitchMultiplayer");
      
      if (!toggleSwitch || !toggleSwitchMultiplayer) {
        console.warn("Mode toggle elements not found");
        return;
      }
      
      if (gameMode === "multiplayer") {
        toggleSwitch.classList.add("multiplayer");
        toggleSwitchMultiplayer.classList.add("multiplayer");
        toggleSwitch.title = "Multiplayer Mode - Click to switch to Training";
        toggleSwitchMultiplayer.title = "Multiplayer Mode - Click to switch to Training";
        // Hide streak displays, show multiplayer scores
        const streakBar = document.getElementById("streak-bar");
        const statsBtn = document.getElementById("statsBtn");
        const leaderboardBtn = document.getElementById("leaderboardBtn");
        const trophyBtn = document.getElementById("trophyBtn");
        
        if (streakBar) streakBar.style.display = "none";
        const waitingPromptContainer = document.getElementById("waitingPlayerPromptContainer");
        if (waitingPromptContainer) waitingPromptContainer.style.display = "none";
        try { stopWaitingRoomCheck(); } catch (e) { console.warn("stopWaitingRoomCheck:", e); }
        if (multiplayerScoreBar) multiplayerScoreBar.style.display = "flex";
        if (statsBtn) statsBtn.style.display = "none";
        if (leaderboardBtn) leaderboardBtn.style.display = "block";
        if (trophyBtn) trophyBtn.style.display = "none";
      } else {
        toggleSwitch.classList.remove("multiplayer");
        toggleSwitchMultiplayer.classList.remove("multiplayer");
        toggleSwitch.title = "Training Mode - Click to switch to Multiplayer";
        toggleSwitchMultiplayer.title = "Training Mode - Click to switch to Multiplayer";
        // Show streak displays, hide multiplayer scores
        const streakBar = document.getElementById("streak-bar");
        const statsBtn = document.getElementById("statsBtn");
        const leaderboardBtn = document.getElementById("leaderboardBtn");
        const trophyBtn = document.getElementById("trophyBtn");
        
        if (streakBar) streakBar.style.display = "flex";
        const waitingPromptContainer = document.getElementById("waitingPlayerPromptContainer");
        if (waitingPromptContainer) waitingPromptContainer.style.display = "block";
        try { startWaitingRoomCheck(); } catch (e) { console.warn("startWaitingRoomCheck:", e); }
        if (multiplayerScoreBar) multiplayerScoreBar.style.display = "none";
        if (statsBtn) statsBtn.style.display = "block";
        if (leaderboardBtn) leaderboardBtn.style.display = "none";
        if (trophyBtn) trophyBtn.style.display = "block";
        // Reset multiplayer score display
        updateMultiplayerScoreDisplay();
      }
    }

    function updateMultiplayerScoreDisplay() {
      if (gameMode !== "multiplayer") return;
      
      const player1NameDisplay = document.getElementById("player1NameDisplay");
      const player2NameDisplay = document.getElementById("player2NameDisplay");
      const player1ScoreDisplay = document.getElementById("player1ScoreDisplay");
      const player2ScoreDisplay = document.getElementById("player2ScoreDisplay");
      
      if (!player1NameDisplay || !player2NameDisplay || !player1ScoreDisplay || !player2ScoreDisplay) return;
      
      // Update player names
      if (player1Name) {
        player1NameDisplay.textContent = player1Name;
      } else {
        player1NameDisplay.textContent = "-";
      }
      
      if (player2Name) {
        player2NameDisplay.textContent = player2Name;
        // Stop loading animation
        if (loadingDotsInterval) {
          clearInterval(loadingDotsInterval);
          loadingDotsInterval = null;
        }
      } else {
        // Show "Waiting" + loading dots animation
        if (!player2NameDisplay.querySelector(".loading-dots")) {
          player2NameDisplay.innerHTML = 'Waiting <span class="loading-dots"></span>';
        } else {
          // Update text but keep dots
          const loadingSpan = player2NameDisplay.querySelector(".loading-dots");
          if (loadingSpan && !player2NameDisplay.textContent.includes("Waiting")) {
            player2NameDisplay.innerHTML = 'Waiting <span class="loading-dots"></span>';
          }
        }
        // Animate dots
        const loadingSpan = player2NameDisplay.querySelector(".loading-dots");
        if (loadingSpan && !loadingDotsInterval) {
          let dotCount = 0;
          loadingDotsInterval = setInterval(() => {
            dotCount = (dotCount % 3) + 1;
            loadingSpan.textContent = '.'.repeat(dotCount);
          }, 500);
        }
      }
      
      // Update scores
      if (currentRoomId && player1Name) {
        const scores = calculateMatchScore(matchResults.player1Wins, matchResults.draws, matchResults.player2Wins);
        currentMatchScore = { player1: scores.player1Score, player2: scores.player2Score };
        player1ScoreDisplay.textContent = scores.player1Score;
        player2ScoreDisplay.textContent = scores.player2Score;
      } else {
        player1ScoreDisplay.textContent = "0";
        player2ScoreDisplay.textContent = "0";
      }
    }

    let isToggling = false; // Prevent double-firing
    
    async function toggleGameMode() {
      if (isToggling) {
        console.log("Toggle already in progress, ignoring duplicate call");
        return;
      }
      
      isToggling = true;
      console.log("toggleGameMode called, current mode:", gameMode);
      
      try {
        if (gameMode === "training") {
          // Switching to multiplayer - need name first
          if (!hasHumanName()) {
            alert("Please enter your name before switching to multiplayer mode.");
            isToggling = false;
            return;
          }
          console.log("Switching to multiplayer mode");
          gameMode = "multiplayer";
          saveGameMode();
          updateModeToggle();
          // Track mode switch
          trackEvent('mode_switch', {
            'from': 'training',
            'to': 'multiplayer'
          });
          showRoomModal();
        } else {
          // Switching to training - check if we need to forfeit first
          if (currentRoomId && gameMode === "multiplayer" && firebaseInitialized && db) {
            try {
              const roomRef = db.collection("gameRooms").doc(currentRoomId);
              const roomDoc = await roomRef.get();
              if (roomDoc.exists) {
                const roomData = roomDoc.data();
                const totalGames = (roomData.matchResults?.player1Wins || 0) + (roomData.matchResults?.player2Wins || 0) + (roomData.matchResults?.draws || 0);
                const matchFinished = roomData.gameOver && totalGames >= 2;
                // If match is not finished and both players are present, show forfeit modal
                if (!matchFinished && roomData.player1 && roomData.player2) {
                  showForfeitModal("switch-mode");
                  isToggling = false; // Reset flag since we're not switching yet
                  return; // Don't switch yet - wait for user confirmation
                }
              }
            } catch (error) {
              console.error("Error checking room state before mode switch:", error);
            }
          }
          // No active match or match finished - safe to switch
          if (currentRoomId) {
            await leaveRoom();
          }
          console.log("Switching to training mode");
          gameMode = "training";
          saveGameMode();
          updateModeToggle();
          // Track mode switch
          trackEvent('mode_switch', {
            'from': 'multiplayer',
            'to': 'training'
          });
          // Use startNewRound instead of restartGame to prevent auto-starting computer
          startNewRound();
        }
      } finally {
        // Reset flag after a short delay to allow the toggle to complete
        setTimeout(() => {
          isToggling = false;
        }, 300);
      }
    }

    function showRoomModal() {
      // Ensure buttons exist
      let buttonsDiv = roomModalBody.querySelector("div[style*='flex-direction: column']");
      if (!buttonsDiv) {
        // Create buttons if they don't exist (first time)
        buttonsDiv = document.createElement("div");
        buttonsDiv.style.cssText = "display: flex; flex-direction: column; gap: 10px;";
        buttonsDiv.innerHTML = `
          <button id="quickMatchBtn" class="button" style="width: 100%;">Quick Match</button>
          <button id="createRoomBtn" class="button" style="width: 100%;">Create Room</button>
          <button id="joinRoomBtn" class="button" style="width: 100%;">Join Room</button>
        `;
        // Insert at the beginning of roomModalBody
        roomModalBody.insertBefore(buttonsDiv, roomModalBody.firstChild);
      }
      
      // Show buttons, hide other sections
      buttonsDiv.style.display = "flex";
      roomIdSection.style.display = "none";
      waitingRoomSection.style.display = "none";
      joinRoomSection.style.display = "none";
      roomModal.classList.add("show");
      
      // Re-attach event listeners (remove old ones first to avoid duplicates)
      const createBtn = document.getElementById("createRoomBtn");
      const joinBtn = document.getElementById("joinRoomBtn");
      
      if (createBtn) {
        // Remove old listener and add new one
        const newCreateBtn = createBtn.cloneNode(true);
        createBtn.parentNode.replaceChild(newCreateBtn, createBtn);
        newCreateBtn.addEventListener("click", function(e) {
          console.log("Create Room button clicked");
          e.preventDefault();
          e.stopPropagation();
          createRoom();
        });
      }
      
      if (joinBtn) {
        // Remove old listener and add new one
        const newJoinBtn = joinBtn.cloneNode(true);
        joinBtn.parentNode.replaceChild(newJoinBtn, joinBtn);
        newJoinBtn.addEventListener("click", () => {
          // Hide buttons, show join room input
          const buttonsDiv = roomModalBody.querySelector("div[style*='flex-direction: column']");
          if (buttonsDiv) {
            buttonsDiv.style.display = "none";
          }
          if (roomIdSection) roomIdSection.style.display = "none";
          if (waitingRoomSection) waitingRoomSection.style.display = "none";
          if (joinRoomSection) joinRoomSection.style.display = "block";
          if (joinRoomIdInput) {
            joinRoomIdInput.focus();
            joinRoomIdInput.value = ""; // Clear any previous input
          }
        });
      }
      
      // quickMatch handled via event delegation on roomModalContent
    }

    async function hideRoomModal(switchToTraining = true) {
      roomModal.classList.remove("show");
      // Only return to training when user explicitly closes (not when both players join)
      if (switchToTraining && gameMode === "multiplayer") {
        // Check if there's an active game - prevent leaving without forfeiting
        const hasActiveGame = gameStarted && !gameOver && currentRoomId;
        if (hasActiveGame) {
          // Show forfeit modal for multiplayer
          showForfeitModal("leave-room");
          return; // Don't leave yet - wait for user confirmation
        }
        await leaveRoom();
        gameMode = "training";
        saveGameMode();
        updateModeToggle();
        startNewRound(); // Reset to training state
      }
    }

    async function createRoom(matchType = "open") {
      console.log("createRoom called");
      
      if (!firebaseInitialized || !db) {
        console.error("Firebase not initialized");
        alert("Multiplayer requires Firebase. Please configure Firebase.");
        return;
      }
      if (!hasHumanName()) {
        console.error("No name entered");
        alert("Please enter your name first.");
        return;
      }
      
      if (gameMode !== "multiplayer") {
        console.error("Not in multiplayer mode, current mode:", gameMode);
        alert("Please switch to multiplayer mode first.");
        return;
      }

      const roomId = generateRoomId();
      console.log("Creating room with ID:", roomId);
      currentRoomId = roomId;
      isPlayer1 = true;
      matchGameNumber = 0;
      matchResults = { player1Wins: 0, draws: 0, player2Wins: 0 };

      try {
        const playerName = currentPlayerName || humanNameInput.value.trim();
        console.log("Creating room for player:", playerName);
        await db.collection("gameRooms").doc(roomId).set({
          roomId: roomId,
          player1: {
            name: playerName,
            mark: "X",
            ready: true
          },
          player2: null,
          status: "waiting",
          matchType: matchType, // "open" = join by ID; "quick" = Quick Match only
          quickMatchKey: matchType === "quick" ? "waiting" : null, // Single-field query for Quick Match (avoids composite index)
          board: boardToFirestore(createEmptyBoard()), // Convert 2D array to flat array for Firestore
          currentPlayer: "X",
          gameOver: false,
          winner: null,
          matchGameNumber: 0,
          matchResults: { player1Wins: 0, draws: 0, player2Wins: 0 },
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          lastMove: firebase.firestore.FieldValue.serverTimestamp()
        });

        player1Name = playerName;
        player2Name = ""; // Reset until player2 joins
        
        // Update display immediately - check if we're in multiplayer mode
        if (gameMode === "multiplayer") {
          const player1NameDisplay = document.getElementById("player1NameDisplay");
          if (player1NameDisplay) {
            player1NameDisplay.textContent = playerName;
          }
          updateMultiplayerScoreDisplay();
        }
        // Hide the buttons div
        const buttonsDiv = roomModalBody.querySelector("div[style*='flex-direction: column']");
        if (buttonsDiv) {
          buttonsDiv.style.display = "none";
        }
        
        // Show room ID and waiting sections
        console.log("Setting room ID display:", roomId);
        console.log("roomIdDisplay element:", roomIdDisplay);
        console.log("roomIdSection element:", roomIdSection);
        
        if (roomIdDisplay) {
          roomIdDisplay.textContent = roomId;
        } else {
          console.error("roomIdDisplay not found!");
        }
        
        if (roomIdSection) {
          roomIdSection.style.display = "block";
          console.log("Room ID section displayed");
        } else {
          console.error("roomIdSection not found!");
        }
        
        if (waitingRoomSection) {
          waitingRoomSection.style.display = "block";
        }
        
        if (joinRoomSection) {
          joinRoomSection.style.display = "none"; // Hide join section
        }
        
        if (roomPlayer1) roomPlayer1.textContent = playerName;
        if (roomPlayer2) roomPlayer2.textContent = "Waiting...";
        
        console.log("Room created! Share this ID:", roomId);

        // Listen for room updates
        setupRoomListener(roomId);
        console.log("Room created successfully:", roomId);
        console.log("Room ID to share:", roomId);
        // Track room creation
        trackEvent('multiplayer_room_created', {
          'room_id': roomId,
          'match_type': matchType
        });
      } catch (error) {
        console.error("Error creating room:", error);
        console.error("Error details:", error.message, error.stack);
        alert("Failed to create room: " + error.message);
      }
    }

    async function joinRoom(roomIdToJoin) {
      if (!firebaseInitialized || !db) {
        alert("Multiplayer requires Firebase. Please configure Firebase.");
        return;
      }
      if (!hasHumanName()) {
        alert("Please enter your name first.");
        return;
      }

      const roomId = roomIdToJoin || joinRoomIdInput.value.trim().toUpperCase();
      if (!roomId) {
        alert("Please enter a room ID.");
        return;
      }

      try {
        const roomRef = db.collection("gameRooms").doc(roomId);
        const roomDoc = await roomRef.get();

        if (!roomDoc.exists) {
          alert("Room not found. Please check the room ID.");
          return;
        }

        const roomData = roomDoc.data();
        if (roomData.player2) {
          alert("Room is full.");
          return;
        }

        // Prevent self-matching
        const playerName = currentPlayerName || humanNameInput.value.trim();
        const creatorName = (roomData.player1?.name || "").toLowerCase();
        const myName = playerName.toLowerCase();
        if (creatorName && myName && creatorName === myName) {
          alert("You cannot join your own room. Please create a new room or join a different one.");
          return;
        }
        currentRoomId = roomId;
        isPlayer1 = false;
        matchGameNumber = 0;
        matchResults = { player1Wins: 0, draws: 0, player2Wins: 0 };

        await roomRef.update({
          player2: {
            name: playerName,
            mark: "O",
            ready: true
          },
          status: "full",
          quickMatchKey: null, // No longer in Quick Match pool
          lastMove: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        player2Name = playerName;
        // Also set player1Name from room data if we're joining
        const roomDataJoin = roomDoc.data();
        if (roomDataJoin.player1) {
          player1Name = roomDataJoin.player1.name;
          // Update display immediately
          const player1NameDisplay = document.getElementById("player1NameDisplay");
          if (player1NameDisplay) {
            player1NameDisplay.textContent = player1Name;
          }
        }
        updateMultiplayerScoreDisplay();

        hideRoomModal(false); // Don't switch to training - game is starting
        setupRoomListener(roomId);
        // Track room join
        trackEvent('multiplayer_room_joined', {
          'room_id': roomId
        });
      } catch (error) {
        console.error("Error joining room:", error);
        alert("Failed to join room. Please try again.");
      }
    }

    async function quickMatch() {
      if (!firebaseInitialized || !db) {
        alert("Multiplayer requires Firebase. Please configure Firebase.");
        return;
      }
      if (!hasHumanName()) {
        alert("Please enter your name first.");
        return;
      }

      try {
        // Only match with other Quick Match players (quickMatchKey = "waiting")
        const waitingRooms = await db.collection("gameRooms")
          .where("quickMatchKey", "==", "waiting")
          .limit(10)
          .get();

        if (!waitingRooms.empty) {
          // Filter out own rooms and pick a random Quick Match room
          const playerName = currentPlayerName || humanNameInput.value.trim();
          const myName = playerName.toLowerCase();
          const availableRooms = waitingRooms.docs.filter(doc => {
            const roomData = doc.data();
            const creatorName = (roomData.player1?.name || "").toLowerCase();
            return !(creatorName && myName && creatorName === myName);
          });

          if (availableRooms.length > 0) {
            const roomDoc = availableRooms[Math.floor(Math.random() * availableRooms.length)];
            await joinRoom(roomDoc.id);
          } else {
            // All available rooms are our own, create a new one
            await createRoom("quick");
          }
        } else {
          // No one waiting, create a Quick Match room for others to find
          await createRoom("quick");
        }
      } catch (error) {
        console.error("Error in quick match:", error);
        alert("Failed to find a match. Creating a room instead...");
        await createRoom();
      }
    }

    function startWaitingRoomCheck() {
      stopWaitingRoomCheck();
      if (gameMode !== "training" || !firebaseInitialized || !db || !hasHumanName()) return;

      let lastSnapshot = null;
      const waitMs = 5000; // Room must be waiting 5+ seconds (client-side "first seen")

      function processSnapshot(snapshot) {
        lastSnapshot = snapshot;
      }

      function checkAndShow() {
        if (gameMode !== "training" || currentRoomId) return;
        const prompt = document.getElementById("waitingPlayerPrompt");
        if (prompt && prompt.classList.contains("visible")) return;
        if (!lastSnapshot) return;

        const myName = (currentPlayerName || humanNameInput?.value?.trim() || "").toLowerCase();
        const now = Date.now();
        const currentRoomIds = new Set(lastSnapshot.docs.map((d) => d.id));
        for (const id of Object.keys(waitingRoomsFirstSeen)) {
          if (!currentRoomIds.has(id)) delete waitingRoomsFirstSeen[id];
        }

        lastSnapshot.docs.forEach((doc) => {
          const d = doc.data();
          if (d.player2) return;
          const creatorName = (d.player1?.name || "").toLowerCase();
          if (creatorName && myName && creatorName === myName) return;

          const roomId = doc.id;
          if (!waitingRoomsFirstSeen[roomId]) {
            waitingRoomsFirstSeen[roomId] = now;
          }
        });

        let bestRoom = null;
        let oldestSeen = 0;
        for (const [roomId, firstSeen] of Object.entries(waitingRoomsFirstSeen)) {
          if (now - firstSeen >= waitMs && firstSeen > oldestSeen) {
            const doc = lastSnapshot.docs.find((d) => d.id === roomId);
            if (doc) {
              const d = doc.data();
              if (!d.player2) {
                const creatorName = (d.player1?.name || "").toLowerCase();
                if (!(creatorName && myName && creatorName === myName)) {
                  oldestSeen = firstSeen;
                  bestRoom = { id: roomId, data: d };
                }
              }
            }
          }
        }

        if (bestRoom) {
          waitingRoomsFirstSeen = {};
          showWaitingPlayerPrompt(bestRoom.id);
        }
      }

      try {
        waitingRoomListenerUnsub = db.collection("gameRooms")
          .where("status", "==", "waiting")
          .limit(20)
          .onSnapshot(
            (snapshot) => {
              processSnapshot(snapshot);
              checkAndShow();
            },
            (error) => { console.error("Waiting rooms listener:", error); }
          );
        waitingRoomCheckInterval = setInterval(checkAndShow, 1000);
      } catch (error) {
        console.error("Error starting waiting room listener:", error);
      }
    }

    function stopWaitingRoomCheck() {
      if (waitingRoomCheckInterval) {
        clearInterval(waitingRoomCheckInterval);
        waitingRoomCheckInterval = null;
      }
      if (waitingRoomListenerUnsub) {
        waitingRoomListenerUnsub();
        waitingRoomListenerUnsub = null;
      }
      if (waitingPromptAutoHideTimeout) {
        clearTimeout(waitingPromptAutoHideTimeout);
        waitingPromptAutoHideTimeout = null;
      }
      if (waitingPromptReappearTimeout) {
        clearTimeout(waitingPromptReappearTimeout);
        waitingPromptReappearTimeout = null;
      }
      currentWaitingRoomId = null;
      waitingRoomsFirstSeen = {};
      hideWaitingPlayerPrompt(false, false);
      const container = document.getElementById("waitingPlayerPromptContainer");
      if (container) container.classList.remove("has-room");
    }

    function showWaitingPlayerPrompt(roomId) {
      const container = document.getElementById("waitingPlayerPromptContainer");
      const prompt = document.getElementById("waitingPlayerPrompt");
      const btn = document.getElementById("joinWaitingRoomBtn");
      if (!prompt || !btn) return;

      // Clear any existing timeouts
      if (waitingPromptAutoHideTimeout) {
        clearTimeout(waitingPromptAutoHideTimeout);
        waitingPromptAutoHideTimeout = null;
      }
      if (waitingPromptReappearTimeout) {
        clearTimeout(waitingPromptReappearTimeout);
        waitingPromptReappearTimeout = null;
      }

      stopWaitingRoomCheck();
      currentWaitingRoomId = roomId;
      btn.textContent = "Opponent is waiting!";
      btn.disabled = false;
      if (container) container.classList.add("has-room");
      prompt.classList.remove("slide-out");
      prompt.classList.add("visible");

      // Auto-hide after 10 seconds
      waitingPromptAutoHideTimeout = setTimeout(() => {
        hideWaitingPlayerPrompt(false, false);
        // Reappear after 1 minute (60 seconds)
        waitingPromptReappearTimeout = setTimeout(() => {
          if (gameMode === "training" && !currentRoomId) {
            showWaitingPlayerPrompt(roomId);
          }
        }, 60000); // 1 minute
      }, 10000); // 10 seconds

      // Listen for someone else joining or room closed
      waitingRoomListenerUnsub = db.collection("gameRooms").doc(roomId).onSnapshot((doc) => {
        if (!doc.exists) {
          hideWaitingPlayerPrompt(false); // Room was closed
          return;
        }
        const d = doc.data();
        if (d.player2 && currentRoomId !== roomId) {
          hideWaitingPlayerPrompt(true); // Match started by someone else
        }
      });
    }

    function hideWaitingPlayerPrompt(matchStarted, resumeCheck = true) {
      const container = document.getElementById("waitingPlayerPromptContainer");
      const prompt = document.getElementById("waitingPlayerPrompt");
      const btn = document.getElementById("joinWaitingRoomBtn");
      if (!prompt || !btn) return;

      // Clear auto-hide timeout if hiding manually
      if (waitingPromptAutoHideTimeout) {
        clearTimeout(waitingPromptAutoHideTimeout);
        waitingPromptAutoHideTimeout = null;
      }

      if (waitingRoomListenerUnsub) {
        waitingRoomListenerUnsub();
        waitingRoomListenerUnsub = null;
      }
      currentWaitingRoomId = null;

      if (matchStarted) {
        btn.textContent = "match started";
        btn.disabled = true;
        prompt.classList.remove("visible");
        prompt.classList.add("slide-out");
        setTimeout(() => {
          prompt.classList.remove("slide-out");
          btn.textContent = "Opponent is waiting!";
          btn.disabled = false;
          if (container) container.classList.remove("has-room");
          if (resumeCheck) startWaitingRoomCheck();
        }, 450);
      } else {
        prompt.classList.remove("visible", "slide-out");
        btn.textContent = "Opponent is waiting!";
        btn.disabled = false;
        if (container) container.classList.remove("has-room");
        if (resumeCheck) startWaitingRoomCheck();
      }
    }

    async function onJoinWaitingRoomClick() {
      if (!currentWaitingRoomId) return;
      const roomId = currentWaitingRoomId;
      // Clear timeouts when user clicks to join
      if (waitingPromptAutoHideTimeout) {
        clearTimeout(waitingPromptAutoHideTimeout);
        waitingPromptAutoHideTimeout = null;
      }
      if (waitingPromptReappearTimeout) {
        clearTimeout(waitingPromptReappearTimeout);
        waitingPromptReappearTimeout = null;
      }
      hideWaitingPlayerPrompt(false, false);
      stopWaitingRoomCheck();

      if (firebaseInitialized && db) {
        try {
          const roomDoc = await db.collection("gameRooms").doc(roomId).get();
          if (!roomDoc.exists) return;
          const d = roomDoc.data();
          const creatorName = (d?.player1?.name || "").toLowerCase();
          const myName = (currentPlayerName || humanNameInput?.value?.trim() || "").toLowerCase();
          if (creatorName && myName && creatorName === myName) return; // Don't join our own room
        } catch (e) {
          console.warn("Could not verify room before join:", e);
        }
      }

      gameMode = "multiplayer";
      saveGameMode();
      updateModeToggle();
      joinRoom(roomId);
    }

    function setupRoomListener(roomId) {
      if (roomListener) {
        roomListener(); // Unsubscribe previous listener
      }

      roomListener = db.collection("gameRooms").doc(roomId).onSnapshot(
        async (doc) => {
          if (!doc.exists) {
            // Room was deleted - silently handle it
            if (currentRoomId === roomId) {
              // Only leave room if not showing rematch decline modal or forfeit result modal (user will click "Back to Multiplayer")
              const showingRematchDeclineModal = rematchDeclineResultModal?.classList.contains("show");
              const showingForfeitModal = forfeitModal?.classList.contains("show");
              if (!showingRematchDeclineModal && !showingForfeitModal) {
                leaveRoom();
              }
            }
            return;
          }

          const roomData = doc.data();
          
          // Check for forfeit - opponent has forfeited
          // Use local flag to prevent duplicate modal display
          const forfeitKey = `forfeitShown_${roomId}_${roomData.forfeitedBy}`;
          const alreadyShownForfeit = sessionStorage.getItem(forfeitKey) === "true";
          
          if (roomData.forfeit === true && roomData.forfeitedBy && 
              ((isPlayer1 && roomData.forfeitedBy === "player2") || 
               (!isPlayer1 && roomData.forfeitedBy === "player1")) &&
              !alreadyShownForfeit) {
            // Mark as shown locally to prevent duplicate handling
            sessionStorage.setItem(forfeitKey, "true");
            
            // Opponent has forfeited - we win!
            const totalGames = (roomData.matchResults?.player1Wins || 0) + 
                              (roomData.matchResults?.player2Wins || 0) + 
                              (roomData.matchResults?.draws || 0);
            const matchFinished = roomData.gameOver && totalGames >= 2;
            
            // Update local match results to reflect forfeit (opponent gets 0, we get 4 points)
            let updatedMatchResults = { ...(roomData.matchResults || { player1Wins: 0, draws: 0, player2Wins: 0 }) };
            if (isPlayer1) {
              updatedMatchResults.player1Wins = 2; // We get 2 wins (4 points)
              updatedMatchResults.player2Wins = 0;
            } else {
              updatedMatchResults.player2Wins = 2; // We get 2 wins (4 points)
              updatedMatchResults.player1Wins = 0;
            }
            matchResults = updatedMatchResults;
            updateMultiplayerScoreDisplay();
            
            // Update game state
            gameOver = true;
            gameStarted = false;
            
            // Show win notification
            setStatusWithMark("You", "", " win! Opponent forfeited.");
            statusRow.className = "status-neutral";
            playSound("applause");
            createConfetti();
            
            // Update leaderboard
            const player1Name = roomData.player1?.name || "";
            const player2Name = roomData.player2?.name || "";
            const scores = calculateMatchScore(updatedMatchResults.player1Wins, updatedMatchResults.draws, updatedMatchResults.player2Wins);
            await updateLeaderboard(player1Name, player2Name, scores, updatedMatchResults);
            
            // Hide any other modals that might be showing
            matchResultModal.classList.remove("show");
            
            // Show forfeit result modal (opponent forfeited, so we won)
            showForfeitResultModal(player1Name, player2Name, false);
            
            // Track opponent forfeit (we won)
            trackEvent('multiplayer_forfeit', {
              'forfeited_by': 'opponent',
              'i_received_points': 4
            });
          }
          
          // Update UI
          if (roomData.player1) {
            roomPlayer1.textContent = roomData.player1.name;
            player1Name = roomData.player1.name;
            // Update display immediately
            const player1NameDisplay = document.getElementById("player1NameDisplay");
            if (player1NameDisplay) {
              player1NameDisplay.textContent = player1Name;
            }
          }
          if (roomData.player2) {
            roomPlayer2.textContent = roomData.player2.name;
            player2Name = roomData.player2.name;
            opponentName = isPlayer1 ? roomData.player2.name : roomData.player1.name;
            if (waitingRoomSection) {
              waitingRoomSection.style.display = "none";
            }
            hideRoomModal(false); // Don't switch to training - both players in, game starting
          } else {
            // Player 2 hasn't joined yet
            player2Name = "";
          }
          updateMultiplayerScoreDisplay();

          // Handle match progression FIRST (before syncing board)
          const previousMatchGameNumber = matchGameNumber;
          if (roomData.matchGameNumber !== undefined) {
            matchGameNumber = roomData.matchGameNumber;
          }
          if (roomData.matchResults) {
            matchResults = roomData.matchResults;
          }
          
          // If matchGameNumber changed to 1 (second game started), update player assignments FIRST
          const isSecondGameStart = matchGameNumber === 1 && previousMatchGameNumber === 0 && !roomData.gameOver;
          if (isSecondGameStart) {
            // Second game: player1 is O, player2 is X (and goes first)
            humanPlayer = isPlayer1 ? "O" : "X";
            computerPlayer = isPlayer1 ? "X" : "O";
            myMarkInMatch = humanPlayer;
            gameStarted = true; // Mark game as started
            gameOver = false; // Ensure game is not over
            updateRestartButtonText(); // Update button text to "Restart game"
            
            // Update currentPlayer from Firestore
            if (roomData.currentPlayer) {
              currentPlayer = roomData.currentPlayer;
            }
            
            // Show transition message (same for winner, loser, draw)
            statusElem.textContent = "Set 2 will start shortly";
            statusRow.className = "status-neutral";
            
            // After 3 seconds, update status to show whose turn it is
            setTimeout(async () => {
              // Re-check currentPlayer from Firestore in case it changed
              try {
                const roomDoc = await roomRef.get();
                const currentRoomData = roomDoc.data();
                const currentPlayerFromFirestore = currentRoomData?.currentPlayer || "X";
                
                // Update currentPlayer locally
                currentPlayer = currentPlayerFromFirestore;
                
                if (currentPlayerFromFirestore === "X") {
                  if (!isPlayer1) {
                    // Player2 is X and goes first
                    const name = getHumanDisplayName();
                    setStatusWithMark(name, "X", "  your turn");
                    statusRow.className = "status-your-turn";
                  } else {
                    // Player1 is O and waits
                    setStatusWithMark(opponentName || player2Name, "X", "  their turn");
                    statusRow.className = "status-computer-turn";
                  }
                }
              } catch (error) {
                console.error("Error updating status after second game start:", error);
                // Fallback to using currentPlayer value
                if (currentPlayer === "X") {
                  if (!isPlayer1) {
                    const name = getHumanDisplayName();
                    setStatusWithMark(name, "X", "  your turn");
                    statusRow.className = "status-your-turn";
                  } else {
                    setStatusWithMark(opponentName || player2Name, "X", "  their turn");
                    statusRow.className = "status-computer-turn";
                  }
                }
              }
            }, 3000);
          }
          
          // Sync game state (but skip status update if second game just started)
          if (roomData.board && Array.isArray(roomData.board)) {
            // Check if it's already a 2D array (legacy) or flat array (new format)
            const is2DArray = Array.isArray(roomData.board[0]);
            if (!is2DArray) {
              // Convert flat array to 2D array
              roomData.board = boardFromFirestore(roomData.board);
            }
            // Pass a flag to skip status update if second game just started
            syncBoardFromFirestore(roomData, isSecondGameStart);
          } else if (roomData.player1 && roomData.player2 && !roomData.board) {
            // Both players joined but no board yet - initialize game
            const newBoard = createEmptyBoard();
            await roomRef.update({
              board: boardToFirestore(newBoard), // Convert 2D array to flat array
              currentPlayer: "X",
              gameOver: false,
              winner: null,
              matchGameNumber: 0,
              matchResults: { player1Wins: 0, draws: 0, player2Wins: 0 },
              lastMove: firebase.firestore.FieldValue.serverTimestamp()
            });
          }
          
          // Check if match is complete (2 games played) and show modal to both players
          if (roomData.matchResults && roomData.player1 && roomData.player2) {
            const totalGames = (roomData.matchResults.player1Wins || 0) + 
                               (roomData.matchResults.player2Wins || 0) + 
                               (roomData.matchResults.draws || 0);
            
            // Single-set complete: board already synced with highlighted winning line
            // Wait 1 second so both players see the board, then show popup
            if (totalGames === 1 && roomData.gameOver && !setCompleteModal.classList.contains("show")) {
              const iWon = roomData.winner && roomData.winner === humanPlayer;
              const isDraw = !roomData.winner;
              const resultType = iWon ? "you-win" : isDraw ? "draw" : "you-lose";
              const title = iWon ? "You won this set!" : isDraw ? "Set 1 was a draw!" : "You lost this set!";
              setTimeout(() => {
                setCompleteModalTitle.textContent = title;
                setCompleteModalTitle.className = resultType;
                setCompleteModal.classList.add("show");
                setTimeout(() => setCompleteModal.classList.remove("show"), 2500);
              }, 1000);
            }
            
            // If match is complete and modal hasn't been shown yet, show it (unless there was a forfeit)
            if (totalGames >= 2 && roomData.gameOver && !matchResultModal.classList.contains("show") && !roomData.forfeit) {
              // Match is complete - show modal to this player (if not already processed)
              const scores = calculateMatchScore(
                roomData.matchResults.player1Wins || 0,
                roomData.matchResults.draws || 0,
                roomData.matchResults.player2Wins || 0
              );
              const myScore = isPlayer1 ? scores.player1Score : scores.player2Score;
              const opponentScore = isPlayer1 ? scores.player2Score : scores.player1Score;
              
              // Determine result type
              let resultType = "";
              let resultMessage = "";
              if (myScore > opponentScore) {
                resultType = "you-win";
                resultMessage = "YOU WIN";
                playSound("applause");
                createConfetti();
              } else if (myScore < opponentScore) {
                resultType = "you-lose";
                resultMessage = "YOU LOSE";
                // No losing sound when match result modal shows (user will click decline/accept)
              } else {
                resultType = "draw";
                resultMessage = "DRAW. POINTS ARE SPLIT";
                playSound("draw");
              }
              
              // Update status with result
              statusElem.textContent = resultMessage;
              statusRow.className = "status-neutral";
              
              // Leaderboard is updated by completeMatch (only the player who made the final move)
              // Do NOT update here - would cause double-counting since both clients run this listener
              
              // Show modal after 1s so both players see last move + highlighted line first
              setTimeout(() => {
                showMatchResultModal(
                  roomData.matchResults,
                  scores,
                  player1Name,
                  player2Name,
                  resultType,
                  resultMessage
                );
              }, 1000);
            }
          }
          
          // Handle rematch acceptance
          if (roomData.player1 && roomData.player2) {
            const p1Rematch = roomData.player1.rematchAccepted === true;
            const p2Rematch = roomData.player2.rematchAccepted === true;
            const p1Declined = roomData.player1.rematchDeclined === true;
            const p2Declined = roomData.player2.rematchDeclined === true;
            
            // Update rematch status in modal if it's visible
            if (matchResultModal && matchResultModal.classList.contains("show")) {
              if (p1Declined || p2Declined) {
                // Opponent declined - show result modal
                const matchResults = roomData.matchResults || { player1Wins: 0, draws: 0, player2Wins: 0 };
                const scores = calculateMatchScore(matchResults.player1Wins, matchResults.draws, matchResults.player2Wins);
                const myScore = isPlayer1 ? scores.player1Score : scores.player2Score;
                const opponentScore = isPlayer1 ? scores.player2Score : scores.player1Score;
                const iWon = myScore > opponentScore;
                const player1Name = roomData.player1?.name || "";
                const player2Name = roomData.player2?.name || "";
                
                // Hide match result modal
                matchResultModal.classList.remove("show");
                
                // Show rematch decline result modal
                showRematchDeclineResultModal(matchResults, scores, player1Name, player2Name, iWon);
              } else if (p1Rematch && p2Rematch) {
                // Both players accepted - start new match
                rematchStatus.style.display = "block";
                rematchStatusText.textContent = "Both players accepted! Starting new match...";
                setTimeout(async () => {
                  matchResultModal.classList.remove("show");
                  await startNewMatch();
                }, 1000);
              } else if ((isPlayer1 && p1Rematch) || (!isPlayer1 && p2Rematch)) {
                // This player accepted, waiting for opponent
                rematchStatus.style.display = "block";
                rematchStatusText.textContent = "Waiting for opponent to accept rematch...";
              } else if ((isPlayer1 && p2Rematch) || (!isPlayer1 && p1Rematch)) {
                // Opponent accepted, this player hasn't yet
                rematchStatus.style.display = "block";
                rematchStatusText.textContent = "Opponent wants to rematch. Click 'Rematch' to accept.";
              }
            }
          }
        },
        (error) => {
          console.error("Room listener error:", error);
        }
      );
    }

    function syncBoardFromFirestore(roomData, skipStatusUpdate = false) {
      if (!roomData.board) return;

      // Convert flat array from Firestore back to 2D array
      // Check if it's already a 2D array (legacy format) or flat array (new format)
      if (Array.isArray(roomData.board[0])) {
        // Already a 2D array (legacy - shouldn't happen with new code, but handle it)
        board = roomData.board;
      } else {
        // Flat array - convert to 2D
        board = boardFromFirestore(roomData.board);
      }
      // Update currentPlayer from Firestore (but don't overwrite if already set correctly)
      if (roomData.currentPlayer) {
        currentPlayer = roomData.currentPlayer;
      }
      gameOver = roomData.gameOver || false;

      // Update UI
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
          if (cell) {
            cell.textContent = board[r][c] || "";
            cell.classList.remove("X", "O", "last-move", "win");
            if (board[r][c]) {
              cell.classList.add(board[r][c]);
            }
          }
        }
      }

      // Update player assignments based on match game
      // IMPORTANT: This must happen BEFORE setStatusForTurn() is called
      if (matchGameNumber === 0) {
        // First game: player1 is X, player2 is O
        humanPlayer = isPlayer1 ? "X" : "O";
        computerPlayer = isPlayer1 ? "O" : "X";
        myMarkInMatch = isPlayer1 ? "X" : "O";
      } else {
        // Second game: player1 is O, player2 is X
        humanPlayer = isPlayer1 ? "O" : "X";
        computerPlayer = isPlayer1 ? "X" : "O";
        myMarkInMatch = isPlayer1 ? "O" : "X";
      }
      
      // Ensure currentPlayer matches what's in Firestore
      currentPlayer = roomData.currentPlayer || currentPlayer;

      // Update cells UI
      const cells = document.querySelectorAll(".cell");
      cells.forEach(cell => {
        const r = parseInt(cell.dataset.row, 10);
        const c = parseInt(cell.dataset.col, 10);
        cell.textContent = board[r][c] || "";
        cell.classList.remove("X", "O", "last-move", "win");
        if (board[r][c]) {
          cell.classList.add(board[r][c]);
        }
      });

      // Update status
      if (skipStatusUpdate) {
        // Status update is handled by the caller (room listener for second game start)
        return;
      }
      
      if (gameOver) {
        if (roomData.winner) {
          const iWon = roomData.winner === humanPlayer;
          // Highlight winning line for both winner and loser (training-mode style)
          outer: for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
              if (board[r][c] === roomData.winner) {
                const winLine = getWinningLine(board, r, c, roomData.winner);
                if (winLine) {
                  highlightWinningLine(winLine);
                  break outer;
                }
              }
            }
          }
          if (iWon) {
            const winnerName = currentPlayerName || "You";
            setStatusWithMark(winnerName, roomData.winner, " wins!");
          } else {
            // Loser: show explicit "You lost!" message (same prominence as winner)
            statusElem.textContent = "You lost!";
            // No losing sound (avoids extra sounds when set-complete modal appears)
          }
        } else {
          statusElem.textContent = "It's a draw!";
        }
        statusRow.className = "status-neutral";
      } else {
        setStatusForTurn();
      }
      
      // Update score display
      if (roomData.matchResults) {
        matchResults = roomData.matchResults;
        updateMultiplayerScoreDisplay();
      }
    }

    async function leaveRoom() {
      // Prevent leaving if match is not finished - must forfeit first
      if (gameMode === "multiplayer" && currentRoomId && firebaseInitialized && db) {
        try {
          const roomRef = db.collection("gameRooms").doc(currentRoomId);
          const roomDoc = await roomRef.get();
          
          if (roomDoc.exists) {
            const roomData = roomDoc.data();
            const totalGames = (roomData.matchResults?.player1Wins || 0) + (roomData.matchResults?.player2Wins || 0) + (roomData.matchResults?.draws || 0);
            const matchFinished = roomData.gameOver && totalGames >= 2;
            
            // If match is not finished and there's an active game or opponent is present, prevent leaving
            if (!matchFinished && roomData.player1 && roomData.player2 && (gameStarted || totalGames > 0)) {
              // Show forfeit modal - don't allow leaving without forfeiting
              showForfeitModal("leave-room");
              return; // Don't leave yet - wait for user confirmation
            }
          }
        } catch (error) {
          console.error("Error checking room state before leaving:", error);
        }
      }

      if (roomListener) {
        roomListener();
        roomListener = null;
      }

      if (currentRoomId && firebaseInitialized && db) {
        try {
          const roomRef = db.collection("gameRooms").doc(currentRoomId);
          const roomDoc = await roomRef.get();
          
          if (roomDoc.exists) {
            const roomData = roomDoc.data();
            const p1Declined = roomData.player1?.rematchDeclined === true;
            const p2Declined = roomData.player2?.rematchDeclined === true;
            const totalGames = (roomData.matchResults?.player1Wins || 0) + (roomData.matchResults?.player2Wins || 0) + (roomData.matchResults?.draws || 0);
            const matchFinished = roomData.gameOver && totalGames >= 2;

            // When both declined rematch, or match is finished and we're leaving - DELETE the room
            // (never put finished-match rooms back in Quick Match pool)
            if (p1Declined && p2Declined) {
              await roomRef.delete();
            } else if (matchFinished) {
              await roomRef.delete();
            } else if (isPlayer1 && !roomData.player2) {
              await roomRef.delete();
            } else if (isPlayer1 && roomData.player2) {
              // Player1 leaving first (mid-match) - clear ourselves
              await roomRef.update({ player1: null });
            } else if (!isPlayer1) {
              if (!roomData.player1) {
                await roomRef.delete();
              } else {
                const wasQuickMatch = roomData.matchType === "quick";
                await roomRef.update({
                  player2: null,
                  status: "waiting",
                  quickMatchKey: wasQuickMatch ? "waiting" : null
                });
              }
            }
          }
        } catch (error) {
          console.error("Error leaving room:", error);
        }
      }

      currentRoomId = null;
      isPlayer1 = false;
      opponentName = "";
      player1Name = "";
      player2Name = "";
      matchGameNumber = 0;
      matchResults = { player1Wins: 0, draws: 0, player2Wins: 0 };
      currentMatchScore = { player1: 0, player2: 0 };
      // Stop loading animation
      if (loadingDotsInterval) {
        clearInterval(loadingDotsInterval);
        loadingDotsInterval = null;
      }
      updateMultiplayerScoreDisplay();
    }

    // Scoring system: Win = 2pts, Draw = 1pt each, Loss = 0pts
    function calculateMatchScore(player1Wins, draws, player2Wins) {
      // Win=2, Draw=1, Loss=0
      const player1Score = (player1Wins * 2) + (draws * 1);
      const player2Score = (player2Wins * 2) + (draws * 1);
      return { player1Score, player2Score };
    }

    async function handleMultiplayerGameEnd(winner, result) {
      if (!currentRoomId || !firebaseInitialized || !db) return;

      try {
        const roomRef = db.collection("gameRooms").doc(currentRoomId);
        const roomDoc = await roomRef.get();
        if (!roomDoc.exists) return;

        const roomData = roomDoc.data();
        let updatedMatchResults = { ...matchResults };

        // Update match results based on game outcome
        if (result === "draw") {
          updatedMatchResults.draws++;
          playSound("draw");
          statusElem.textContent = "It's a draw!";
        } else if (winner) {
          const iWon = (isPlayer1 && winner === "X" && matchGameNumber === 0) ||
                      (isPlayer1 && winner === "O" && matchGameNumber === 1) ||
                      (!isPlayer1 && winner === "O" && matchGameNumber === 0) ||
                      (!isPlayer1 && winner === "X" && matchGameNumber === 1);
          
          if (iWon) {
            if (isPlayer1) {
              updatedMatchResults.player1Wins++;
            } else {
              updatedMatchResults.player2Wins++;
            }
            playSound("applause");
            createConfetti();
            const winnerName = getHumanDisplayName();
            setStatusWithMark(winnerName, winner, " wins!");
          } else {
            if (isPlayer1) {
              updatedMatchResults.player2Wins++;
            } else {
              updatedMatchResults.player1Wins++;
            }
            playSound("aw");
            setStatusWithMark(opponentName, winner, " wins!");
          }
        }

        matchResults = updatedMatchResults;
        updateMultiplayerScoreDisplay(); // Update score display

        // Update Firestore (include board so opponent sees last move + winning line)
        await roomRef.update({
          board: boardToFirestore(board),
          gameOver: true,
          winner: winner,
          matchResults: updatedMatchResults,
          lastMove: firebase.firestore.FieldValue.serverTimestamp()
        });

        // Check if match is complete (2 games played)
        const totalGames = updatedMatchResults.player1Wins + updatedMatchResults.player2Wins + updatedMatchResults.draws;
        
        if (totalGames >= 2) {
          // Match complete - calculate final scores and update leaderboard
          await completeMatch(updatedMatchResults, roomData);
        } else {
          // Set 1 complete - board already has highlighted winning line from makeMove
          // Wait 1 second so both players see the board, then show popup, then start set 2
          const iWon = (isPlayer1 && winner === "X" && matchGameNumber === 0) ||
                      (isPlayer1 && winner === "O" && matchGameNumber === 1) ||
                      (!isPlayer1 && winner === "O" && matchGameNumber === 0) ||
                      (!isPlayer1 && winner === "X" && matchGameNumber === 1);
          const isDraw = !winner;
          const resultType = iWon ? "you-win" : isDraw ? "draw" : "you-lose";
          const title = iWon ? "You won this set!" : isDraw ? "Set 1 was a draw!" : "You lost this set!";
          setTimeout(() => {
            setCompleteModalTitle.textContent = title;
            setCompleteModalTitle.className = resultType;
            setCompleteModal.classList.add("show");
            setTimeout(() => setCompleteModal.classList.remove("show"), 2500);
          }, 1000);
          // Start next set 1s (board) + 2.5s (popup) + 0.5s buffer = 4 seconds from game end
          setTimeout(async () => {
            await startNextMatchGame();
          }, 4000);
        }

        statusRow.className = "status-neutral";
        resetGameState();
      } catch (error) {
        console.error("Error handling multiplayer game end:", error);
      }
    }

    async function startNextMatchGame() {
      if (!currentRoomId || !firebaseInitialized || !db) return;

      matchGameNumber = 1; // Second game
      gameOver = false;
      board = createEmptyBoard();
      resetGameState();

      // Swap marks: player1 becomes O, player2 becomes X (and goes first)
      const roomRef = db.collection("gameRooms").doc(currentRoomId);
      const roomDoc = await roomRef.get();
      if (!roomDoc.exists) return;
      
      const roomData = roomDoc.data();
      
      // Show transition message (same for winner, loser, draw)
      statusElem.textContent = "Set 2 will start shortly";
      statusRow.className = "status-neutral";
      
      await roomRef.update({
        board: boardToFirestore(board), // Convert 2D array to flat array
        currentPlayer: "X", // Player2 (X) goes first in second game
        gameOver: false,
        winner: null,
        matchGameNumber: 1,
        // Update player marks in Firestore
        "player1.mark": "O",
        "player2.mark": "X",
        lastMove: firebase.firestore.FieldValue.serverTimestamp()
      });

      // Update UI
      const cells = document.querySelectorAll(".cell");
      cells.forEach(cell => {
        cell.textContent = "";
        cell.classList.remove("X", "O", "last-move", "win");
      });

      // Update player assignments locally
      humanPlayer = isPlayer1 ? "O" : "X";
      computerPlayer = isPlayer1 ? "X" : "O";
      myMarkInMatch = humanPlayer;
      currentPlayer = "X"; // Player2 (X) goes first
      gameStarted = true; // Game is ready to play
      gameOver = false; // Ensure game is not over
      
      // After 3 seconds, update status to show whose turn it is
      setTimeout(() => {
        if (!isPlayer1) {
          // Player2 is X and goes first
          const name = getHumanDisplayName();
          setStatusWithMark(name, "X", "  your turn");
          statusRow.className = "status-your-turn";
        } else {
          // Player1 is O and waits
          setStatusWithMark(opponentName || player2Name, "X", "  their turn");
          statusRow.className = "status-computer-turn";
        }
      }, 3000);

      updateMultiplayerScoreDisplay();
      updateRestartButtonText(); // Update button text to "Restart game"
    }

    async function completeMatch(matchResults, roomData) {
      if (!firebaseInitialized || !db || !currentRoomId) return;
      
      // Prevent duplicate processing
      if (matchCompletionProcessed) return;
      matchCompletionProcessed = true;

      const scores = calculateMatchScore(matchResults.player1Wins, matchResults.draws, matchResults.player2Wins);
      const player1Name = roomData.player1?.name || "";
      const player2Name = roomData.player2?.name || "";

      // Update leaderboard (only once)
      await updateLeaderboard(player1Name, player2Name, scores, matchResults);

      // If there was a forfeit, don't show match result modal (forfeit modal already shown)
      if (roomData.forfeit === true) {
        return;
      }

      // Determine match outcome
      const myScore = isPlayer1 ? scores.player1Score : scores.player2Score;
      const opponentScore = isPlayer1 ? scores.player2Score : scores.player1Score;
      
      // Determine result type
      let resultType = "";
      let resultMessage = "";
      if (myScore > opponentScore) {
        resultType = "you-win";
        resultMessage = "YOU WIN";
        playSound("applause");
        createConfetti();
        // Track multiplayer match win
        trackEvent('multiplayer_match_complete', {
          'result': 'win',
          'my_score': myScore,
          'opponent_score': opponentScore,
          'player1_wins': matchResults.player1Wins,
          'player2_wins': matchResults.player2Wins,
          'draws': matchResults.draws
        });
      } else if (myScore < opponentScore) {
        resultType = "you-lose";
        resultMessage = "YOU LOSE";
        // No losing sound when match result modal shows (user will click decline/accept)
        // Track multiplayer match loss
        trackEvent('multiplayer_match_complete', {
          'result': 'loss',
          'my_score': myScore,
          'opponent_score': opponentScore,
          'player1_wins': matchResults.player1Wins,
          'player2_wins': matchResults.player2Wins,
          'draws': matchResults.draws
        });
      } else {
        resultType = "draw";
        resultMessage = "DRAW. POINTS ARE SPLIT";
        playSound("draw");
        // Track multiplayer match draw
        trackEvent('multiplayer_match_complete', {
          'result': 'draw',
          'my_score': myScore,
          'opponent_score': opponentScore,
          'player1_wins': matchResults.player1Wins,
          'player2_wins': matchResults.player2Wins,
          'draws': matchResults.draws
        });
      }
      
      // Update status with result
      statusElem.textContent = resultMessage;
      statusRow.className = "status-neutral";

      // Show match result modal after 1s so both players see last move + highlighted line first
      setTimeout(() => {
        showMatchResultModal(matchResults, scores, player1Name, player2Name, resultType, resultMessage);
      }, 1000);
    }
    
    function showMatchResultModal(matchResults, scores, player1Name, player2Name, resultType, resultMessage) {
      // Update modal content
      matchResultTitle.textContent = resultMessage;
      matchResultTitle.className = resultType;
      
      // Build game details
      let game1Result = "";
      if (matchResults.player1Wins > 0) {
        game1Result = `${player1Name} (X) won`;
      } else if (matchResults.player2Wins > 0) {
        game1Result = `${player2Name} (O) won`;
      } else {
        game1Result = "Draw";
      }
      
      let game2Result = "";
      // Check if there were 2 games (could be draws)
      const totalGames = matchResults.player1Wins + matchResults.player2Wins + matchResults.draws;
      if (totalGames >= 2) {
        // Second game: player2 is X, player1 is O
        if (matchResults.player2Wins > 1 || (matchResults.player2Wins === 1 && matchResults.player1Wins === 0)) {
          game2Result = `${player2Name} (X) won`;
        } else if (matchResults.player1Wins > 1 || (matchResults.player1Wins === 1 && matchResults.player2Wins === 0)) {
          game2Result = `${player1Name} (O) won`;
        } else {
          game2Result = "Draw";
        }
      }
      
      matchResultDetails.innerHTML = `
        <div style="margin-bottom: 8px;"><strong>Set 1:</strong> ${game1Result}</div>
        ${totalGames >= 2 ? `<div><strong>Set 2:</strong> ${game2Result}</div>` : ''}
      `;
      
      matchResultPlayer1Name.textContent = player1Name;
      matchResultPlayer1Score.textContent = `${scores.player1Score} pts`;
      matchResultPlayer2Name.textContent = player2Name;
      matchResultPlayer2Score.textContent = `${scores.player2Score} pts`;
      
      // Reset rematch status
      rematchStatus.style.display = "none";
      matchResultRematchBtn.disabled = false;
      matchResultDeclineBtn.disabled = false;
      
      // Show modal
      matchResultModal.classList.add("show");
      
      // Initialize rematch acceptance in Firestore
      const roomRef = db.collection("gameRooms").doc(currentRoomId);
      const playerKey = isPlayer1 ? "player1" : "player2";
      roomRef.update({
        [`${playerKey}.rematchAccepted`]: false,
        [`${playerKey}.rematchDeclined`]: false
      });
    }
    
    async function handleRematchAccept() {
      if (!currentRoomId || !firebaseInitialized || !db) return;
      
      const roomRef = db.collection("gameRooms").doc(currentRoomId);
      const playerKey = isPlayer1 ? "player1" : "player2";
      
      // Mark this player as accepting rematch
      await roomRef.update({
        [`${playerKey}.rematchAccepted`]: true,
        [`${playerKey}.rematchDeclined`]: false
      });
      
      // Disable buttons
      matchResultRematchBtn.disabled = true;
      matchResultDeclineBtn.disabled = true;
      
      // Update status
      rematchStatus.style.display = "block";
      rematchStatusText.textContent = "Waiting for opponent to accept rematch...";
      
      // Check if both players accepted (will be handled by room listener)
    }
    
    function showRematchDeclineResultModal(matchResults, scores, player1Name, player2Name, iWon) {
      // Determine result message
      const resultType = iWon ? "you-win" : "you-lose";
      const resultMessage = iWon ? "YOU WIN" : "YOU LOSE";
      
      // Update modal content
      rematchDeclineResultTitle.textContent = resultMessage;
      rematchDeclineResultTitle.className = resultType;
      
      // Build details
      const myScore = isPlayer1 ? scores.player1Score : scores.player2Score;
      const opponentScore = isPlayer1 ? scores.player2Score : scores.player1Score;
      const opponentName = isPlayer1 ? player2Name : player1Name;
      
      if (iWon) {
        rematchDeclineResultDetails.textContent = `Opponent declined rematch. You win the match!`;
        playSound("applause");
        createConfetti();
      } else {
        rematchDeclineResultDetails.textContent = `You declined rematch. ${opponentName} wins the match.`;
      }
      
      // Update scores
      rematchDeclinePlayer1Name.textContent = player1Name;
      rematchDeclinePlayer1Score.textContent = `${scores.player1Score} pts`;
      rematchDeclinePlayer2Name.textContent = player2Name;
      rematchDeclinePlayer2Score.textContent = `${scores.player2Score} pts`;
      
      // Show modal
      rematchDeclineResultModal.classList.add("show");
    }
    
    function showForfeitResultModal(player1Name, player2Name, iAmForfeiter) {
      // Determine result message
      const resultType = iAmForfeiter ? "you-lose" : "you-win";
      const resultMessage = iAmForfeiter ? "YOU LOSE" : "YOU WIN";
      
      // Update modal content
      rematchDeclineResultTitle.textContent = resultMessage;
      rematchDeclineResultTitle.className = resultType;
      
      // Build details and scores
      if (iAmForfeiter) {
        // Forfeiter sees: they lost, 0 points, opponent gets 4 points
        rematchDeclineResultDetails.textContent = `You forfeited the match.`;
        if (isPlayer1) {
          rematchDeclinePlayer1Name.textContent = player1Name;
          rematchDeclinePlayer1Score.textContent = `0 pts`;
          rematchDeclinePlayer2Name.textContent = player2Name;
          rematchDeclinePlayer2Score.textContent = `4 pts`;
        } else {
          rematchDeclinePlayer1Name.textContent = player1Name;
          rematchDeclinePlayer1Score.textContent = `4 pts`;
          rematchDeclinePlayer2Name.textContent = player2Name;
          rematchDeclinePlayer2Score.textContent = `0 pts`;
        }
      } else {
        // Winner sees: they won, 4 points, opponent got 0 points
        rematchDeclineResultDetails.textContent = `Opponent forfeited. You win the match!`;
        playSound("applause");
        createConfetti();
        if (isPlayer1) {
          rematchDeclinePlayer1Name.textContent = player1Name;
          rematchDeclinePlayer1Score.textContent = `4 pts`;
          rematchDeclinePlayer2Name.textContent = player2Name;
          rematchDeclinePlayer2Score.textContent = `0 pts`;
        } else {
          rematchDeclinePlayer1Name.textContent = player1Name;
          rematchDeclinePlayer1Score.textContent = `0 pts`;
          rematchDeclinePlayer2Name.textContent = player2Name;
          rematchDeclinePlayer2Score.textContent = `4 pts`;
        }
      }
      
      // Show modal
      rematchDeclineResultModal.classList.add("show");
    }
    
    async function handleRematchDecline() {
      if (!currentRoomId || !firebaseInitialized || !db) return;
      
      const roomRef = db.collection("gameRooms").doc(currentRoomId);
      const roomDoc = await roomRef.get();
      if (!roomDoc.exists) return;
      
      const roomData = roomDoc.data();
      const playerKey = isPlayer1 ? "player1" : "player2";
      
      // Get match results and scores
      const matchResults = roomData.matchResults || { player1Wins: 0, draws: 0, player2Wins: 0 };
      const scores = calculateMatchScore(matchResults.player1Wins, matchResults.draws, matchResults.player2Wins);
      const myScore = isPlayer1 ? scores.player1Score : scores.player2Score;
      const opponentScore = isPlayer1 ? scores.player2Score : scores.player1Score;
      const iWon = myScore > opponentScore;
      const player1Name = roomData.player1?.name || "";
      const player2Name = roomData.player2?.name || "";
      
      // Mark this player as declining rematch
      await roomRef.update({
        [`${playerKey}.rematchAccepted`]: false,
        [`${playerKey}.rematchDeclined`]: true
      });
      
      // Hide match result modal
      matchResultModal.classList.remove("show");
      
      // Show rematch decline result modal
      showRematchDeclineResultModal(matchResults, scores, player1Name, player2Name, iWon);
    }
    

    async function startNewMatch() {
      if (!currentRoomId || !firebaseInitialized || !db) return;

      matchGameNumber = 0;
      matchResults = { player1Wins: 0, draws: 0, player2Wins: 0 };
      gameOver = false;
      board = createEmptyBoard();
      resetGameState();
      matchCompletionProcessed = false; // Reset flag for new match

      const roomRef = db.collection("gameRooms").doc(currentRoomId);
      await roomRef.update({
        board: boardToFirestore(board), // Convert 2D array to flat array
        currentPlayer: "X",
        gameOver: false,
        winner: null,
        matchGameNumber: 0,
        matchResults: { player1Wins: 0, draws: 0, player2Wins: 0 },
        // Reset rematch flags
        "player1.rematchAccepted": false,
        "player1.rematchDeclined": false,
        "player2.rematchAccepted": false,
        "player2.rematchDeclined": false,
        // Reset player marks for first game
        "player1.mark": "X",
        "player2.mark": "O",
        lastMove: firebase.firestore.FieldValue.serverTimestamp()
      });

      // Update UI
      const cells = document.querySelectorAll(".cell");
      cells.forEach(cell => {
        cell.textContent = "";
        cell.classList.remove("X", "O", "last-move", "win");
      });

      // Reset player assignments
      humanPlayer = isPlayer1 ? "X" : "O";
      computerPlayer = isPlayer1 ? "O" : "X";
      myMarkInMatch = humanPlayer;
      currentPlayer = "X";

      updateMultiplayerScoreDisplay();
      setStatusForTurn();
    }

    async function updateLeaderboard(player1Name, player2Name, scores, matchResults) {
      if (!firebaseInitialized || !db) return;
      const p1Name = (player1Name || "").trim();
      const p2Name = (player2Name || "").trim();
      if (!p1Name || !p2Name) {
        console.warn("Leaderboard: Skipping update - player names empty", { player1Name, player2Name });
        return;
      }

      try {
        // Update player1 stats
        const p1Ref = db.collection("multiplayerLeaderboard").doc(p1Name.toLowerCase());
        const p1Doc = await p1Ref.get();
        const p1Data = p1Doc.exists ? p1Doc.data() : { name: p1Name, matchesPlayed: 0, wins: 0, draws: 0, losses: 0, totalPoints: 0 };
        
        p1Data.matchesPlayed = (p1Data.matchesPlayed || 0) + 1;
        p1Data.totalPoints = (p1Data.totalPoints || 0) + scores.player1Score;
        if (scores.player1Score > scores.player2Score) {
          p1Data.wins = (p1Data.wins || 0) + 1;
        } else if (scores.player1Score < scores.player2Score) {
          p1Data.losses = (p1Data.losses || 0) + 1;
        } else {
          p1Data.draws = (p1Data.draws || 0) + 1;
        }
        p1Data.lastUpdated = firebase.firestore.FieldValue.serverTimestamp();
        await p1Ref.set(p1Data, { merge: true });

        // Update player2 stats
        const p2Ref = db.collection("multiplayerLeaderboard").doc(p2Name.toLowerCase());
        const p2Doc = await p2Ref.get();
        const p2Data = p2Doc.exists ? p2Doc.data() : { name: p2Name, matchesPlayed: 0, wins: 0, draws: 0, losses: 0, totalPoints: 0 };
        
        p2Data.matchesPlayed = (p2Data.matchesPlayed || 0) + 1;
        p2Data.totalPoints = (p2Data.totalPoints || 0) + scores.player2Score;
        if (scores.player2Score > scores.player1Score) {
          p2Data.wins = (p2Data.wins || 0) + 1;
        } else if (scores.player2Score < scores.player1Score) {
          p2Data.losses = (p2Data.losses || 0) + 1;
        } else {
          p2Data.draws = (p2Data.draws || 0) + 1;
        }
        p2Data.lastUpdated = firebase.firestore.FieldValue.serverTimestamp();
        await p2Ref.set(p2Data, { merge: true });
      } catch (error) {
        console.error("Error updating leaderboard:", error);
      }
    }
    
    // Function to clear multiplayer leaderboard (for testing/admin use)
    // Call from browser console: clearMultiplayerLeaderboard()
    window.clearMultiplayerLeaderboard = async function() {
      if (!firebaseInitialized || !db) {
        console.error("Firebase not initialized");
        return;
      }
      
      try {
        const snapshot = await db.collection("multiplayerLeaderboard").get();
        const batch = db.batch();
        let count = 0;
        
        snapshot.docs.forEach(doc => {
          batch.delete(doc.ref);
          count++;
        });
        
        await batch.commit();
        console.log(` Cleared ${count} entries from multiplayer leaderboard`);
        alert(`Cleared ${count} entries from multiplayer leaderboard`);
      } catch (error) {
        console.error("Error clearing leaderboard:", error);
        alert("Error clearing leaderboard: " + error.message);
      }
    };
    
    // Make function available globally for console access
    // Initialize sound
    const savedSound = localStorage.getItem("tictac9x9_sound");
    if (savedSound !== null) {
      soundEnabled = savedSound === "true";
    }
    soundToggleBtn.classList.toggle("muted", !soundEnabled);
    soundToggleBtn.addEventListener("click", toggleSound);

    // Mode toggle switches - initialize both with same content
    function initializeToggle(toggleElement) {
      if (toggleElement && !toggleElement.querySelector(".mode-option")) {
        toggleElement.innerHTML = `
          <div class="mode-option" data-mode="training"></div>
          <div class="mode-slider"></div>
          <div class="mode-option" data-mode="multiplayer"></div>
        `;
      }
    }

    if (modeToggleSwitch) {
      initializeToggle(modeToggleSwitch);
      // Temporarily enabled for testing - both toggles should work
      modeToggleSwitch.addEventListener("click", toggleGameMode);
    }
    if (modeToggleSwitchMultiplayer) {
      initializeToggle(modeToggleSwitchMultiplayer);
      // Event listener will be attached in init() after DOM is ready
      // Temporarily enabled for testing
    }
    
    // Room modal
    roomModalClose.addEventListener("click", hideRoomModal);
    if (roomModalLeaderboardBtn) {
      roomModalLeaderboardBtn.addEventListener("click", () => {
        showLeaderboardModal();
      });
    }
    roomModal.addEventListener("click", (e) => {
      if (e.target === roomModal) hideRoomModal();
    });
    roomModalContent.addEventListener("click", (e) => {
      if (e.target && e.target.id === "quickMatchBtn") {
        e.preventDefault();
        quickMatch();
      }
    });
    copyRoomIdBtn.addEventListener("click", () => {
      navigator.clipboard.writeText(currentRoomId).then(() => {
        copyRoomIdBtn.textContent = " Copied!";
        setTimeout(() => { copyRoomIdBtn.textContent = " Copy Room ID"; }, 2000);
      });
    });
    const joinWaitingRoomBtn = document.getElementById("joinWaitingRoomBtn");
    if (joinWaitingRoomBtn) {
      joinWaitingRoomBtn.addEventListener("click", onJoinWaitingRoomClick);
    }

    joinRoomConfirmBtn.addEventListener("click", () => {
      const roomId = joinRoomIdInput.value.trim();
      if (roomId) {
        joinRoom(roomId);
      } else {
        alert("Please enter a room ID");
      }
    });
    joinRoomIdInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const roomId = joinRoomIdInput.value.trim();
        if (roomId) {
          joinRoom(roomId);
        } else {
          alert("Please enter a room ID");
        }
      }
    });


    // Stats modal
    if (statsBtn) {
      statsBtn.addEventListener("click", showStats);
    }
    if (closeStatsBtn) {
      closeStatsBtn.addEventListener("click", hideStats);
    }
    if (statsModal) {
      statsModal.addEventListener("click", (e) => {
        if (e.target === statsModal) {
          hideStats();
        }
      });
    }

    // Leaderboard modal
    if (leaderboardBtn) {
      leaderboardBtn.addEventListener("click", showLeaderboardModal);
    }
    const leaderboardModalEl = document.getElementById("leaderboardModal");
    const leaderboardModalClose = document.getElementById("leaderboardModalClose");
    if (leaderboardModalClose) {
      leaderboardModalClose.addEventListener("click", hideLeaderboardModal);
    }
    if (leaderboardModalEl) {
      leaderboardModalEl.addEventListener("click", (e) => {
        if (e.target === leaderboardModalEl) {
          hideLeaderboardModal();
        }
      });
    }

    // Achievements modal
    trophyBtn.addEventListener("click", showTrophyCabinet);
    closeTrophyBtn.addEventListener("click", hideTrophyCabinet);
    trophyModal.addEventListener("click", (e) => {
      if (e.target === trophyModal) {
        hideTrophyCabinet();
      }
    });

    shareAchievementsBtn.addEventListener("click", () => {
      const unlocked = Object.values(achievements).filter(a => a.unlocked).length;
      const text = `I've unlocked ${unlocked}/8 achievements in 5-in-a-Row! Can you beat that?`;
      openShare(text);
    });

    shareGameResultBtn.addEventListener("click", () => {
      openShare(lastGameResultText);
    });

    shareModalClose.addEventListener("click", hideShareModal);
    shareModal.addEventListener("click", (e) => {
      if (e.target === shareModal) hideShareModal();
    });

    document.addEventListener("keydown", (e) => {
      
      // Normal restart shortcuts
      if (e.key === "r" || e.key === "R" || e.key === " ") {
        const active = document.activeElement;
        if (active && (active.tagName === "INPUT" || active.tagName === "TEXTAREA")) return;
        e.preventDefault();
        restartGame();
      }
    });

    restartBtn.addEventListener("click", restartGame);

    applyHumanNameBtn.addEventListener("click", async () => {
      const newName = humanNameInput.value.trim();
      if (!newName) {
        alert("Please enter your name before clicking Set.");
        return;
      }
      
      if (newName.length < 3) {
        alert("Name must be at least 3 characters long.");
        humanNameInput.focus();
        return;
      }

      const nameChanged = newName.toLowerCase() !== currentPlayerName.toLowerCase();

      // If name changed and streak > 0, warn user that counter will reset
      if (nameChanged && currentStreak > 0) {
        const confirmed = confirm(
          `Changing your name will reset your current streak of ${currentStreak}. Do you want to continue?`
        );
        if (!confirmed) {
          return;
        }
      }

      // If Firebase is not configured, allow name without registration
      if (!firebaseInitialized || !db) {
        await completeNameSetup(newName);
        return;
      }

      // Check if name is registered
      const isRegistered = await checkNameRegistered(newName);
      
      if (isRegistered) {
        // Name is registered - show login modal
        showRegisterModal(newName, true);
      } else {
        // Name is not registered - show registration modal
        showRegisterModal(newName, false);
      }
    });

    async function completeNameSetup(name) {
      if (!name || !name.trim()) return;
      const nameChanged = name.toLowerCase() !== currentPlayerName.toLowerCase();

      if (nameChanged) {
        currentStreak = 0;
        if (gameMode === "training") {
          updateStreakDisplays();
        }
      }
      
      currentPlayerName = name;
      
      // Save name to localStorage for persistence
      try {
        localStorage.setItem("tictac9x9_currentPlayerName", name);
      } catch (e) {
        // ignore errors
      }
      
      // Ensure game state is initialized before showing status (fixes undefined in training)
      if (gameMode === "training" && (humanPlayer === undefined || currentPlayer === undefined)) {
        startNewRound();
      } else {
        setStatusForTurn();
      }
      if (gameMode === "training") startWaitingRoomCheck();
      
      // If it's computer's turn and game has started, trigger computer move
      // (Don't trigger if game hasn't started yet - wait for player confirmation)
      if (gameStarted && currentPlayer === computerPlayer && !gameOver) {
        computerThinking = true;
        if (computerMoveTimeoutId !== null) {
          clearTimeout(computerMoveTimeoutId);
        }
        computerMoveTimeoutId = setTimeout(computerMove, 1000);
      }
    }

    registerConfirmBtn.addEventListener("click", async () => {
      const password = registerPassword.value.trim();
      if (!password) {
        alert("Please enter a password.");
        return;
      }

      if (isLoginMode) {
        // Login: verify password
        const nameToUse = pendingName; // Save name before hiding modal
        const isValid = await verifyPassword(nameToUse, password);
        if (isValid) {
          // Copy name to main input field
          humanNameInput.value = nameToUse;
          
          hideRegisterModal();
          await completeNameSetup(nameToUse);
          // Don't auto-start game - user must click "Start Game" button
        } else {
          alert("Incorrect password. Please try again.");
          registerPassword.value = "";
          registerPassword.focus();
        }
      } else {
        // Register: create new registration
        const nameToUse = pendingName; // Save name before hiding modal
        if (password.length < 4) {
          alert("Password must be at least 4 characters long.");
          return;
        }
        const success = await registerName(nameToUse, password);
        if (success) {
          // Copy name to main input field
          humanNameInput.value = nameToUse;
          
          hideRegisterModal();
          await completeNameSetup(nameToUse);
          if (!gameOver && board.every(row => row.every(cell => cell === ""))) {
            startNewRound();
          }
        } else {
          alert("Registration failed. The name might already be registered.");
          registerPassword.value = "";
          registerPassword.focus();
        }
      }
    });

    registerCancelBtn.addEventListener("click", hideRegisterModal);
    registerSkipBtn.addEventListener("click", async () => {
      const nameToUse = pendingName; // Save name before hiding modal
      if (!nameToUse || !nameToUse.trim()) {
        hideRegisterModal();
        return;
      }
      // Copy name to main input field
      humanNameInput.value = nameToUse;
      
      hideRegisterModal();
      await completeNameSetup(nameToUse);
      // Don't auto-start game - user must click "Start Game" button
    });
    registerModal.addEventListener("click", (e) => {
      if (e.target === registerModal) hideRegisterModal();
    });

    registerPassword.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        registerConfirmBtn.click();
      }
    });

    // Name Selection Modal handlers - real-time checking with debounce
    nameSelectionInput.addEventListener("input", () => {
      const name = nameSelectionInput.value.trim();
      
      // Show button immediately if name is valid (3+ chars)
      if (name.length >= 3) {
        nameSelectionStartBtn.style.display = "block";
        nameSelectionStartBtn.textContent = "Play Unregistered";
        nameSelectionPasswordSection.style.display = "none";
        nameSelectionLoginBtn.style.display = "none";
        nameSelectionWarning.style.display = "none";
        nameSelectionRegisterBtn.style.display = "none";
      } else {
        // Hide buttons if name is too short
        nameSelectionStartBtn.style.display = "none";
        nameSelectionRegisterBtn.style.display = "none";
        nameSelectionLoginBtn.style.display = "none";
      }
      
      // Clear previous timeout
      if (nameCheckTimeout) {
        clearTimeout(nameCheckTimeout);
      }
      
      // Debounce the Firebase check - wait 300ms after user stops typing
      nameCheckTimeout = setTimeout(() => {
        checkNameAndUpdateModal();
      }, 300);
    });

    nameSelectionStartBtn.addEventListener("click", async () => {
      const name = nameSelectionInput.value.trim();
      if (name.length < 3) {
        alert("Name must be at least 3 characters long.");
        nameSelectionInput.focus();
        return;
      }
      
      // Copy name to main input field
      humanNameInput.value = name;
      
      hideNameSelectionModal();
      await completeNameSetup(name);
      // Don't call startNewRound() here - completeNameSetup already calls it when
      // humanPlayer/currentPlayer are undefined, and calling it again would flip
      // nextHumanPlayer and make the computer start first.
    });

    nameSelectionRegisterBtn.addEventListener("click", async () => {
      const name = nameSelectionInput.value.trim();
      if (name.length < 3) {
        alert("Name must be at least 3 characters long.");
        nameSelectionInput.focus();
        return;
      }
      
      // Copy name to main input field
      humanNameInput.value = name;
      
      // Show registration modal
      pendingName = name;
      showRegisterModal(name, false);
      hideNameSelectionModal();
    });

    nameSelectionLoginBtn.addEventListener("click", async () => {
      const name = nameSelectionInput.value.trim();
      const password = nameSelectionPassword.value.trim();
      
      if (name.length < 3) {
        alert("Name must be at least 3 characters long.");
        nameSelectionInput.focus();
        return;
      }
      
      if (!password) {
        alert("Please enter your password.");
        nameSelectionPassword.focus();
        return;
      }
      
      // Verify password
      const isValid = await verifyPassword(name, password);
      if (isValid) {
        // Copy name to main input field
        humanNameInput.value = name;
        
        hideNameSelectionModal();
        await completeNameSetup(name);
        startNewRound();
      } else {
        alert("Incorrect password. Please try again.");
        nameSelectionPassword.value = "";
        nameSelectionPassword.focus();
      }
    });

    nameSelectionInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const name = nameSelectionInput.value.trim();
        if (name.length < 3) {
          return; // Don't proceed if name is too short
        }
        
        // If buttons are visible, trigger the appropriate one
        if (nameSelectionPasswordSection.style.display !== "none" && nameSelectionLoginBtn.style.display !== "none") {
          nameSelectionLoginBtn.click();
        } else if (nameSelectionStartBtn.style.display !== "none") {
          nameSelectionStartBtn.click();
        }
      }
    });

    nameSelectionPassword.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        nameSelectionLoginBtn.click();
      }
    });

    nameSelectionModal.addEventListener("click", (e) => {
      if (e.target === nameSelectionModal) {
        // Don't allow closing by clicking outside - user must enter name
      }
    });

    function startNewRound() {
      if (gameMode === "multiplayer" && currentRoomId) {
        // In multiplayer, don't reset - wait for sync from Firestore
        return;
      }

      // Cancel any pending computer move
      if (computerMoveTimeoutId !== null) {
        clearTimeout(computerMoveTimeoutId);
        computerMoveTimeoutId = null;
      }

      board = createEmptyBoard();
      gameOver = false;
      gameStarted = false; // Don't mark as started yet - wait for first move or user confirmation
      computerThinking = false;
      resetGameState();
      clearGameState(); // Clear saved game state when starting new round
      
      // Update button text
      updateRestartButtonText();

      // Alternate which mark the human controls each game
      humanPlayer = nextHumanPlayer;
      computerPlayer = humanPlayer === "X" ? "O" : "X";
      // Set starting player: if human is X, human goes first; if human is O, computer (X) goes first
      currentPlayer = humanPlayer === "X" ? humanPlayer : computerPlayer;

      const cells = document.querySelectorAll(".cell");
      cells.forEach(cell => {
        cell.textContent = "";
        cell.classList.remove("X", "O", "last-move", "win");
      });

      shareGameResultBtn.classList.remove("visible");
      if (gameMode === "training") {
        updateStreakDisplays();
      } else if (gameMode === "multiplayer") {
        updateMultiplayerScoreDisplay();
      }

      // Prepare status - game hasn't started yet
      if (!hasHumanName()) {
        statusElem.textContent = "Enter your name above to start playing";
        statusRow.className = "status-neutral";
      } else if (currentPlayer === humanPlayer) {
        // Human goes first - can click on board to start
        const name = getHumanDisplayName();
        setStatusWithMark(name, currentPlayer, "  click any square to start");
        statusRow.className = "status-your-turn";
      } else {
        // Computer goes first - user must click "Start Game" button to begin
        statusElem.textContent = "Computer goes first. Click the 'Start Game'.";
        statusRow.className = "status-neutral";
      }

      // Flip for next game
      nextHumanPlayer = nextHumanPlayer === "X" ? "O" : "X";
    }

    async function init() {
      // Reset current streak on page refresh
      currentStreak = 0;
      
      // Reset nextHumanPlayer to "X" so first game after page reload always starts with human going first
      nextHumanPlayer = "X";
      
      // Set initial state before any rendering
      gameMode = "training"; // Default to training mode
      // Don't load saved mode - always start with training
      // loadGameMode(); // Load game mode preference (may override default)
      
      // Initialize board first
      initBoardUI();
      
      // Debug: Test if board clicks are working
      console.log("Board initialized, cells:", document.querySelectorAll(".cell").length);
      boardElem.addEventListener("click", (e) => {
        console.log("Board element clicked!", e.target);
      }, true); // Use capture phase to catch all clicks
      
      // Initialize toggle switches
      if (modeToggleSwitch) {
        initializeToggle(modeToggleSwitch);
        // Remove any existing listeners first
        const newToggle = modeToggleSwitch.cloneNode(true);
        modeToggleSwitch.parentNode.replaceChild(newToggle, modeToggleSwitch);
        const toggleSwitch = document.getElementById("modeToggleSwitch");
        
        // Enable training toggle to switch to multiplayer
        // Handle clicks on the toggle container - clicks on mode-option will bubble up
        toggleSwitch.addEventListener("click", function(e) {
          console.log("Training toggle clicked! Target:", e.target.className, "CurrentTarget:", e.currentTarget.id);
          e.preventDefault();
          e.stopPropagation();
          toggleGameMode();
        });
        
        // Prevent mode-option elements from interfering - they're just visual
        const modeOptions = toggleSwitch.querySelectorAll(".mode-option");
        modeOptions.forEach(option => {
          option.style.pointerEvents = "none"; // Make them non-clickable, clicks go to parent
        });
        console.log("Training toggle event listener attached in init()");
      }
      if (modeToggleSwitchMultiplayer) {
        initializeToggle(modeToggleSwitchMultiplayer);
        // Add event listener for multiplayer toggle (enabled for testing)
        // Remove any existing listeners first by cloning (but we'll use onclick to be sure)
        modeToggleSwitchMultiplayer.onclick = function(e) {
          console.log("Multiplayer toggle clicked!", e);
          e.stopPropagation();
          toggleGameMode();
        };
        console.log("Multiplayer toggle event listener attached in init()");
      } else {
        console.error("modeToggleSwitchMultiplayer element not found in init()");
      }
      
      // Initialize UI state after DOM elements exist
      if (modeToggleSwitch && modeToggleSwitchMultiplayer) {
        updateModeToggle();
      }
      
      await loadBestStreak();
      loadStats();
      loadAchievements();
      updateAchievementsDisplay();
      
      // Update toggle again after everything is loaded
      if (modeToggleSwitch && modeToggleSwitchMultiplayer) {
        updateModeToggle();
      }
      
      // Try to restore saved player name
      try {
        const savedName = localStorage.getItem("tictac9x9_currentPlayerName");
        if (savedName && savedName.trim()) {
          humanNameInput.value = savedName;
          if (firebaseInitialized && db) {
            const isRegistered = await checkNameRegistered(savedName);
            if (isRegistered) {
              await completeNameSetup(savedName);
            } else {
              currentPlayerName = savedName;
              if (gameMode === "training") {
                updateStreakDisplays();
              }
            }
          } else {
            // Firebase not configured, just set the name
            currentPlayerName = savedName;
            if (gameMode === "training") {
              updateStreakDisplays();
            }
          }
        } else {
          humanNameInput.value = "";
        }
      } catch (e) {
        humanNameInput.value = "";
      }
      
      if (gameMode === "training") {
        updateStreakDisplays();
      }
      
      // Clear any stale game state on init (forfeit modal will show on beforeunload if needed)
      clearGameState();
      
      // Initialize game state but don't start automatically
      gameStarted = false;
      gameOver = true; // Set to true so no moves can be made until game starts
      board = createEmptyBoard();
      updateRestartButtonText();
      
      // Clear board display
      const cells = document.querySelectorAll(".cell");
      cells.forEach(cell => {
        cell.textContent = "";
        cell.classList.remove("X", "O", "last-move", "win");
      });
      
      // Set initial status and prepare game
      if (!currentPlayerName) {
        statusElem.textContent = "Enter your name above to start playing";
        statusRow.className = "status-neutral";
        showNameSelectionModal();
      } else {
        // Name exists - prepare the game so player can click to start
        // Only call startNewRound() if it wasn't already called by completeNameSetup()
        if (humanPlayer === undefined || currentPlayer === undefined) {
          startNewRound();
        } else {
          // Ensure gameOver is false even if startNewRound() was already called
          // (because init() sets gameOver = true after completeNameSetup might have called startNewRound)
          gameOver = false;
        }
        if (gameMode === "training") startWaitingRoomCheck();
      }
    }
    
    // Forfeit modal handlers
    // Match result modal event listeners
    if (matchResultRematchBtn) {
      matchResultRematchBtn.addEventListener("click", handleRematchAccept);
    }
    if (matchResultDeclineBtn) {
      matchResultDeclineBtn.addEventListener("click", handleRematchDecline);
    }
    if (rematchDeclineBackBtn) {
      rematchDeclineBackBtn.addEventListener("click", async () => {
        // Hide modal
        rematchDeclineResultModal.classList.remove("show");
        
        // Close room if it still exists (might already be deleted by forfeiter)
        if (currentRoomId && firebaseInitialized && db) {
          try {
            const roomRef = db.collection("gameRooms").doc(currentRoomId);
            const roomDoc = await roomRef.get();
            if (roomDoc.exists) {
              await roomRef.delete();
            }
          } catch (error) {
            console.error("Error closing room:", error);
          }
        }
        
        // Clean up local state
        if (roomListener) {
          roomListener();
          roomListener = null;
        }
        
        currentRoomId = null;
        isPlayer1 = false;
        opponentName = "";
        player1Name = "";
        player2Name = "";
        matchGameNumber = 0;
        matchResults = { player1Wins: 0, draws: 0, player2Wins: 0 };
        currentMatchScore = { player1: 0, player2: 0 };
        gameOver = false;
        gameStarted = false;
        updateMultiplayerScoreDisplay();
        
        // Stop loading animation if any
        if (loadingDotsInterval) {
          clearInterval(loadingDotsInterval);
          loadingDotsInterval = null;
        }
        
        // Show multiplayer dialog
        showRoomModal();
      });
    }
    
    forfeitContinueBtn.addEventListener("click", () => {
      hideForfeitModal();
      isNavigatingAway = false;
      pendingForfeitOnUnload = false;
      forfeitModalShownForUnload = false;
      const action = forfeitModal.dataset.action || "";
      delete forfeitModal.dataset.action;
      
      const savedGameState = loadGameState();
      if (savedGameState) {
        restoreGameState(savedGameState);
        // Continue saving game state
        saveGameState();
      } else if (action === "restart") {
        // If it was a restart action but no saved state, just continue current game
        // (shouldn't happen, but handle it gracefully)
      } else {
        startNewRound();
      }
    });
    
    forfeitConfirmBtn.addEventListener("click", async () => {
      hideForfeitModal();
      isNavigatingAway = false;
      pendingForfeitOnUnload = false;
      const action = forfeitModal.dataset.action || "";
      delete forfeitModal.dataset.action;
      
      await handleForfeit();
      
      // If it was a restart action, start a new game after forfeit
      if (action === "restart") {
        startNewRound();
      } else if (action === "forfeit-button") {
        // Forfeit button clicked - room will be closed by handleMultiplayerForfeit
        // Stay in multiplayer mode, room will be closed
      } else if (action === "leave-room" || action === "switch-mode") {
        // After forfeiting in multiplayer, the room will be closed by handleMultiplayerForfeit
        // Just switch to training mode
        gameMode = "training";
        saveGameMode();
        updateModeToggle();
        startNewRound(); // Reset to training state
      } else if (action === "" && gameMode === "multiplayer") {
        // Page close/refresh forfeit - room will be closed by handleMultiplayerForfeit
        // Allow page to close/refresh naturally after forfeit is processed
        setTimeout(() => {
          // Page will close/refresh naturally
        }, 1000);
      }
      // Otherwise, allow page to refresh/close naturally
    });
    
    forfeitModal.addEventListener("click", (e) => {
      if (e.target === forfeitModal) {
        // Don't allow closing by clicking outside - user must choose
      }
    });

    // Play Again Modal handlers
    // Play again modal removed - game starts directly when "Start Game" is clicked

    // Handle page close/refresh - show forfeit modal if game is active
    let isNavigatingAway = false;
    
    // Track if we should prevent navigation
    let pendingForfeitOnUnload = false;
    let forfeitModalShownForUnload = false;
    
    // Show forfeit modal when user tries to leave (before beforeunload)
    window.addEventListener("mouseleave", (e) => {
      if (e.clientY < 0 && gameMode === "multiplayer" && currentRoomId) {
        const totalGames = (matchResults?.player1Wins || 0) + (matchResults?.player2Wins || 0) + (matchResults?.draws || 0);
        const matchFinished = gameOver && totalGames >= 2;
        if (!matchFinished && (gameStarted || totalGames > 0) && !forfeitModal.classList.contains("show")) {
          showForfeitModal("");
          forfeitModalShownForUnload = true;
        }
      }
    });
    
    window.addEventListener("beforeunload", (e) => {
      // Check for multiplayer match in progress
      if (gameMode === "multiplayer" && currentRoomId) {
        // Check if match appears to be in progress based on local state
        const totalGames = (matchResults?.player1Wins || 0) + (matchResults?.player2Wins || 0) + (matchResults?.draws || 0);
        const matchFinished = gameOver && totalGames >= 2;
        // If match is not finished and game has started, prevent leaving
        if (!matchFinished && (gameStarted || totalGames > 0)) {
          // If modal wasn't shown yet, try to show it (may not work reliably)
          if (!forfeitModalShownForUnload && !forfeitModal.classList.contains("show")) {
            showForfeitModal("");
            forfeitModalShownForUnload = true;
          }
          pendingForfeitOnUnload = true;
          // Prevent navigation
          e.preventDefault();
          e.returnValue = "You have an active multiplayer game. Leaving will forfeit the match and award 4 points to your opponent."; // Required for Chrome
          return "You have an active multiplayer game. Leaving will forfeit the match and award 4 points to your opponent."; // Required for other browsers
        }
      }
      
      // Also check for training mode active game
      const savedGameState = loadGameState();
      const hasMovesOnBoard = board.some(row => row.some(cell => cell !== ""));
      if (savedGameState && savedGameState.playerName && 
          savedGameState.playerName.toLowerCase() === (currentPlayerName || "").toLowerCase() &&
          gameMode === "training" && !gameOver && gameStarted && hasMovesOnBoard) {
        // Trigger browser's confirmation dialog
        e.preventDefault();
        e.returnValue = ""; // Required for Chrome
        return ""; // Required for other browsers
      }
    });
    
    // Handle visibility change - if page becomes hidden and forfeit is pending, execute it
    document.addEventListener("visibilitychange", async () => {
      if (document.hidden && pendingForfeitOnUnload && gameMode === "multiplayer" && currentRoomId && firebaseInitialized && db) {
        // User is leaving - execute forfeit
        try {
          await handleMultiplayerForfeit();
        } catch (error) {
          console.error("Error executing forfeit on visibilitychange:", error);
        }
      }
    });
    
    // Handle actual page unload - execute forfeit if user confirmed leaving
    window.addEventListener("pagehide", async () => {
      if (pendingForfeitOnUnload && gameMode === "multiplayer" && currentRoomId && firebaseInitialized && db) {
        // User confirmed leaving - execute forfeit
        try {
          await handleMultiplayerForfeit();
        } catch (error) {
          console.error("Error executing forfeit on pagehide:", error);
          // Fallback: try to update Firestore directly
          try {
            const roomRef = db.collection("gameRooms").doc(currentRoomId);
            const roomDoc = await roomRef.get();
            if (roomDoc.exists) {
              const roomData = roomDoc.data();
              let updatedMatchResults = { ...(roomData.matchResults || { player1Wins: 0, draws: 0, player2Wins: 0 }) };
              if (isPlayer1) {
                updatedMatchResults.player2Wins = 2;
              } else {
                updatedMatchResults.player1Wins = 2;
              }
              await roomRef.update({
                gameOver: true,
                winner: isPlayer1 ? "O" : "X",
                matchResults: updatedMatchResults,
                forfeit: true,
                forfeitedBy: isPlayer1 ? "player1" : "player2",
                lastMove: firebase.firestore.FieldValue.serverTimestamp()
              });
              // Close room after a delay
              setTimeout(async () => {
                await roomRef.delete();
              }, 2000);
            }
          } catch (fallbackError) {
            console.error("Fallback forfeit also failed:", fallbackError);
          }
        }
      }
    });

    // Handle visibility change - hide modal if user cancels navigation
    document.addEventListener("visibilitychange", () => {
      if (!document.hidden && isNavigatingAway) {
        // User cancelled navigation - hide modal and reset flag
        hideForfeitModal();
        isNavigatingAway = false;
      }
    });


    init();
  </script>
</body>
</html>
