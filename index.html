<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>5-in-a-Row - Challenge the AI!</title>
  <meta name="description" content="Play 5-in-a-Row against a challenging AI. Track your stats, unlock achievements, and compete for the global best streak!" />
  <meta name="keywords" content="5 in a row, tic tac toe, strategy game, puzzle game, online game" />
  <meta property="og:title" content="5-in-a-Row - Challenge the AI!" />
  <meta property="og:description" content="Play 5-in-a-Row against a challenging AI. Track your stats, unlock achievements, and compete for the global best streak!" />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="5-in-a-Row - Challenge the AI!" />
  <meta name="twitter:description" content="Play 5-in-a-Row against a challenging AI. Track your stats, unlock achievements, and compete for the global best streak!" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    
    :root {
      --bg-main: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #4facfe 75%, #00f2fe 100%);
      --board-bg: linear-gradient(145deg, #f0f4f8 0%, #e2e8f0 100%);
      --cell-bg: #ffffff;
      --cell-bg-hover: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%);
      --x-color: #ef4444;
      --o-color: #3b82f6;
      --accent: #6366f1;
      --accent-hover: #4f46e5;
      --success: #10b981;
      --success-hover: #059669;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.08), 0 1px 2px rgba(0, 0, 0, 0.06);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      --shadow-glow: 0 0 20px rgba(99, 102, 241, 0.3);
      --shadow-soft: 0 8px 32px rgba(0, 0, 0, 0.08);
      --shadow-soft-inner: inset 0 2px 4px rgba(0, 0, 0, 0.06);
      --text-primary: #0f172a;
      --text-secondary: #64748b;
      --app-bg: rgba(255, 255, 255, 0.85);
      --app-border: rgba(255, 255, 255, 0.3);
      --glass-bg: rgba(255, 255, 255, 0.7);
      --glass-border: rgba(255, 255, 255, 0.5);
      --player-tag-bg: rgba(255, 255, 255, 0.9);
      --player-tag-border: rgba(226, 232, 240, 0.8);
      --input-bg: rgba(255, 255, 255, 0.95);
      --input-border: rgba(226, 232, 240, 0.8);
      --radius-sm: 8px;
      --radius-md: 14px;
      --radius-lg: 20px;
      --radius-xl: 28px;
      --radius-full: 9999px;
    }

    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    [data-theme="dark"] {
      --bg-main: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 25%, #252b45 50%, #1e2338 75%, #0f1428 100%);
      --board-bg: linear-gradient(145deg, #1a2332 0%, #1e293b 100%);
      --cell-bg: linear-gradient(145deg, #334155 0%, #2d3748 100%);
      --cell-bg-hover: linear-gradient(145deg, #475569 0%, #3d4757 100%);
      --x-color: #ff6b6b;
      --o-color: #4dabf7;
      --accent: #5c7cfa;
      --accent-hover: #4c6ef5;
      --success: #51cf66;
      --success-hover: #40c057;
      --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.4), 0 1px 2px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.5), 0 2px 4px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.05);
      --shadow-lg: 0 10px 20px rgba(0, 0, 0, 0.6), 0 4px 8px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.08);
      --shadow-xl: 0 20px 40px rgba(0, 0, 0, 0.7), 0 8px 16px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.1);
      --shadow-glow: 0 0 30px rgba(92, 124, 250, 0.4), 0 0 60px rgba(92, 124, 250, 0.2);
      --shadow-soft: 0 8px 32px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.08);
      --shadow-soft-inner: inset 0 2px 4px rgba(0, 0, 0, 0.4), inset 0 0 0 1px rgba(255, 255, 255, 0.05);
      --text-primary: #f1f5f9;
      --text-secondary: #cbd5e1;
      --app-bg: rgba(15, 23, 42, 0.92);
      --app-border: rgba(148, 163, 184, 0.2);
      --glass-bg: rgba(30, 41, 59, 0.7);
      --glass-border: rgba(148, 163, 184, 0.15);
      --player-tag-bg: rgba(30, 41, 59, 0.8);
      --player-tag-border: rgba(148, 163, 184, 0.2);
      --input-bg: rgba(30, 41, 59, 0.8);
      --input-border: rgba(148, 163, 184, 0.25);
    }

    [data-theme="dark"] .cell {
      border-color: rgba(203, 213, 225, 0.3);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.12), 0 2px 4px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.08);
    }

    [data-theme="dark"] .cell:hover {
      border-color: rgba(92, 124, 250, 0.7);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 4px 12px rgba(92, 124, 250, 0.4), 0 0 0 2px rgba(92, 124, 250, 0.5);
      transform: translateY(-1px);
    }

    [data-theme="dark"] .cell::after {
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.25), transparent 70%);
    }

    [data-theme="dark"] .cell.win {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 50%, #b45309 100%);
      color: #fef3c7;
      box-shadow: 0 0 20px rgba(245, 158, 11, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.2);
      border-color: rgba(245, 158, 11, 0.6);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg-main);
      background-size: 400% 400%;
      animation: gradientShift 15s ease infinite;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      color: var(--text-primary);
      transition: background 0.3s ease, color 0.3s ease;
    }

    .app {
      background: var(--glass-bg);
      border-radius: var(--radius-xl);
      padding: 12px 8px 14px;
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      transition: all 0.3s ease;
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
      box-sizing: border-box;
    }

    /* Mode Toggle Switch */
    #modeToggleSwitch,
    #modeToggleSwitchMultiplayer {
      display: flex;
      align-items: center;
      background: var(--cell-bg);
      border: 1px solid var(--app-border);
      border-radius: var(--radius-full);
      padding: 2px;
      cursor: not-allowed;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      min-width: 64px;
      height: 24px;
      flex-shrink: 0;
      box-sizing: border-box;
      opacity: 0.5;
      pointer-events: none;
    }

    #modeToggleSwitch:hover,
    #modeToggleSwitchMultiplayer:hover {
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      transform: translateX(-50%);
    }

    /* Toggle is now outside the bars */

    /* Hide multiplayer elements by default until JS loads */
    #multiplayer-score-bar {
      display: none;
    }

    #leaderboardBtn {
      display: none;
    }

    #modeToggleSwitch:hover,
    #modeToggleSwitchMultiplayer:hover {
      border-color: var(--accent);
      box-shadow: var(--shadow-md);
    }

    .mode-option {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      padding: 3px 5px;
      z-index: 2;
      transition: color 0.3s ease;
      user-select: none;
      height: 100%;
      box-sizing: border-box;
    }

    .mode-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: calc(50% - 2px);
      height: calc(100% - 4px);
      background: linear-gradient(135deg, var(--accent), rgba(37, 99, 235, 0.8));
      border-radius: var(--radius-full);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1;
      box-shadow: 0 1px 3px rgba(37, 99, 235, 0.25);
    }

    #modeToggleSwitch.multiplayer .mode-slider,
    #modeToggleSwitchMultiplayer.multiplayer .mode-slider {
      transform: translateX(100%);
    }

    #modeToggleSwitch.multiplayer .mode-option[data-mode="multiplayer"],
    #modeToggleSwitchMultiplayer.multiplayer .mode-option[data-mode="multiplayer"] {
      color: white;
    }

    #modeToggleSwitch:not(.multiplayer) .mode-option[data-mode="training"],
    #modeToggleSwitchMultiplayer:not(.multiplayer) .mode-option[data-mode="training"] {
      color: white;
    }

    h1 {
      margin: 0 0 8px;
      margin-top: -8px;
      font-size: 24px;
      font-weight: 700;
      letter-spacing: -0.03em;
      text-align: center;
      background: linear-gradient(135deg, var(--accent), #8b5cf6, #ec4899);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      background-size: 200% 200%;
      animation: gradientShift 8s ease infinite;
      font-family: 'Inter', system-ui, sans-serif;
    }

    #streak-bar {
      position: relative;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      margin-top: 0;
      gap: 8px;
      font-size: 12px;
      color: var(--text-secondary);
      min-height: 32px;
    }

    #streak-bar #modeToggleSwitch {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }

    #bestStreakDisplay {
      font-weight: 600;
      white-space: nowrap;
      font-size: 13px;
      font-family: 'Inter', system-ui, sans-serif;
      color: var(--text-primary);
      background: rgba(251, 191, 36, 0.1);
      padding: 5px 12px;
      border-radius: var(--radius-md);
      border: 1px solid rgba(251, 191, 36, 0.2);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
      box-sizing: border-box;
      box-shadow: var(--shadow-sm);
    }

    #bestStreakDisplay:hover {
      background: rgba(251, 191, 36, 0.15);
      border-color: rgba(251, 191, 36, 0.3);
    }

    #currentStreakDisplay {
      margin-left: auto;
      font-weight: 600;
      font-size: 13px;
      font-family: 'Inter', system-ui, sans-serif;
      color: var(--text-primary);
      background: rgba(37, 99, 235, 0.1);
      padding: 5px 12px;
      border-radius: var(--radius-md);
      border: 1px solid rgba(37, 99, 235, 0.2);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex-shrink: 0;
      box-sizing: border-box;
      box-shadow: var(--shadow-sm);
    }

    #currentStreakDisplay:hover {
      background: rgba(37, 99, 235, 0.15);
      border-color: rgba(37, 99, 235, 0.3);
    }


    #multiplayer-score-bar {
      position: relative;
      margin-bottom: 12px;
      margin-top: 0;
      min-height: 32px;
    }

    #multiplayer-score-bar #modeToggleSwitchMultiplayer {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }

    .player-score-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-top: 0;
      padding-top: 0;
      min-height: 32px;
    }

    .player-score-item-left {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 0 1 auto;
      min-width: 0;
      justify-content: flex-start;
      margin-left: 0;
    }

    .player-score-item-right {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 0 1 auto;
      min-width: 0;
      justify-content: flex-end;
      margin-right: 0;
    }

    .player-name-display {
      font-weight: 500;
      font-size: 12px;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 120px;
      min-width: 0;
      transition: color 0.2s ease;
      box-sizing: border-box;
    }

    .player-score-value {
      font-weight: 700;
      font-size: 18px;
      font-family: 'Inter', system-ui, sans-serif;
      color: var(--accent);
      background: linear-gradient(135deg, rgba(37, 99, 235, 0.15), rgba(37, 99, 235, 0.08));
      padding: 5px 12px;
      border-radius: var(--radius-md);
      border: 1px solid rgba(37, 99, 235, 0.25);
      box-shadow: var(--shadow-sm);
      min-width: 40px;
      text-align: center;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      flex-shrink: 0;
      box-sizing: border-box;
      overflow: hidden;
    }

    .player-score-value:hover {
      background: linear-gradient(135deg, rgba(37, 99, 235, 0.2), rgba(37, 99, 235, 0.12));
      border-color: rgba(37, 99, 235, 0.35);
      transform: translateY(-1px);
      box-shadow: 0 3px 6px rgba(37, 99, 235, 0.15);
    }

    /* Loading dots animation */
    .loading-dots {
      display: inline-block;
      width: 1.5em;
      text-align: left;
      font-family: monospace;
    }

    .loading-dots::after {
      content: '...';
      animation: pulseDots 1.5s ease-in-out infinite;
    }

    @keyframes pulseDots {
      0%, 100% {
        opacity: 0.3;
      }
      50% {
        opacity: 1;
      }
    }

    .name-button {
      border-radius: var(--radius-md);
      border: 1px solid var(--input-border);
      background: var(--cell-bg);
      padding: 6px 14px;
      font-size: 12px;
      font-weight: 600;
      font-family: 'Inter', system-ui, sans-serif;
      cursor: pointer;
      color: var(--text-primary);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: var(--shadow-sm);
    }

    .name-button:hover {
      background: var(--cell-bg-hover);
      border-color: var(--accent);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    #players {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-bottom: 4px;
      flex-wrap: wrap;
      align-items: center;
    }

    .name-bar-info {
      min-width: 36px;
      padding: 0 10px;
    }

    .player-tag {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .player-dot {
      width: 20px;
      height: 20px;
      border-radius: var(--radius-md);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .player-dot.X-dot {
      background: rgba(220, 38, 38, 0.12);
      border: 1px solid rgba(220, 38, 38, 0.4);
      color: var(--x-color);
    }

    .player-dot.O-dot {
      background: rgba(37, 99, 235, 0.12);
      border: 1px solid rgba(37, 99, 235, 0.4);
      color: var(--o-color);
    }

    .player-name-input {
      border-radius: var(--radius-md);
      border: 1px solid var(--input-border);
      padding: 8px 14px;
      font-size: 13px;
      font-family: 'Inter', system-ui, sans-serif;
      min-width: 130px;
      outline: none;
      background: var(--input-bg);
      color: var(--text-primary);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: var(--shadow-sm);
    }

    .player-name-input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15), var(--shadow-md);
      transform: translateY(-1px);
    }

    .player-name-input:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    #statusRow {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-bottom: 6px;
      min-height: 40px;
      text-align: center;
      padding: 8px 14px;
      border-radius: var(--radius-md);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      width: calc(9 * 44px + 8 * 4px);
      margin-left: auto;
      margin-right: auto;
      max-width: calc(100% - 16px);
      box-sizing: border-box;
      overflow: hidden;
      font-family: 'Inter', system-ui, sans-serif;
    }

    #statusRow.status-your-turn {
      background: rgba(34, 197, 94, 0.1);
      border: 1px solid rgba(34, 197, 94, 0.25);
      animation: statusPulse 2.5s ease-in-out infinite;
    }

    @keyframes statusPulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.2); }
      50% { box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.08); }
    }

    #statusRow.status-computer-turn {
      background: rgba(148, 163, 184, 0.12);
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    #statusRow.status-neutral {
      background: transparent;
      border: 1px solid transparent;
    }

    [data-theme="dark"] #statusRow.status-your-turn {
      background: linear-gradient(135deg, rgba(81, 207, 102, 0.2), rgba(64, 192, 87, 0.15));
      border-color: rgba(81, 207, 102, 0.4);
      box-shadow: 0 0 15px rgba(81, 207, 102, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    [data-theme="dark"] #statusRow.status-computer-turn {
      background: linear-gradient(135deg, rgba(148, 163, 184, 0.15), rgba(100, 116, 139, 0.1));
      border-color: rgba(148, 163, 184, 0.3);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    /* Enhanced dark mode styles for buttons and UI elements */
    [data-theme="dark"] button:not(.icon-button):not(.name-button) {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 0 2px 4px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    [data-theme="dark"] button:not(.icon-button):not(.name-button):hover {
      box-shadow: 0 6px 16px rgba(92, 124, 250, 0.4), 0 4px 8px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.15);
    }

    [data-theme="dark"] .icon-button {
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    [data-theme="dark"] .icon-button:hover {
      box-shadow: 0 4px 8px rgba(92, 124, 250, 0.3), 0 2px 4px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    [data-theme="dark"] .player-score-value {
      background: linear-gradient(135deg, rgba(92, 124, 250, 0.25), rgba(92, 124, 250, 0.15));
      border-color: rgba(92, 124, 250, 0.4);
      box-shadow: 0 2px 6px rgba(92, 124, 250, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    [data-theme="dark"] .player-score-value:hover {
      background: linear-gradient(135deg, rgba(92, 124, 250, 0.35), rgba(92, 124, 250, 0.2));
      border-color: rgba(92, 124, 250, 0.5);
      box-shadow: 0 4px 12px rgba(92, 124, 250, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.15);
    }

    [data-theme="dark"] #bestStreakDisplay {
      background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(245, 158, 11, 0.15));
      border-color: rgba(245, 158, 11, 0.4);
      box-shadow: 0 2px 6px rgba(245, 158, 11, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    [data-theme="dark"] #bestStreakDisplay:hover {
      background: linear-gradient(135deg, rgba(245, 158, 11, 0.25), rgba(245, 158, 11, 0.2));
      border-color: rgba(245, 158, 11, 0.5);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.15);
    }

    [data-theme="dark"] #currentStreakDisplay {
      background: linear-gradient(135deg, rgba(92, 124, 250, 0.2), rgba(92, 124, 250, 0.15));
      border-color: rgba(92, 124, 250, 0.4);
      box-shadow: 0 2px 6px rgba(92, 124, 250, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    [data-theme="dark"] #currentStreakDisplay:hover {
      background: linear-gradient(135deg, rgba(92, 124, 250, 0.25), rgba(92, 124, 250, 0.2));
      border-color: rgba(92, 124, 250, 0.5);
      box-shadow: 0 4px 12px rgba(92, 124, 250, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.15);
    }

    [data-theme="dark"] input[type="text"],
    [data-theme="dark"] input[type="password"] {
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    [data-theme="dark"] input[type="text"]:focus,
    [data-theme="dark"] input[type="password"]:focus {
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 0 0 3px rgba(92, 124, 250, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.08);
    }

    [data-theme="dark"] .app {
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), 0 8px 24px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    [data-theme="dark"] #board-wrapper {
      box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.4), 0 4px 12px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(203, 213, 225, 0.15);
    }

    #status {
      font-size: 15px;
      text-align: center;
      font-weight: 600;
      font-family: 'Inter', system-ui, sans-serif;
      flex: 1;
      width: 100%;
    }

    #shareGameResultBtn {
      visibility: hidden;
      pointer-events: none;
      width: 0;
      min-width: 0;
      padding: 0;
      margin: 0;
      overflow: hidden;
      border: none;
    }

    #shareGameResultBtn.visible {
      visibility: visible;
      pointer-events: auto;
      width: auto;
      min-width: 36px;
      padding: 0 10px;
      margin: 0;
      overflow: visible;
      border: 1px solid var(--accent);
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    #shareGameResultBtn.visible:hover {
      background: var(--accent-hover);
      border-color: var(--accent-hover);
    }

    #status .mark-X {
      color: var(--x-color);
      font-weight: 700;
    }

    #status .mark-O {
      color: var(--o-color);
      font-weight: 700;
    }

    #controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 6px;
      flex-wrap: wrap;
      align-items: center;
    }

    .icon-button {
      padding: 8px;
      border-radius: var(--radius-md);
      border: 1px solid var(--input-border);
      background: var(--cell-bg);
      color: var(--text-primary);
      font-size: 16px;
      cursor: pointer;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: var(--shadow-sm);
      display: flex;
      align-items: center;
      justify-content: center;
      height: 36px;
      min-width: 36px;
      box-sizing: border-box;
    }

    .icon-button.name-bar-info {
      height: auto;
      min-height: 34px;
      align-self: stretch;
    }

    .icon-button:hover {
      background: var(--cell-bg-hover);
      border-color: var(--accent);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .icon-button:active {
      transform: scale(0.95);
    }

    .icon-button:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .icon-button.muted {
      opacity: 0.5;
    }

    .icon-button.muted:hover {
      opacity: 0.7;
    }

    /* Stats Modal */
    #statsModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.4);
      z-index: 2000;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      opacity: 0;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #statsModal.show {
      display: flex;
      opacity: 1;
    }

    #statsContent {
      background: var(--glass-bg);
      border-radius: var(--radius-xl);
      padding: 28px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      color: var(--text-primary);
      box-sizing: border-box;
      -webkit-overflow-scrolling: touch;
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #statsModal.show #statsContent {
      transform: scale(1);
    }

    #statsContent h2 {
      margin: 0 0 20px 0;
      font-size: 20px;
      font-weight: 700;
      text-align: center;
      background: linear-gradient(135deg, var(--accent), #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    #statsColumns {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    .stats-column h3 {
      margin: 0 0 14px 0;
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
      text-align: center;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--input-border);
    }

    .stat-item {
      display: flex;
      justify-content: space-between;
      padding: 12px 0;
      border-bottom: 1px solid var(--input-border);
      transition: background 0.2s ease;
      border-radius: var(--radius-sm);
      padding-left: 8px;
      padding-right: 8px;
    }

    .stat-item:hover {
      background: rgba(99, 102, 241, 0.05);
    }

    .stat-item:last-child {
      border-bottom: none;
    }

    .stat-label {
      color: var(--text-secondary);
      font-weight: 500;
    }

    .stat-value {
      color: var(--text-primary);
      font-weight: 700;
      font-size: 16px;
    }

    #closeStats {
      margin-top: 16px;
      width: 100%;
    }

    /* Achievements */
    .achievements-section {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 2px solid var(--input-border);
    }

    .achievements-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }

    .achievement-item {
      background: var(--player-tag-bg);
      border: 1px solid var(--input-border);
      border-radius: var(--radius-lg);
      padding: 14px;
      text-align: center;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: var(--shadow-sm);
    }

    .achievement-item.unlocked {
      border-color: rgba(251, 191, 36, 0.5);
      background: rgba(251, 191, 36, 0.08);
      box-shadow: var(--shadow-md);
      position: relative;
      overflow: hidden;
    }

    .achievement-item.unlocked::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      animation: shimmer 3s infinite;
    }

    @keyframes shimmer {
      0% { left: -100%; }
      100% { left: 100%; }
    }

    .achievement-item:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .achievement-item.locked {
      opacity: 0.45;
      filter: grayscale(100%);
    }

    .achievement-icon {
      font-size: 32px;
      margin-bottom: 6px;
    }

    .achievement-name {
      font-weight: 600;
      font-size: 12px;
      color: var(--text-primary);
      margin-bottom: 4px;
    }

    .achievement-desc {
      font-size: 10px;
      color: var(--text-secondary);
      line-height: 1.3;
    }

    /* Achievements Modal */
    #trophyModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.4);
      z-index: 2000;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      opacity: 0;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #trophyModal.show {
      display: flex;
      opacity: 1;
    }

    #trophyContent {
      background: var(--glass-bg);
      border-radius: var(--radius-xl);
      padding: 28px;
      max-width: 700px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      color: var(--text-primary);
      box-sizing: border-box;
      -webkit-overflow-scrolling: touch;
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #trophyModal.show #trophyContent {
      transform: scale(1);
    }

    #trophyContent h2 {
      margin: 0 0 20px 0;
      font-size: 20px;
      font-weight: 700;
      text-align: center;
      background: linear-gradient(135deg, #fbbf24, #f59e0b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .achievement-notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--glass-bg);
      border: 1px solid rgba(251, 191, 36, 0.5);
      border-radius: var(--radius-lg);
      padding: 16px 20px;
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      z-index: 3000;
      animation: slideInRight 0.5s ease-out;
      max-width: 300px;
    }

    @keyframes slideInRight {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .achievement-notification-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 6px;
    }

    .achievement-notification-icon {
      font-size: 24px;
    }

    .achievement-notification-title {
      font-weight: 700;
      color: var(--text-primary);
      font-size: 14px;
    }

    .achievement-notification-desc {
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* Share modal (fallback when Web Share API unavailable) */
    #shareModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.4);
      z-index: 2500;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      opacity: 0;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #shareModal.show {
      display: flex;
      opacity: 1;
    }

    #shareModalContent {
      background: var(--glass-bg);
      border-radius: var(--radius-xl);
      padding: 28px;
      max-width: 360px;
      width: 90%;
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      color: var(--text-primary);
      box-sizing: border-box;
      -webkit-overflow-scrolling: touch;
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #shareModal.show #shareModalContent {
      transform: scale(1);
    }

    #shareModalContent h3 {
      margin: 0 0 16px 0;
      font-size: 16px;
      text-align: center;
      background: linear-gradient(135deg, var(--accent), #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    /* Name Selection Modal (shown when no cached name) */
    #nameSelectionModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 3000;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      opacity: 0;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #nameSelectionModal.show {
      display: flex;
      opacity: 1;
    }

    #nameSelectionModalContent {
      background: var(--glass-bg);
      border-radius: var(--radius-xl);
      padding: 28px;
      max-width: 480px;
      width: 90%;
      max-width: min(480px, calc(100vw - 32px));
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      color: var(--text-primary);
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin: 0 auto;
      align-items: center;
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #nameSelectionModal.show #nameSelectionModalContent {
      transform: scale(1);
    }

    #nameSelectionModalContent h3 {
      margin: 0;
      font-size: 20px;
      font-weight: 700;
      text-align: center;
      background: linear-gradient(135deg, var(--accent), #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    #nameSelectionInput,
    #nameSelectionPassword {
      width: 100% !important;
      max-width: 100% !important;
      box-sizing: border-box;
      text-align: center;
    }

    #nameSelectionPasswordSection {
      width: 100%;
    }

    /* Registration/Login Modal */
    #registerModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.4);
      z-index: 2500;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      opacity: 0;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #registerModal.show {
      display: flex;
      opacity: 1;
    }

    #registerModalContent {
      background: var(--glass-bg);
      border-radius: var(--radius-xl);
      padding: 24px;
      max-width: 480px;
      width: 90%;
      max-width: min(480px, calc(100vw - 32px));
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      color: var(--text-primary);
      box-sizing: border-box;
      -webkit-overflow-scrolling: touch;
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin: 0 auto;
      align-items: center;
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #registerModal.show #registerModalContent {
      transform: scale(1);
    }

    #registerModalContent h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      text-align: center;
      background: linear-gradient(135deg, var(--accent), #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    #registerModalMessage {
      margin: 0 !important;
      padding: 0;
      line-height: 1.4;
      word-wrap: break-word;
    }

    #registerPassword {
      width: 100% !important;
      max-width: 100% !important;
      margin-bottom: 0 !important;
      box-sizing: border-box;
      text-align: center;
    }

    #registerModalContent > div[style*="display: flex"] {
      display: flex !important;
      gap: 8px;
      flex-direction: column;
      width: 100%;
      align-items: stretch;
    }

    #registerModalContent > div[style*="display: flex"] > div[style*="display: flex"] {
      display: flex !important;
      gap: 8px;
      flex-direction: row;
      width: 100%;
    }

    #registerModalContent button:not(#registerSkipBtn) {
      flex: 1;
      min-width: 0;
      box-sizing: border-box;
    }

    #registerSkipBtn {
      width: 100% !important;
      background: rgba(34, 197, 94, 0.1) !important;
      border-color: rgba(34, 197, 94, 0.3) !important;
      color: rgb(34, 197, 94) !important;
      font-weight: 600 !important;
      margin-top: 4px !important;
      font-size: 12px !important;
      padding: 8px 16px !important;
      transition: all 0.2s ease !important;
    }

    #registerSkipBtn:hover {
      background: rgba(34, 197, 94, 0.2) !important;
      border-color: rgba(34, 197, 94, 0.5) !important;
      color: rgb(22, 163, 74) !important;
      transform: translateY(-1px) !important;
    }

    #registerSkipBtn:active {
      transform: translateY(0) !important;
    }

    #nameSelectionStartBtn {
      background: rgba(34, 197, 94, 0.1) !important;
      border-color: rgba(34, 197, 94, 0.3) !important;
      color: rgb(34, 197, 94) !important;
      font-weight: 600 !important;
    }

    #nameSelectionStartBtn:hover {
      background: rgba(34, 197, 94, 0.2) !important;
      border-color: rgba(34, 197, 94, 0.5) !important;
      color: rgb(22, 163, 74) !important;
      transform: translateY(-1px);
    }

    #nameSelectionStartBtn:active {
      transform: translateY(0);
    }

    #nameSelectionRegisterBtn {
      background: var(--accent) !important;
      color: white !important;
      border-color: var(--accent) !important;
      font-weight: 700 !important;
    }

    #nameSelectionRegisterBtn:hover {
      background: var(--accent-hover) !important;
      border-color: var(--accent-hover) !important;
      color: white !important;
      transform: translateY(-1px);
    }

    #nameSelectionRegisterBtn:active {
      transform: translateY(0);
    }

    /* Multiplayer Room Modal */
    #roomModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.4);
      z-index: 2500;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      opacity: 0;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #roomModal.show {
      display: flex;
      opacity: 1;
    }

    #roomModalContent {
      background: var(--glass-bg);
      border-radius: var(--radius-xl);
      padding: 24px;
      max-width: 400px;
      width: 90%;
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      color: var(--text-primary);
      box-sizing: border-box;
      -webkit-overflow-scrolling: touch;
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #roomModal.show #roomModalContent {
      transform: scale(1);
    }

    #roomModalContent h3 {
      margin: 0 0 16px 0;
      font-size: 18px;
      font-weight: 600;
      text-align: center;
      background: linear-gradient(135deg, var(--accent), #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    #modeToggle.multiplayer {
      background: rgba(34, 197, 94, 0.9);
      border-color: rgba(34, 197, 94, 1);
    }

    #modeToggle.multiplayer:hover {
      background: rgba(34, 197, 94, 1);
    }

    .share-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin-bottom: 12px;
    }

    .share-buttons a,
    .share-buttons button {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 16px;
      border-radius: var(--radius-md);
      font-size: 14px;
      font-weight: 500;
      text-decoration: none;
      color: var(--text-primary);
      background: var(--cell-bg);
      border: 1px solid var(--input-border);
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: var(--shadow-sm);
    }

    .share-buttons a:hover,
    .share-buttons button:hover {
      background: var(--cell-bg-hover);
      border-color: var(--accent);
    }

    #shareModalClose {
      display: block;
      width: 100%;
      margin-top: 12px;
    }

    /* Forfeit Modal - Popup above game */
    #forfeitModal,
    #playAgainModal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 3000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #forfeitModal.show,
    #playAgainModal.show {
      display: block;
      opacity: 1;
      pointer-events: auto;
    }

    #forfeitModal .modal-content,
    #playAgainModal .modal-content {
      background: var(--glass-bg);
      border-radius: var(--radius-xl);
      padding: 24px;
      max-width: 420px;
      width: calc(100vw - 40px);
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      color: var(--text-primary);
      box-sizing: border-box;
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #forfeitModal.show .modal-content,
    #playAgainModal.show .modal-content {
      transform: scale(1);
    }

    #forfeitModal::before,
    #playAgainModal::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      z-index: -1;
      opacity: 0;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #forfeitModal.show::before,
    #playAgainModal.show::before {
      opacity: 1;
    }

    /* Confetti container */
    #confettiContainer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1500;
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #ffd700;
      animation: confettiFall linear forwards;
    }

    @keyframes confettiFall {
      to {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
      }
    }

    /* Smooth piece placement */
    .cell.placing {
      animation: placePiece 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      will-change: transform;
    }

    @keyframes placePiece {
      0% {
        transform: scale(0);
      }
      50% {
        transform: scale(1.15);
      }
      100% {
        transform: scale(1);
      }
    }

    button:not(.icon-button):not(.name-button) {
      padding: 10px 20px;
      border-radius: var(--radius-md);
      border: none;
      background: linear-gradient(135deg, var(--accent), var(--accent-hover));
      color: white;
      font-size: 14px;
      font-weight: 600;
      font-family: 'Inter', system-ui, sans-serif;
      cursor: pointer;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: var(--shadow-md);
      display: flex;
      align-items: center;
      justify-content: center;
      height: 40px;
      box-sizing: border-box;
      letter-spacing: 0.01em;
      position: relative;
      overflow: hidden;
    }

    button:not(.icon-button):not(.name-button)::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.3);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }

    button:not(.icon-button):not(.name-button):active::before {
      width: 300px;
      height: 300px;
    }

    button:not(.icon-button):not(.name-button):hover {
      background: linear-gradient(135deg, var(--accent-hover), var(--accent));
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    button:not(.icon-button):not(.name-button):active {
      transform: translateY(0) scale(0.98);
      box-shadow: var(--shadow-md);
    }

    button:not(.icon-button):not(.name-button):focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    #board-wrapper {
      background: var(--board-bg);
      padding: 4px 2px 4px 2px;
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-soft-inner), var(--shadow-md);
      width: fit-content;
      margin: 0 auto;
      max-width: 100%;
      box-sizing: border-box;
      overflow: hidden;
    }

    #board {
      display: grid;
      grid-template-columns: repeat(9, 44px);
      grid-template-rows: repeat(9, 44px);
      gap: 4px;
      width: fit-content;
      max-width: 100%;
      box-sizing: border-box;
      isolation: isolate;
    }

    .cell {
      width: 44px;
      height: 44px;
      min-width: 0;
      min-height: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--cell-bg);
      cursor: pointer;
      font-size: 26px;
      font-weight: 700;
      font-family: 'Inter', system-ui, sans-serif;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-sm);
      border: 1px solid rgba(0, 0, 0, 0.08);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      user-select: none;
      position: relative;
      overflow: hidden;
      box-sizing: border-box;
      isolation: isolate;
    }

    .cell::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.6), transparent 70%);
      opacity: 0;
      transition: opacity 0.2s ease;
      pointer-events: none;
    }

    .cell:hover {
      background: var(--cell-bg-hover);
      transform: scale(1.05);
      box-shadow: var(--shadow-md);
      z-index: 1;
      border-color: rgba(99, 102, 241, 0.2);
    }

    .cell:hover::after {
      opacity: 1;
    }

    .cell.X {
      color: var(--x-color);
      animation: popIn 0.2s ease-out;
    }

    .cell.O {
      color: var(--o-color);
      animation: popIn 0.2s ease-out;
    }

    .cell.last-move {
      box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.6);
    }

    .cell.preview-X::before,
    .cell.preview-O::before {
      content: attr(data-preview);
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 26px;
      font-weight: 700;
      opacity: 0.25;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    .cell.preview-X {
      border-color: rgba(239, 68, 68, 0.4);
      box-shadow: 0 0 0 1px rgba(239, 68, 68, 0.2), 0 2px 4px rgba(239, 68, 68, 0.1);
    }

    .cell.preview-X::before {
      color: var(--x-color);
    }

    .cell.preview-O {
      border-color: rgba(59, 130, 246, 0.4);
      box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.2), 0 2px 4px rgba(59, 130, 246, 0.1);
    }

    .cell.preview-O::before {
      color: var(--o-color);
    }

    .cell.win {
      background: linear-gradient(135deg, #fef3c7, #fde68a, #fbbf24);
      background-size: 200% 200%;
      box-shadow: 0 0 0 2px rgba(217, 119, 6, 0.5);
      color: #92400e;
      animation: pulseWin 1s ease-in-out infinite, gradientShiftWin 3s ease infinite;
      position: relative;
    }

    .cell.win::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(135deg, rgba(251, 191, 36, 0.4), transparent);
      animation: glowOverlay 2s ease-in-out infinite;
    }

    @keyframes pulseWin {
      0%, 100% {
        transform: scale(1);
        box-shadow: 0 0 0 2px rgba(217, 119, 6, 0.85), 0 5px 14px rgba(180, 83, 9, 0.6), 0 0 20px rgba(251, 191, 36, 0.4);
      }
      50% {
        transform: scale(1.05);
        box-shadow: 0 0 0 3px rgba(217, 119, 6, 1), 0 7px 20px rgba(180, 83, 9, 0.8), 0 0 30px rgba(251, 191, 36, 0.6);
      }
    }

    @keyframes gradientShiftWin {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    @keyframes glowOverlay {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.6; }
    }

    #contactLink {
      display: block;
      text-align: center;
      margin-top: 8px;
      font-size: 12px;
      color: var(--text-secondary);
      text-decoration: none;
      opacity: 0.75;
      transition: opacity 0.2s ease;
    }

    #contactLink:hover {
      text-decoration: underline;
      opacity: 1;
    }

    #themeToggle {
      padding: 8px;
      border-radius: var(--radius-md);
      border: 1px solid var(--input-border);
      background: var(--cell-bg);
      color: var(--text-primary);
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: var(--shadow-sm);
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 36px;
      height: 36px;
    }

    #themeToggle:hover {
      background: var(--cell-bg-hover);
      border-color: var(--accent);
    }

    #themeToggle:active {
      transform: scale(0.98);
    }

    @keyframes popIn {
      from {
        transform: scale(0.2);
        opacity: 0;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    @keyframes glow {
      from {
        box-shadow: 0 0 0 2px rgba(217, 119, 6, 0.3), 0 6px 16px rgba(180, 83, 9, 0.5);
      }
      to {
        box-shadow: 0 0 0 3px rgba(217, 119, 6, 0.8), 0 7px 20px rgba(180, 83, 9, 0.75);
      }
    }

    /* Responsive design */
    @media (max-width: 600px) {
      body {
        padding: 8px;
        align-items: flex-start;
        padding-top: 12px;
      }

      .app {
        padding: 6px 6px;
        border-radius: 16px;
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
      }

      h1 {
        font-size: 18px;
        margin-bottom: 6px;
      }

      #streak-bar {
        font-size: 10px;
        gap: 6px;
        flex-wrap: nowrap;
        margin-bottom: 10px;
        overflow: hidden;
      }

      #streak-bar #modeToggleSwitch {
        position: absolute;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
      }

      #bestStreakDisplay {
        flex: 0 1 auto;
        min-width: 0;
        max-width: calc(50% - 40px);
        overflow: hidden;
        text-overflow: ellipsis;
        font-size: 11px;
        padding: 3px 6px;
      }

      #currentStreakDisplay {
        margin-left: auto;
        flex-shrink: 0;
        font-size: 11px;
        padding: 3px 6px;
        max-width: calc(50% - 40px);
      }

      #multiplayer-score-bar {
        overflow: hidden;
      }

      .player-score-row {
        gap: 6px;
        overflow: hidden;
      }

      .player-score-item-left,
      .player-score-item-right {
        max-width: calc(50% - 40px);
        min-width: 0;
      }

      .player-name-display {
        font-size: 11px;
        max-width: 80px;
      }

      .player-score-value {
        font-size: 16px;
        padding: 3px 8px;
        min-width: 32px;
      }

      #board-wrapper {
        padding: 3px 2px 3px 2px;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        max-width: 100%;
        box-sizing: border-box;
      }

      #board {
        grid-template-columns: repeat(9, min(36px, calc((100vw - 48px) / 9)));
        grid-template-rows: repeat(9, min(36px, calc((100vw - 48px) / 9)));
        gap: 3px;
        width: fit-content;
        max-width: 100%;
        box-sizing: border-box;
        isolation: isolate;
      }

      .cell {
        width: 100%;
        height: 100%;
        aspect-ratio: 1;
        font-size: clamp(16px, 4vw, 20px);
        border-radius: 6px;
        min-height: 0;
        min-width: 0;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.06);
      }

      .cell:hover {
        box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);
      }

      #statusRow {
        width: calc(9 * min(36px, calc((100vw - 48px) / 9)) + 8 * 3px);
        max-width: calc(100% - 12px);
        padding: 6px 8px;
        gap: 8px;
      }

      #status {
        font-size: 13px;
        padding: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      button:not(.icon-button):not(.name-button) {
        padding: 8px 14px;
        font-size: 13px;
        min-height: 36px;
        width: auto;
      }
      
      .icon-button {
        min-width: 36px;
        min-height: 36px;
        padding: 8px;
      }

      .player-name-input {
        min-width: 100px;
        max-width: 150px;
        font-size: 12px;
        padding: 6px 8px;
        min-height: 32px;
        box-sizing: border-box;
      }

      .name-button {
        font-size: 11px;
        padding: 4px 8px;
        min-height: 32px;
        flex-shrink: 0;
      }
      
      #players {
        gap: 6px;
        flex-wrap: wrap;
        justify-content: center;
      }

      #modeToggleSwitch,
      #modeToggleSwitchMultiplayer {
        min-width: 56px;
        height: 22px;
        padding: 2px;
      }

      .mode-option {
        font-size: 11px;
        padding: 2px 4px;
      }

      .mode-slider {
        top: 2px;
        left: 2px;
        width: calc(50% - 2px);
        height: calc(100% - 4px);
      }

      .modal-content {
        max-width: calc(100vw - 32px);
        margin: 20px auto;
        padding: 16px;
        max-height: calc(100vh - 40px);
        overflow-y: auto;
      }

      #statsContent {
        max-width: 100%;
        padding: 12px;
      }

      #statsColumns {
        grid-template-columns: 1fr;
        gap: 16px;
      }

      .stats-column h3 {
        font-size: 13px;
      }

      .stat-item {
        padding: 8px 0;
        font-size: 13px;
      }

      .achievements-grid {
        grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
        gap: 8px;
      }

      .achievement-item {
        padding: 8px;
      }

      .achievement-icon {
        font-size: 24px;
      }

      .achievement-name {
        font-size: 11px;
      }

      .achievement-desc {
        font-size: 9px;
      }

      #trophyContent,
      #shareModalContent,
      #registerModalContent,
      #roomModalContent,
      #nameSelectionModalContent {
        max-width: calc(100vw - 20px);
        width: calc(100vw - 20px);
        padding: 16px;
        max-height: calc(100vh - 20px);
      }

      #registerModalContent {
        padding: 16px;
        gap: 10px;
        max-width: min(480px, calc(100vw - 20px));
        width: calc(100vw - 20px);
      }

      #nameSelectionModalContent {
        padding: 20px;
        gap: 12px;
      }

      #nameSelectionModalContent h3 {
        font-size: 18px;
      }

      #nameSelectionInput,
      #nameSelectionPassword {
        font-size: 14px;
        padding: 10px;
        min-height: 44px;
      }

      #nameSelectionStartBtn,
      #nameSelectionRegisterBtn,
      #nameSelectionLoginBtn {
        min-height: 44px;
        font-size: 15px;
      }

      #nameSelectionMessage {
        font-size: 13px !important;
      }

      #nameSelectionWarning {
        font-size: 12px !important;
      }

      #registerModalContent h3 {
        font-size: 16px;
      }

      #registerModalMessage {
        font-size: 12px !important;
      }

      #registerPassword {
        font-size: 14px;
        padding: 8px 10px;
        min-height: 40px;
        text-align: center;
      }

      #registerModalContent button:not(#registerSkipBtn) {
        min-height: 40px;
        font-size: 14px;
      }

      #registerSkipBtn {
        min-height: 40px;
        font-size: 13px !important;
        padding: 8px 12px !important;
      }

      #statsContent {
        padding: 12px;
      }
    }

    @media (max-width: 400px) {
      body {
        padding: 6px;
      }

      .app {
        padding: 4px 4px;
      }

      h1 {
        font-size: 16px;
        margin-bottom: 4px;
      }

      #streak-bar {
        font-size: 9px;
        gap: 4px;
        margin-bottom: 8px;
      }

      #bestStreakDisplay {
        font-size: 10px;
        padding: 2px 5px;
        max-width: calc(50% - 35px);
      }

      #currentStreakDisplay {
        font-size: 10px;
        padding: 2px 5px;
        max-width: calc(50% - 35px);
      }

      .player-name-display {
        font-size: 10px;
        max-width: 70px;
      }

      .player-score-value {
        font-size: 14px;
        padding: 2px 6px;
        min-width: 28px;
      }

      #board-wrapper {
        padding: 2px 1px 2px 1px;
      }

      #board {
        grid-template-columns: repeat(9, min(30px, calc((100vw - 40px) / 9)));
        grid-template-rows: repeat(9, min(30px, calc((100vw - 40px) / 9)));
        gap: 2px;
        isolation: isolate;
      }
      
      .cell {
        font-size: clamp(14px, 3.5vw, 16px);
        min-height: 0;
        min-width: 0;
        box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
      }

      .cell:hover {
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
      }

      #statusRow {
        width: calc(9 * min(30px, calc((100vw - 40px) / 9)) + 8 * 2px);
        max-width: calc(100% - 8px);
        padding: 5px 6px;
        gap: 6px;
        min-height: 32px;
      }

      #status {
        font-size: 12px;
      }

      button:not(.icon-button):not(.name-button) {
        padding: 6px 12px;
        font-size: 12px;
        min-height: 32px;
      }

      .icon-button {
        min-width: 32px;
        min-height: 32px;
        padding: 6px;
      }

      .player-name-input {
        min-width: 90px;
        max-width: 120px;
        font-size: 11px;
        padding: 5px 6px;
        min-height: 30px;
      }

      .name-button {
        font-size: 10px;
        padding: 4px 6px;
        min-height: 30px;
      }

      #modeToggleSwitch,
      #modeToggleSwitchMultiplayer {
        min-width: 52px;
        height: 20px;
        padding: 1px;
      }

      .mode-option {
        font-size: 10px;
        padding: 2px 3px;
      }

      .mode-slider {
        top: 1px;
        left: 1px;
        width: calc(50% - 1px);
        height: calc(100% - 2px);
      }
    }

    @media (min-width: 601px) and (max-width: 900px) {
      .app {
        max-width: 480px;
      }

      #board-wrapper {
        padding: 5px 3px 5px 3px;
      }

      #board {
        grid-template-columns: repeat(9, min(38px, calc((100vw - 120px) / 9)));
        grid-template-rows: repeat(9, min(38px, calc((100vw - 120px) / 9)));
        gap: 3px;
        isolation: isolate;
      }

      .cell {
        font-size: clamp(20px, 2.5vw, 22px);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.07);
      }

      .cell:hover {
        box-shadow: 0 2px 3px rgba(0, 0, 0, 0.11);
      }

      #statusRow {
        width: calc(9 * min(38px, calc((100vw - 120px) / 9)) + 8 * 3px);
        max-width: calc(100% - 16px);
      }
    }

    @media (min-width: 901px) and (max-width: 1199px) {
      .app {
        max-width: 520px;
      }
    }

    @media (min-width: 1200px) {
      .app {
        max-width: 500px;
      }
    }

    /* Prevent text overflow and ensure proper scaling */
    * {
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Ensure modals are responsive */
    @media (max-width: 600px) {
      .modal {
        padding: 10px;
      }

      .modal-content {
        width: calc(100vw - 20px);
        max-width: calc(100vw - 20px);
        margin: 10px auto;
        padding: 12px;
      }

      #forfeitModal .modal-content {
        width: calc(100vw - 40px);
        max-width: calc(100vw - 40px);
        padding: 20px;
      }
    }
  </style>
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
</head>
<body>
  <div class="app">
    <div id="streak-bar">
      <div id="bestStreakDisplay">Best streak: none</div>
      <div id="modeToggleSwitch" class="mode-toggle"></div>
      <div id="currentStreakDisplay">Streak: 0</div>
    </div>
    
    <!-- Multiplayer Score Display -->
    <div id="multiplayer-score-bar" style="display: none;">
      <div class="player-score-row">
        <div class="player-score-item-left">
          <div id="player1ScoreDisplay" class="player-score-value">0</div>
          <div id="player1NameDisplay" class="player-name-display">-</div>
        </div>
        <div id="modeToggleSwitchMultiplayer" class="mode-toggle"></div>
        <div class="player-score-item-right">
          <div id="player2NameDisplay" class="player-name-display">
            Waiting <span class="loading-dots"></span>
          </div>
          <div id="player2ScoreDisplay" class="player-score-value">0</div>
        </div>
      </div>
    </div>

    <h1>5-in-a-Row</h1>

    <div id="players">
      <div class="player-tag">
        <div class="player-dot X-dot"></div>
        <input
          id="humanName"
          class="player-name-input"
          type="text"
          placeholder="Your name"
        />
        <button id="applyHumanName" class="name-button" type="button">Set</button>
      </div>
      <button id="shareGameResultBtn" class="icon-button name-bar-info" aria-label="Share result" type="button"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><path d="m8.59 13.51 6.82 3.98"/><path d="m15.41 6.51-6.82 3.98"/></svg></button>
    </div>

    <!-- Multiplayer Room Modal -->
    <div id="roomModal">
      <div id="roomModalContent">
        <h3 id="roomModalTitle">Multiplayer</h3>
        <div id="roomModalBody">
          <div style="display: flex; flex-direction: column; gap: 10px;">
            <button id="createRoomBtn" class="button" style="width: 100%;">Create Room</button>
            <button id="joinRoomBtn" class="button" style="width: 100%;">Join Room</button>
            <button id="quickMatchBtn" class="button" style="width: 100%;">Quick Match</button>
          </div>
          <div id="roomIdSection" style="display: none; margin-top: 16px;">
            <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Room ID:</div>
            <div id="roomIdDisplay" style="font-size: 18px; font-weight: 700; font-family: monospace; background: var(--cell-bg); padding: 8px; border-radius: var(--radius-md); text-align: center; border: 1px solid var(--input-border);"></div>
            <button id="copyRoomIdBtn" class="icon-button" style="width: 100%; margin-top: 8px;"> Copy Room ID</button>
          </div>
          <div id="waitingRoomSection" style="display: none; margin-top: 16px; text-align: center;">
            <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 12px;">Waiting for opponent...</div>
            <div id="roomPlayers" style="display: flex; justify-content: space-around; gap: 16px;">
              <div>
                <div style="font-size: 12px; color: var(--text-secondary);">Player 1</div>
                <div id="roomPlayer1" style="font-weight: 600;">-</div>
              </div>
              <div>
                <div style="font-size: 12px; color: var(--text-secondary);">Player 2</div>
                <div id="roomPlayer2" style="font-weight: 600;">-</div>
              </div>
            </div>
          </div>
          <div id="joinRoomSection" style="display: none; margin-top: 16px;">
            <input id="joinRoomIdInput" type="text" class="player-name-input" placeholder="Enter Room ID" style="width: 100%; margin-bottom: 10px;" />
            <button id="joinRoomConfirmBtn" class="button" style="width: 100%;">Join</button>
          </div>
        </div>
        <button id="roomModalClose" class="icon-button" style="margin-top: 12px; width: 100%;">Close</button>
      </div>
    </div>

    <!-- Name Selection Modal (shown when no cached name) -->
    <div id="nameSelectionModal">
      <div id="nameSelectionModalContent">
        <h3>Welcome to 5-in-a-Row!</h3>
        <div id="nameSelectionMessage" style="font-size: 14px; color: var(--text-secondary); margin-bottom: 16px; text-align: center;">
          Enter your name to start playing (minimum 3 characters)
        </div>
        <input
          id="nameSelectionInput"
          type="text"
          class="player-name-input"
          placeholder="Your name"
          style="width: 100%; margin-bottom: 12px; text-align: center; font-size: 16px; padding: 10px;"
          autofocus
          minlength="3"
        />
        <div id="nameSelectionWarning" style="display: none; font-size: 13px; color: #dc2626; margin-bottom: 12px; text-align: center; font-weight: 500;">
          If you register your username, no one can claim your streaks!
        </div>
        <div id="nameSelectionPasswordSection" style="display: none; width: 100%; margin-bottom: 12px;">
          <input
            id="nameSelectionPassword"
            type="password"
            class="player-name-input"
            placeholder="Enter password"
            style="width: 100%; text-align: center; font-size: 16px; padding: 10px;"
          />
        </div>
        <div id="nameSelectionButtons" style="display: flex; gap: 8px; flex-direction: column;">
          <button id="nameSelectionStartBtn" class="button" style="width: 100%; display: none;">Play Now</button>
          <button id="nameSelectionRegisterBtn" class="button" style="width: 100%; display: none;">Register Name</button>
          <button id="nameSelectionLoginBtn" class="button" style="width: 100%; display: none;">Login</button>
        </div>
      </div>
    </div>

    <!-- Registration/Login Modal -->
    <div id="registerModal">
      <div id="registerModalContent">
        <h3 id="registerModalTitle">Register Name</h3>
        <div id="registerModalMessage" style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px; text-align: center;"></div>
        <input
          id="registerPassword"
          type="password"
          class="player-name-input"
          placeholder="Enter password"
          style="width: 100%; margin-bottom: 10px;"
        />
        <div style="display: flex; gap: 8px; flex-direction: column;">
          <div style="display: flex; gap: 8px;">
            <button id="registerConfirmBtn" class="button" style="flex: 1;">Register</button>
            <button id="registerCancelBtn" class="icon-button" style="flex: 1;">Cancel</button>
          </div>
          <button id="registerSkipBtn" class="icon-button" style="margin-top: 4px; font-size: 12px; padding: 4px 8px;">Play without registering</button>
        </div>
      </div>
    </div>

    <div id="statusRow">
      <div id="status">Ready to play</div>
    </div>

    <div id="controls">
      <button id="restartBtn" title="Restart game (R or Space)">Restart game</button>
      <button id="statsBtn" class="icon-button" aria-label="Statistics"></button>
      <button id="leaderboardBtn" class="icon-button" aria-label="Leaderboard" style="display: none;"></button>
      <button id="trophyBtn" class="icon-button" aria-label="Achievements"></button>
      <button id="soundToggle" class="icon-button" aria-label="Toggle sound"></button>
      <button id="themeToggle" class="icon-button" aria-label="Toggle theme"></button>
    </div>

    <div id="board-wrapper">
      <div id="board"></div>
    </div>

    <a id="contactLink" href="mailto:stevan.toncic@gmail.com"> Contact</a>
  </div>

  <!-- Stats Modal -->
  <div id="statsModal">
    <div id="statsContent">
      <h2>Statistics</h2>
      <div id="statsColumns">
        <div class="stats-column">
          <h3 id="currentPlayerName">Current Player</h3>
          <div class="stat-item">
            <span class="stat-label">Games Played:</span>
            <span class="stat-value" id="statCurrentGamesPlayed">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Wins:</span>
            <span class="stat-value" id="statCurrentWins">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Losses:</span>
            <span class="stat-value" id="statCurrentLosses">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Draws:</span>
            <span class="stat-value" id="statCurrentDraws">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Win Rate:</span>
            <span class="stat-value" id="statCurrentWinRate">0%</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Current Streak:</span>
            <span class="stat-value" id="statCurrentStreak">0</span>
          </div>
        </div>
        <div class="stats-column">
          <h3>All Players</h3>
          <div class="stat-item">
            <span class="stat-label">Games Played:</span>
            <span class="stat-value" id="statGlobalGamesPlayed">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Wins:</span>
            <span class="stat-value" id="statGlobalWins">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Losses:</span>
            <span class="stat-value" id="statGlobalLosses">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Draws:</span>
            <span class="stat-value" id="statGlobalDraws">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Win Rate:</span>
            <span class="stat-value" id="statGlobalWinRate">0%</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Best Streak:</span>
            <span class="stat-value" id="statGlobalBestStreak">0</span>
          </div>
        </div>
      </div>
      <button id="closeStats" class="icon-button" style="margin-top: 16px; width: 100%;">Close</button>
    </div>
  </div>

  <!-- Achievements Modal -->
  <div id="trophyModal">
    <div id="trophyContent">
      <h2> Achievements</h2>
      <div style="text-align: center; margin-bottom: 16px; color: var(--text-secondary); font-size: 13px;">
        Unlocked: <span id="trophyUnlockedCount">0</span>/8
      </div>
      <div class="achievements-grid" id="trophyAchievementsGrid"></div>
      <div id="achievementsShareRow" style="display: flex; gap: 8px; margin-top: 16px; flex-wrap: wrap; justify-content: center;">
        <button id="shareAchievementsBtn" class="button" type="button">Share my achievements</button>
      </div>
      <button id="closeTrophy" class="icon-button" style="margin-top: 16px; width: 100%;">Close</button>
    </div>
  </div>

  <!-- Achievement Notification -->
  <div id="achievementNotification" style="display: none;"></div>

  <!-- Share Modal (fallback when native share unavailable) -->
  <div id="shareModal">
    <div id="shareModalContent">
      <h3 id="shareModalTitle">Share</h3>
      <div class="share-buttons" id="shareButtons"></div>
      <button id="shareModalClose" class="icon-button">Close</button>
    </div>
  </div>

  <!-- Forfeit Modal -->
  <div id="forfeitModal">
    <div class="modal-content">
      <h3 style="margin-top: 0; margin-bottom: 16px;"> Game In Progress</h3>
      <p id="forfeitModalMessage" style="margin-bottom: 20px; color: var(--text-secondary);">
        You have an active game. Closing or refreshing the page will count as a forfeit (loss).
      </p>
      <div style="display: flex; gap: 10px; justify-content: flex-end;">
        <button id="forfeitContinueBtn" class="button" style="background: var(--accent);">Continue Playing</button>
        <button id="forfeitConfirmBtn" class="button" style="background: #dc2626;">Forfeit (Counts as Loss)</button>
      </div>
    </div>
  </div>

  <!-- Play Again Modal (when computer goes first) -->
  <div id="playAgainModal">
    <div class="modal-content">
      <h3 style="margin-top: 0; margin-bottom: 16px;"> Play it again!</h3>
      <p style="margin-bottom: 20px; color: var(--text-secondary);">
        Computer goes first this round. Click "Start Game" when you're ready to play!
      </p>
      <div style="display: flex; gap: 10px; justify-content: flex-end;">
        <button id="playAgainStartBtn" class="button" style="background: var(--accent);">Start Game</button>
      </div>
    </div>
  </div>

  <!-- Confetti Container -->
  <div id="confettiContainer"></div>

  <script>
    const BOARD_SIZE = 9;
    const WIN_LENGTH = 5;

    // ============================================
    // FIREBASE CONFIGURATION
    // ============================================
    // TODO: Replace this with your Firebase config from Firebase Console
    // Get it from: Firebase Console  Project Settings  Your apps  Config
    const firebaseConfig = {
      apiKey: "AIzaSyBaQxN7VV8RGpSOExbfpluFaaGKPu0NfGY",
      authDomain: "in-a-row-5.firebaseapp.com",
      projectId: "in-a-row-5",
      storageBucket: "in-a-row-5.firebasestorage.app",
      messagingSenderId: "615966800813",
      appId: "1:615966800813:web:197850ee1fda2366833f24",
      measurementId: "G-L08B3D4HTZ"
    };

    // Initialize Firebase (only if config is provided)
    let db = null;
    let firebaseInitialized = false;
    
    if (firebaseConfig.apiKey && firebaseConfig.apiKey !== "YOUR_API_KEY_HERE") {
      try {
        firebase.initializeApp(firebaseConfig);
        db = firebase.firestore();
        firebaseInitialized = true;
      } catch (error) {
        console.error("Firebase initialization error:", error);
      }
    } else {
      console.warn("Firebase not configured. Global best streak will use localStorage.");
    }

    const boardElem = document.getElementById("board");
    const statusElem = document.getElementById("status");
    const statusRow = document.getElementById("statusRow");
    const restartBtn = document.getElementById("restartBtn");
    const themeToggleBtn = document.getElementById("themeToggle");
    const statsBtn = document.getElementById("statsBtn");
    const trophyBtn = document.getElementById("trophyBtn");
    const soundToggleBtn = document.getElementById("soundToggle");
    const statsModal = document.getElementById("statsModal");
    const trophyModal = document.getElementById("trophyModal");
    const closeStatsBtn = document.getElementById("closeStats");
    const closeTrophyBtn = document.getElementById("closeTrophy");
    const confettiContainer = document.getElementById("confettiContainer");
    const achievementNotification = document.getElementById("achievementNotification");
    const shareGameResultBtn = document.getElementById("shareGameResultBtn");
    const shareAchievementsBtn = document.getElementById("shareAchievementsBtn");
    const shareModal = document.getElementById("shareModal");
    const shareModalClose = document.getElementById("shareModalClose");
    const shareButtons = document.getElementById("shareButtons");
    const shareModalTitle = document.getElementById("shareModalTitle");
    const humanNameInput = document.getElementById("humanName");
    const currentStreakElem = document.getElementById("currentStreakDisplay");
    const bestStreakElem = document.getElementById("bestStreakDisplay");
    const applyHumanNameBtn = document.getElementById("applyHumanName");
    const nameSelectionModal = document.getElementById("nameSelectionModal");
    const nameSelectionInput = document.getElementById("nameSelectionInput");
    const nameSelectionPassword = document.getElementById("nameSelectionPassword");
    const nameSelectionMessage = document.getElementById("nameSelectionMessage");
    const nameSelectionWarning = document.getElementById("nameSelectionWarning");
    const nameSelectionPasswordSection = document.getElementById("nameSelectionPasswordSection");
    const nameSelectionButtons = document.getElementById("nameSelectionButtons");
    const nameSelectionStartBtn = document.getElementById("nameSelectionStartBtn");
    const nameSelectionRegisterBtn = document.getElementById("nameSelectionRegisterBtn");
    const nameSelectionLoginBtn = document.getElementById("nameSelectionLoginBtn");
    
    let nameCheckTimeout = null;
    
    const registerModal = document.getElementById("registerModal");
    const registerModalContent = document.getElementById("registerModalContent");
    const registerModalTitle = document.getElementById("registerModalTitle");
    const registerModalMessage = document.getElementById("registerModalMessage");
    const registerPassword = document.getElementById("registerPassword");
    const registerConfirmBtn = document.getElementById("registerConfirmBtn");
    const registerCancelBtn = document.getElementById("registerCancelBtn");
    const registerSkipBtn = document.getElementById("registerSkipBtn");
    const roomModal = document.getElementById("roomModal");
    const roomModalContent = document.getElementById("roomModalContent");
    const roomModalTitle = document.getElementById("roomModalTitle");
    const roomModalBody = document.getElementById("roomModalBody");
    const createRoomBtn = document.getElementById("createRoomBtn");
    const joinRoomBtn = document.getElementById("joinRoomBtn");
    const quickMatchBtn = document.getElementById("quickMatchBtn");
    const roomIdSection = document.getElementById("roomIdSection");
    const roomIdDisplay = document.getElementById("roomIdDisplay");
    const copyRoomIdBtn = document.getElementById("copyRoomIdBtn");
    const waitingRoomSection = document.getElementById("waitingRoomSection");
    const roomPlayer1 = document.getElementById("roomPlayer1");
    const roomPlayer2 = document.getElementById("roomPlayer2");
    const joinRoomSection = document.getElementById("joinRoomSection");
    const joinRoomIdInput = document.getElementById("joinRoomIdInput");
    const joinRoomConfirmBtn = document.getElementById("joinRoomConfirmBtn");
    const roomModalClose = document.getElementById("roomModalClose");
    const leaderboardBtn = document.getElementById("leaderboardBtn");
    const modeToggleSwitch = document.getElementById("modeToggleSwitch");
    const modeToggleSwitchMultiplayer = document.getElementById("modeToggleSwitchMultiplayer");
    const multiplayerScoreBar = document.getElementById("multiplayer-score-bar");
    const forfeitModal = document.getElementById("forfeitModal");
    const forfeitModalMessage = document.getElementById("forfeitModalMessage");
    const forfeitContinueBtn = document.getElementById("forfeitContinueBtn");
    const forfeitConfirmBtn = document.getElementById("forfeitConfirmBtn");
    const playAgainModal = document.getElementById("playAgainModal");
    const playAgainStartBtn = document.getElementById("playAgainStartBtn");

    let pendingName = "";
    let isLoginMode = false;

    async function hashPassword(password) {
      const encoder = new TextEncoder();
      const data = encoder.encode(password);
      const hashBuffer = await crypto.subtle.digest("SHA-256", data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
    }

    async function checkNameRegistered(name) {
      if (!firebaseInitialized || !db) return false;
      if (!name || !name.trim()) return false;
      try {
        const nameLower = name.toLowerCase().trim();
        if (!nameLower) return false;
        const doc = await db.collection("registeredNames").doc(nameLower).get();
        return doc.exists;
      } catch (error) {
        console.error("Error checking name:", error);
        return false;
      }
    }

    async function registerName(name, password) {
      if (!firebaseInitialized || !db) {
        alert("Registration requires Firebase. Please configure Firebase to use this feature.");
        return false;
      }
      try {
        const nameLower = name.toLowerCase();
        const passwordHash = await hashPassword(password);
        await db.collection("registeredNames").doc(nameLower).set({
          name: name,
          passwordHash: passwordHash,
          createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        return true;
      } catch (error) {
        console.error("Error registering name:", error);
        alert("Failed to register name. Please try again.");
        return false;
      }
    }

    async function verifyPassword(name, password) {
      if (!firebaseInitialized || !db) return false;
      try {
        const nameLower = name.toLowerCase();
        const doc = await db.collection("registeredNames").doc(nameLower).get();
        if (!doc.exists) return false;
        const passwordHash = await hashPassword(password);
        return doc.data().passwordHash === passwordHash;
      } catch (error) {
        console.error("Error verifying password:", error);
        return false;
      }
    }

    function showRegisterModal(name, isLogin = false) {
      pendingName = name;
      isLoginMode = isLogin;
      registerModalTitle.textContent = isLogin ? "Login" : "Register Name";
      registerModalMessage.textContent = isLogin
        ? `The name "${name}" is already registered. Enter password to play.`
        : `Register "${name}" with a password to protect it.`;
      registerPassword.value = "";
      registerPassword.focus();
      registerSkipBtn.style.display = "none";
      registerModal.classList.add("show");
    }

    function showNameSelectionModal() {
      nameSelectionModal.classList.add("show");
      nameSelectionInput.value = "";
      nameSelectionPassword.value = "";
      nameSelectionPasswordSection.style.display = "none";
      nameSelectionWarning.style.display = "none";
      nameSelectionMessage.textContent = "Enter your name to start playing (minimum 3 characters)";
      nameSelectionMessage.style.color = "var(--text-secondary)";
      nameSelectionStartBtn.style.display = "none";
      nameSelectionRegisterBtn.style.display = "none";
      nameSelectionLoginBtn.style.display = "none";
      setTimeout(() => {
        nameSelectionInput.focus();
      }, 100);
    }

    function hideNameSelectionModal() {
      nameSelectionModal.classList.remove("show");
      nameSelectionInput.value = "";
      nameSelectionPassword.value = "";
      nameSelectionPasswordSection.style.display = "none";
      nameSelectionWarning.style.display = "none";
      if (nameCheckTimeout) {
        clearTimeout(nameCheckTimeout);
        nameCheckTimeout = null;
      }
    }

    async function checkNameAndUpdateModal() {
      const name = nameSelectionInput.value.trim();
      
      // Validate minimum length
      if (name.length < 3) {
        nameSelectionPasswordSection.style.display = "none";
        nameSelectionWarning.style.display = "none";
        nameSelectionStartBtn.style.display = "none";
        nameSelectionRegisterBtn.style.display = "none";
        nameSelectionLoginBtn.style.display = "none";
        if (name.length > 0) {
          nameSelectionMessage.textContent = "Name must be at least 3 characters long";
          nameSelectionMessage.style.color = "#dc2626";
        } else {
          nameSelectionMessage.textContent = "Enter your name to start playing (minimum 3 characters)";
          nameSelectionMessage.style.color = "var(--text-secondary)";
        }
        return;
      }
      
      nameSelectionMessage.style.color = "var(--text-secondary)";
      
      // Check if name is registered
      if (firebaseInitialized && db) {
        const isRegistered = await checkNameRegistered(name);
        if (isRegistered) {
          // Name is registered - show password field and login button (NO warning)
          nameSelectionPasswordSection.style.display = "block";
          nameSelectionWarning.style.display = "none";
          nameSelectionStartBtn.style.display = "none";
          nameSelectionRegisterBtn.style.display = "none";
          nameSelectionLoginBtn.style.display = "block";
          nameSelectionMessage.textContent = `"${name}" is already registered. Enter password to login, or choose a different name.`;
          setTimeout(() => {
            nameSelectionPassword.focus();
          }, 100);
        } else {
          // Name is not registered - show play and register options WITH warning
          nameSelectionPasswordSection.style.display = "none";
          nameSelectionWarning.style.display = "block";
          nameSelectionStartBtn.style.display = "block";
          nameSelectionRegisterBtn.style.display = "block";
          nameSelectionLoginBtn.style.display = "none";
          nameSelectionStartBtn.textContent = "Play without registering";
          nameSelectionMessage.textContent = `"${name}" is available. Choose to play now or register it.`;
        }
      } else {
        // Firebase not configured - just show play button (NO warning)
        nameSelectionPasswordSection.style.display = "none";
        nameSelectionWarning.style.display = "none";
        nameSelectionStartBtn.style.display = "block";
        nameSelectionRegisterBtn.style.display = "none";
        nameSelectionLoginBtn.style.display = "none";
        nameSelectionStartBtn.textContent = "Play without registering";
        nameSelectionMessage.textContent = "Enter your name to start playing (minimum 3 characters)";
      }
    }

    function hideRegisterModal() {
      registerModal.classList.remove("show");
      pendingName = "";
      registerPassword.value = "";
    }

    function escapeHtml(str) {
      const div = document.createElement("div");
      div.textContent = str;
      return div.innerHTML;
    }

    function setStatusWithMark(name, player, suffix) {
      const cls = player === "X" ? "mark-X" : "mark-O";
      statusElem.innerHTML = escapeHtml(name) + ` (<span class="${cls}">${player}</span>)${suffix}`;
    }

    let board;
    let currentPlayer;
    let gameOver;
    let gameStarted = false; // Track if a game has been started
    let humanPlayer;
    let computerPlayer;
    let nextHumanPlayer = "X"; // alternates between X and O each game
    let computerThinking = false;
    let computerMoveTimeoutId = null;
    let currentStreak = 0;
    let bestStreak = 0;
    let bestStreakName = "";
    let soundEnabled = true;
    let currentPlayerName = "";
    let gameMode = "training"; // "training" or "multiplayer"
    let currentRoomId = null;
    let roomListener = null;
    let isPlayer1 = false;
    let matchGameNumber = 0; // 0 = first game, 1 = second game
    let matchResults = { player1Wins: 0, draws: 0, player2Wins: 0 };
    let opponentName = "";
    let myMarkInMatch = "X"; // X in first game, O in second game
    let player1Name = "";
    let player2Name = "";
    let currentMatchScore = { player1: 0, player2: 0 };
    let loadingDotsInterval = null;
    
    // Statistics
    let currentPlayerStats = {
      gamesPlayed: 0,
      wins: 0,
      losses: 0,
      draws: 0
    };
    
    let globalStats = {
      gamesPlayed: 0,
      wins: 0,
      losses: 0,
      draws: 0
    };

    // Achievements
    const achievements = {
      firstWin: { id: "firstWin", name: "First Win", description: "Win your first game", icon: "", unlocked: false },
      perfectGame: { id: "perfectGame", name: "Perfect Game", description: "Win without opponent getting 4 in a row", icon: "", unlocked: false },
      comebackKing: { id: "comebackKing", name: "Comeback King", description: "Win after opponent had 4 in a row", icon: "", unlocked: false },
      streakMaster: { id: "streakMaster", name: "Streak Master", description: "Reach 5+ win streak", icon: "", unlocked: false },
      speedDemon: { id: "speedDemon", name: "Speed Demon", description: "Win in under 20 moves", icon: "", unlocked: false },
      defender: { id: "defender", name: "Defender", description: "Block 3+ winning attempts in one game", icon: "", unlocked: false },
      centurion: { id: "centurion", name: "Centurion", description: "Play 100 games", icon: "", unlocked: false },
      unstoppable: { id: "unstoppable", name: "Unstoppable", description: "Win 10 games in a row", icon: "", unlocked: false }
    };

    // Game state for achievement tracking
    let gameState = {
      moveCount: 0,
      blocksThisGame: 0,
      opponentMaxInRow: 0,
      opponentHad4InRow: false,
      playerHad4InRow: false
    };

    let lastGameResultText = ""; // For sharing game result

    function createEmptyBoard() {
      return Array.from({ length: BOARD_SIZE }, () =>
        Array.from({ length: BOARD_SIZE }, () => "")
      );
    }

    function initBoardUI() {
      boardElem.innerHTML = "";
      // Grid sizing is handled by CSS for responsiveness

      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.addEventListener("click", onCellClick);
          cell.addEventListener("mouseenter", onCellMouseEnter);
          cell.addEventListener("mouseleave", onCellMouseLeave);
          boardElem.appendChild(cell);
        }
      }
    }

    function clearHighlights() {
      document
        .querySelectorAll(".cell.last-move, .cell.win")
        .forEach(cell => {
          cell.classList.remove("last-move", "win");
        });
      // Also clear all preview classes
      document
        .querySelectorAll(".cell.preview-X, .cell.preview-O")
        .forEach(cell => {
          cell.classList.remove("preview-X", "preview-O");
          delete cell.dataset.preview;
        });
    }

    function onCellClick(e) {
      // Don't allow clicks if computer is thinking
      if (computerThinking) return;
      
      // Allow clicks when game hasn't started (to start the game)
      // Only block clicks if game has started AND (game is over OR computer is thinking)
      if (gameStarted && gameOver) return;
      
      // Clear preview classes when clicking
      const cell = e.currentTarget;
      cell.classList.remove("preview-X", "preview-O");
      delete cell.dataset.preview;

      // Allow clicks if:
      // 1. Game has started and it's human's turn, OR
      // 2. Game hasn't started yet but human goes first (currentPlayer === humanPlayer)
      if (!gameStarted && currentPlayer !== humanPlayer) return;
      if (gameStarted && currentPlayer !== humanPlayer) return;
      if (!hasHumanName()) return;

      const r = parseInt(cell.dataset.row, 10);
      const c = parseInt(cell.dataset.col, 10);

      if (board[r][c] !== "") {
        return;
      }

      // If game hasn't started yet and human goes first, start it now
      if (!gameStarted && currentPlayer === humanPlayer) {
        gameStarted = true;
        updateRestartButtonText();
        setStatusForTurn();
      }

      handleMove(r, c, false);
    }

    function onCellMouseEnter(e) {
      const cell = e.currentTarget;
      const r = parseInt(cell.dataset.row, 10);
      const c = parseInt(cell.dataset.col, 10);
      
      // Allow preview if:
      // 1. Game hasn't started yet AND human goes first (currentPlayer === humanPlayer), OR
      // 2. Game has started AND it's human's turn AND game not over
      const canPreview = (!gameStarted && currentPlayer === humanPlayer) || 
                         (gameStarted && !gameOver && currentPlayer === humanPlayer);
      
      if (!board || board[r][c] !== "" || gameOver || !canPreview || computerThinking || !hasHumanName()) return;
      if (gameMode === "multiplayer" && currentPlayer !== humanPlayer) return;
      
      const cls = humanPlayer === "X" ? "preview-X" : "preview-O";
      cell.classList.add(cls);
      cell.dataset.preview = humanPlayer;
    }

    function onCellMouseLeave(e) {
      const cell = e.currentTarget;
      cell.classList.remove("preview-X", "preview-O");
      delete cell.dataset.preview;
    }

    function getHumanDisplayName() {
      const raw = humanNameInput.value.trim();
      return raw || "You";
    }

    function getComputerDisplayName() {
      return "Computer";
    }

    function hasHumanName() {
      return humanNameInput.value.trim().length > 0;
    }

    async function handleMove(r, c, isComputer) {
      if (gameOver || !gameStarted) return;
      
      // In multiplayer mode, only allow moves for current player
      if (gameMode === "multiplayer" && !isComputer) {
        if (currentPlayer !== humanPlayer) {
          return; // Not your turn
        }
        if (!currentRoomId) {
          return; // Not in a room
        }
      }

      // Track if this is a blocking move (check before placing)
      if (isComputer && currentPlayer === computerPlayer) {
        // Check if computer is blocking human's potential win
        if (checkIfBlockingMove(board, r, c, humanPlayer)) {
          gameState.blocksThisGame++;
        }
      }

      board[r][c] = currentPlayer;
      gameState.moveCount++;

      // Track max line lengths
      if (isComputer) {
        const computerMax = getMaxLineLength(board, computerPlayer);
        gameState.opponentMaxInRow = Math.max(gameState.opponentMaxInRow, computerMax);
        if (computerMax >= 4) {
          gameState.opponentHad4InRow = true;
        }
      } else {
        const humanMax = getMaxLineLength(board, humanPlayer);
        if (humanMax >= 4) {
          gameState.playerHad4InRow = true;
        }
      }

      clearHighlights();
      const allCells = document.querySelectorAll(".cell");
      allCells.forEach(cell => {
        if (!cell.classList.contains("win")) {
          cell.classList.remove("last-move");
        }
        // Clear preview classes from all cells
        cell.classList.remove("preview-X", "preview-O");
        delete cell.dataset.preview;
      });

      const cell = document.querySelector(
        `.cell[data-row="${r}"][data-col="${c}"]`
      );
      if (cell) {
        // Capture the player value before any async operations
        const playerToDisplay = currentPlayer;
        
        // Clear any existing content, classes, and preview classes
        cell.textContent = "";
        cell.classList.remove("X", "O", "last-move", "placing", "preview-X", "preview-O");
        delete cell.dataset.preview;
        
        // Set content and class immediately
        cell.textContent = playerToDisplay;
        cell.classList.add(playerToDisplay, "last-move");
        
        // Force a reflow to ensure DOM is updated
        void cell.offsetHeight;
        
        // Add placing class to trigger animation
        cell.classList.add("placing");
        
        // Remove placing class after animation completes
        setTimeout(() => {
          cell.classList.remove("placing");
        }, 400);
        
        // Play placement sound
        playSound("place");
      }

      const winLine = getWinningLine(board, r, c, currentPlayer);
      if (winLine) {
        gameOver = true;
        highlightWinningLine(winLine);
        
        if (gameMode === "multiplayer") {
          // Multiplayer win handling
          const winner = currentPlayer;
          await handleMultiplayerGameEnd(winner, null);
        } else {
          // Training mode win handling
          currentPlayerStats.gamesPlayed++;
          globalStats.gamesPlayed++;
          
          if (isComputer) {
            setStatusWithMark(getComputerDisplayName(), currentPlayer, " wins!");
            statusRow.className = "status-neutral";
            lastGameResultText = `I just lost in 5-in-a-Row. My streak was ${currentStreak}. Can you do better?`;
            currentStreak = 0;
            currentPlayerStats.losses++;
            globalStats.losses++;
            playSound("aw");
          } else {
            const winnerName = getHumanDisplayName();
            setStatusWithMark(winnerName, currentPlayer, " wins!");
            statusRow.className = "status-neutral";
            currentStreak += 1;
            currentPlayerStats.wins++;
            globalStats.wins++;
            if (currentStreak > bestStreak) {
              bestStreak = currentStreak;
              bestStreakName = winnerName;
              saveBestStreak();
            }
            playSound("applause");
            createConfetti();
            lastGameResultText = `I just won in 5-in-a-Row! Streak: ${currentStreak}. Try to beat me!`;
            checkWinAchievements();
          }
          checkAchievements();
          saveStats();
          if (gameMode === "training") {
            updateStreakDisplays();
          }
          shareGameResultBtn.classList.add("visible");
          computerThinking = false;
          resetGameState();
          clearGameState(); // Clear saved game state when game ends
        }
        return;
      }

      if (boardFull(board)) {
        gameOver = true;
        
        if (gameMode === "multiplayer") {
          // Multiplayer draw handling
          await handleMultiplayerGameEnd(null, "draw");
        } else {
          // Training mode draw handling
          currentPlayerStats.gamesPlayed++;
          currentPlayerStats.draws++;
          globalStats.gamesPlayed++;
          globalStats.draws++;
          statusElem.textContent = "It's a draw!";
          statusRow.className = "status-neutral";
          playSound("draw");
          lastGameResultText = `I just played a draw in 5-in-a-Row. Streak: ${currentStreak}. Give it a try!`;
          checkAchievements();
          saveStats();
          shareGameResultBtn.classList.add("visible");
          computerThinking = false;
          resetGameState();
          clearGameState(); // Clear saved game state when game ends
        }
        return;
      }

      // Switch turns
      currentPlayer = currentPlayer === "X" ? "O" : "X";

      // In multiplayer mode, sync to Firestore
      if (gameMode === "multiplayer" && currentRoomId && firebaseInitialized && db) {
        await syncMoveToFirestore(r, c);
        return; // Don't continue with computer move logic
      }

      // Decide whose turn it is next and update status with names (training mode)
      if (currentPlayer === humanPlayer) {
        const name = getHumanDisplayName();
        setStatusWithMark(name, currentPlayer, "  your turn");
        statusRow.className = "status-your-turn";
        computerThinking = false;
      } else {
        setStatusWithMark(getComputerDisplayName(), currentPlayer, " is thinking...");
        statusRow.className = "status-computer-turn";
        computerThinking = true;
        // 1 second delay before computer moves
        if (computerMoveTimeoutId !== null) {
          clearTimeout(computerMoveTimeoutId);
        }
        computerMoveTimeoutId = setTimeout(computerMove, 1000);
      }
      
      // Save game state after move (for forfeit detection on refresh)
      saveGameState();
    }

    async function syncMoveToFirestore(r, c) {
      if (!currentRoomId || !firebaseInitialized || !db) return;

      try {
        const roomRef = db.collection("gameRooms").doc(currentRoomId);
        const winner = gameOver ? (currentPlayer === humanPlayer ? humanPlayer : computerPlayer) : null;
        await roomRef.update({
          board: board,
          currentPlayer: currentPlayer,
          gameOver: gameOver,
          winner: winner,
          lastMove: firebase.firestore.FieldValue.serverTimestamp()
        });
      } catch (error) {
        console.error("Error syncing move:", error);
      }
    }

    function computerMove() {
      if (gameOver) {
        computerThinking = false;
        return;
      }

      // Don't let computer move if game hasn't started yet (waiting for player confirmation)
      if (!gameStarted) {
        computerThinking = false;
        return;
      }

      // Don't let computer move if human name not set yet
      if (!hasHumanName()) {
        computerThinking = false;
        return;
      }

      const moves = [];
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          if (board[r][c] === "") {
            moves.push([r, c]);
          }
        }
      }

      if (moves.length === 0) {
        computerThinking = false;
        return;
      }

      // First, always take immediate wins if available
      for (const [r, c] of moves) {
        board[r][c] = computerPlayer;
        const winNow = getWinningLine(board, r, c, computerPlayer);
        board[r][c] = "";
        if (winNow) {
          handleMove(r, c, true);
          return;
        }
      }

      // Then, always block immediate human wins if possible
      for (const [r, c] of moves) {
        board[r][c] = humanPlayer;
        const humanWin = getWinningLine(board, r, c, humanPlayer);
        board[r][c] = "";
        if (humanWin) {
          handleMove(r, c, true);
          return;
        }
      }

      let bestScore = -Infinity;
      let bestMoves = [];
      for (const [r, c] of moves) {
        const score = scoreMove(r, c);
        if (score > bestScore) {
          bestScore = score;
          bestMoves = [[r, c]];
        } else if (score === bestScore) {
          bestMoves.push([r, c]);
        }
      }

      // Maximum difficulty: always choose the strongest move
      const [r, c] = bestMoves[Math.floor(Math.random() * bestMoves.length)];
      handleMove(r, c, true);
    }

    function inBounds(r, c) {
      return r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE;
    }

    function collectLine(board, r, c, dr, dc, player) {
      const cells = [[r, c]];

      let nr = r + dr;
      let nc = c + dc;
      while (inBounds(nr, nc) && board[nr][nc] === player) {
        cells.push([nr, nc]);
        nr += dr;
        nc += dc;
      }

      nr = r - dr;
      nc = c - dc;
      while (inBounds(nr, nc) && board[nr][nc] === player) {
        cells.unshift([nr, nc]);
        nr -= dr;
        nc -= dc;
      }

      return cells;
    }

    function getWinningLine(board, r, c, player) {
      const directions = [
        [0, 1],  // horizontal
        [1, 0],  // vertical
        [1, 1],  // diagonal down-right
        [1, -1], // diagonal down-left
      ];

      for (const [dr, dc] of directions) {
        const cells = collectLine(board, r, c, dr, dc, player);
        if (cells.length >= WIN_LENGTH) {
          // limit to exactly WIN_LENGTH contiguous cells around last move
          // (purely visual; game already won)
          return cells.slice(0, WIN_LENGTH);
        }
      }
      return null;
    }

    function highlightWinningLine(cells) {
      cells.forEach(([r, c]) => {
        const cell = document.querySelector(
          `.cell[data-row="${r}"][data-col="${c}"]`
        );
        if (cell) {
          cell.classList.add("win");
        }
      });
    }

    function boardFull(board) {
      return board.every(row => row.every(cell => cell !== ""));
    }

    // ---- Achievement helpers ----

    function getMaxLineLength(board, player) {
      let maxLength = 0;
      const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];

      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          if (board[r][c] === player) {
            for (const [dr, dc] of directions) {
              const length = collectLine(board, r, c, dr, dc, player).length;
              maxLength = Math.max(maxLength, length);
            }
          }
        }
      }
      return maxLength;
    }

    function checkIfBlockingMove(board, r, c, threatenedPlayer) {
      // Check if placing threatenedPlayer's piece here would create a win
      // This means the current move is blocking that win
      if (board[r][c] !== "") return false;
      
      board[r][c] = threatenedPlayer;
      const wouldWin = getWinningLine(board, r, c, threatenedPlayer) !== null;
      board[r][c] = "";
      
      return wouldWin;
    }

    function resetGameState() {
      gameState = {
        moveCount: 0,
        blocksThisGame: 0,
        opponentMaxInRow: 0,
        opponentHad4InRow: false,
        playerHad4InRow: false
      };
    }

    // ---- Game State Persistence (for forfeit detection) ----
    
    function saveGameState() {
      // Only save in training mode and if game is not over
      if (gameMode !== "training" || gameOver) {
        clearGameState();
        return;
      }
      
      // Don't save if board is not initialized or empty (no moves made yet)
      if (!board || !Array.isArray(board)) {
        clearGameState();
        return;
      }
      
      const hasMoves = board.some(row => row.some(cell => cell !== ""));
      if (!hasMoves) {
        clearGameState();
        return;
      }
      
      try {
        const gameStateToSave = {
          board: board,
          currentPlayer: currentPlayer,
          gameOver: gameOver,
          humanPlayer: humanPlayer,
          computerPlayer: computerPlayer,
          gameState: gameState,
          playerName: currentPlayerName || humanNameInput.value.trim()
        };
        localStorage.setItem("tictac9x9_activeGame", JSON.stringify(gameStateToSave));
      } catch (e) {
        // ignore storage errors
      }
    }
    
    function loadGameState() {
      try {
        const saved = localStorage.getItem("tictac9x9_activeGame");
        if (!saved) return null;
        const data = JSON.parse(saved);
        
        // Validate saved data
        if (!data.board || !Array.isArray(data.board) || 
            !data.currentPlayer || !data.humanPlayer || !data.computerPlayer) {
          return null;
        }
        
        return data;
      } catch (e) {
        return null;
      }
    }
    
    function clearGameState() {
      try {
        localStorage.removeItem("tictac9x9_activeGame");
      } catch (e) {
        // ignore errors
      }
    }
    
    function restoreGameState(savedState) {
      if (!savedState) return false;
      
      board = savedState.board;
      currentPlayer = savedState.currentPlayer;
      gameOver = savedState.gameOver || false;
      humanPlayer = savedState.humanPlayer;
      computerPlayer = savedState.computerPlayer;
      gameStarted = true; // Game was started if we're restoring state
      gameState = savedState.gameState || {
        moveCount: 0,
        blocksThisGame: 0,
        opponentMaxInRow: 0,
        opponentHad4InRow: false,
        playerHad4InRow: false
      };
      
      // Restore UI
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
          if (cell) {
            cell.textContent = board[r][c] || "";
            cell.classList.remove("X", "O", "last-move", "win");
            if (board[r][c]) {
              cell.classList.add(board[r][c]);
            }
          }
        }
      }
      
      // Update button text since game is started
      updateRestartButtonText();
      
      // Update status
      if (gameOver) {
        statusElem.textContent = "Game over";
        statusRow.className = "status-neutral";
      } else {
        setStatusForTurn();
        // If it's computer's turn, trigger computer move
        if (currentPlayer === computerPlayer && !gameOver) {
          computerThinking = true;
          if (computerMoveTimeoutId !== null) {
            clearTimeout(computerMoveTimeoutId);
          }
          computerMoveTimeoutId = setTimeout(computerMove, 1000);
        }
      }
      
      return true;
    }
    
    async function handleForfeit() {
      // Count forfeit as loss
      currentPlayerStats.gamesPlayed++;
      currentPlayerStats.losses++;
      globalStats.gamesPlayed++;
      globalStats.losses++;

      // Reset streak
      currentStreak = 0;

      // Update status
      setStatusWithMark(getComputerDisplayName(), computerPlayer, " wins! (Forfeit)");
      statusRow.className = "status-neutral";
      playSound("aw");

      // Save stats
      await saveStats();

      // Update displays
      if (gameMode === "training") {
        updateStreakDisplays();
      }
      updateStatsDisplay();

      // Clear saved game state
      clearGameState();
      
      // Reset game started flag
      gameStarted = false;
      updateRestartButtonText();

      // Don't automatically start new round here - let the caller decide
      // (for restart action, we'll start new round after forfeit)
    }
    
    function showForfeitModal(action = "") {
      // Set message based on action
      if (action === "restart") {
        forfeitModalMessage.textContent = "You have an active game. Restarting will count as a forfeit (loss).";
      } else {
        forfeitModalMessage.textContent = "You have an active game. Closing or refreshing the page will count as a forfeit (loss).";
      }
      forfeitModal.dataset.action = action;
      forfeitModal.classList.add("show");
    }
    
    function hideForfeitModal() {
      forfeitModal.classList.remove("show");
    }

    function showPlayAgainModal() {
      playAgainModal.classList.add("show");
    }
    
    function hidePlayAgainModal() {
      playAgainModal.classList.remove("show");
    }

    function startGameWithComputerFirst() {
      // Hide the modal
      hidePlayAgainModal();
      
      // Start the game
      gameStarted = true;
      updateRestartButtonText();
      
      // Update status
      setStatusForTurn();
      
      // Trigger computer's first move after a short delay
      if (currentPlayer === computerPlayer && !gameOver) {
        computerThinking = true;
        if (computerMoveTimeoutId !== null) {
          clearTimeout(computerMoveTimeoutId);
        }
        computerMoveTimeoutId = setTimeout(computerMove, 1000);
      }
    }

    // ---- Sound Effects ----

    function playSound(type) {
      if (!soundEnabled) return;

      const audioContext = new (window.AudioContext || window.webkitAudioContext)();

      if (type === "applause") {
        // Create a pleasant triumphant fanfare - ascending chord sequence
        const notes = [
          { freq: 523.25, delay: 0.0, duration: 0.15 },   // C5
          { freq: 659.25, delay: 0.1, duration: 0.15 },   // E5
          { freq: 783.99, delay: 0.2, duration: 0.15 },   // G5
          { freq: 1046.50, delay: 0.3, duration: 0.25 },  // C6
        ];
        
        notes.forEach((note, index) => {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          oscillator.frequency.value = note.freq;
          oscillator.type = "sine";
          
          const volume = 0.25;
          const startTime = audioContext.currentTime + note.delay;
          
          gainNode.gain.setValueAtTime(0, startTime);
          gainNode.gain.linearRampToValueAtTime(volume, startTime + 0.02);
          gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + note.duration);
          
          oscillator.start(startTime);
          oscillator.stop(startTime + note.duration);
        });
        return;
      }

      if (type === "aw") {
        // Create disappointed "aw" sound - descending tone
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.type = "sawtooth";
        oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.5);
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.5);
        return;
      }

      // Regular sounds
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      let frequency, duration, volume;

      switch (type) {
        case "place":
          frequency = 440;
          duration = 0.1;
          volume = 0.3;
          break;
        case "win":
          frequency = 523.25; // C5
          duration = 0.3;
          volume = 0.5;
          break;
        case "lose":
          frequency = 220;
          duration = 0.4;
          volume = 0.4;
          break;
        case "draw":
          frequency = 330;
          duration = 0.25;
          volume = 0.3;
          break;
        default:
          return;
      }

      oscillator.frequency.value = frequency;
      oscillator.type = "sine";

      gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + duration);
    }

    function toggleSound() {
      soundEnabled = !soundEnabled;
      soundToggleBtn.classList.toggle("muted", !soundEnabled);
      localStorage.setItem("tictac9x9_sound", soundEnabled);
    }

    // ---- Confetti Animation ----

    function createConfetti() {
      const colors = ["#ffd700", "#ff6b6b", "#4ecdc4", "#45b7d1", "#f9ca24", "#f0932b", "#eb4d4b", "#6c5ce7"];
      const confettiCount = 100;

      for (let i = 0; i < confettiCount; i++) {
        const confetti = document.createElement("div");
        confetti.className = "confetti";
        confetti.style.left = Math.random() * 100 + "%";
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDuration = (Math.random() * 3 + 2) + "s";
        confetti.style.animationDelay = Math.random() * 0.5 + "s";
        confetti.style.opacity = "1";
        confettiContainer.appendChild(confetti);

        setTimeout(() => {
          confetti.remove();
        }, 5000);
      }
    }

    // ---- Statistics ----

    async function loadPlayerStats(name) {
      if (!firebaseInitialized || !db) {
        console.log("Cannot load stats: Firebase not initialized");
        return false;
      }
      if (!name || !name.trim()) return false;
      try {
        const nameLower = name.toLowerCase().trim();
        if (!nameLower) return false;
        const doc = await db.collection("playerStats").doc(nameLower).get();
        if (doc.exists) {
          const data = doc.data();
          currentPlayerStats = {
            gamesPlayed: data.gamesPlayed || 0,
            wins: data.wins || 0,
            losses: data.losses || 0,
            draws: data.draws || 0
          };
          // Don't restore currentStreak - it resets on page refresh
          // currentStreak is always reset to 0 in init()
          return true;
        }
      } catch (error) {
        console.error("Error loading player stats:", error);
      }
      return false;
    }

    async function savePlayerStats(name) {
      if (!firebaseInitialized || !db) return;
      if (!name || !name.trim()) return;
      try {
        const nameLower = name.toLowerCase().trim();
        if (!nameLower) return;
        const existingDoc = await db.collection("playerStats").doc(nameLower).get();
        const existingBestStreak = existingDoc.exists ? (existingDoc.data().bestStreak || 0) : 0;
        const newBestStreak = Math.max(currentStreak, existingBestStreak);
        
        const statsToSave = {
          name: name,
          gamesPlayed: currentPlayerStats.gamesPlayed,
          wins: currentPlayerStats.wins,
          losses: currentPlayerStats.losses,
          draws: currentPlayerStats.draws,
          currentStreak: currentStreak,
          bestStreak: newBestStreak,
          lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
        };
        
        await db.collection("playerStats").doc(nameLower).set(statsToSave, { merge: true });
      } catch (error) {
        console.error("Error saving player stats:", error);
      }
    }

    async function loadGlobalStats() {
      if (!firebaseInitialized || !db) {
        // Fallback to localStorage if Firebase not available
        try {
          const savedGlobal = localStorage.getItem("tictac9x9_global_stats");
          if (savedGlobal) {
            globalStats = JSON.parse(savedGlobal);
          }
        } catch (e) {
          // ignore errors
        }
        return;
      }
      
      try {
        const doc = await db.collection("globalStats").doc("allPlayers").get();
        if (doc.exists) {
          const data = doc.data();
          globalStats = {
            gamesPlayed: data.gamesPlayed || 0,
            wins: data.wins || 0,
            losses: data.losses || 0,
            draws: data.draws || 0
          };
        }
      } catch (error) {
        console.error("Error loading global stats:", error);
        // Fallback to localStorage
        try {
          const savedGlobal = localStorage.getItem("tictac9x9_global_stats");
          if (savedGlobal) {
            globalStats = JSON.parse(savedGlobal);
          }
        } catch (e) {
          // ignore errors
        }
      }
    }

    async function saveGlobalStats() {
      if (!firebaseInitialized || !db) {
        // Fallback to localStorage if Firebase not available
        try {
          localStorage.setItem("tictac9x9_global_stats", JSON.stringify(globalStats));
        } catch (e) {
          // ignore errors
        }
        return;
      }
      
      try {
        await db.collection("globalStats").doc("allPlayers").set({
          gamesPlayed: globalStats.gamesPlayed,
          wins: globalStats.wins,
          losses: globalStats.losses,
          draws: globalStats.draws,
          lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });
        
        // Also save to localStorage as backup
        try {
          localStorage.setItem("tictac9x9_global_stats", JSON.stringify(globalStats));
        } catch (e) {
          // ignore errors
        }
      } catch (error) {
        console.error("Error saving global stats:", error);
        // Fallback to localStorage
        try {
          localStorage.setItem("tictac9x9_global_stats", JSON.stringify(globalStats));
        } catch (e) {
          // ignore errors
        }
      }
    }

    function loadStats() {
      // This function is kept for compatibility but now calls async version
      // It will be called from init() which is async
    }

    async function saveStats() {
      try {
        // Save global stats to Firestore (shared across all devices)
        await saveGlobalStats();
        
        // Get player name from variable or input field
        const playerName = currentPlayerName || humanNameInput.value.trim();
        
        // Save player stats to Firestore if user is registered
        if (playerName && firebaseInitialized && db) {
          const isRegistered = await checkNameRegistered(playerName);
          if (isRegistered) {
            await savePlayerStats(playerName);
          }
        }
      } catch (e) {
        console.error("Error in saveStats():", e);
      }
    }

    function updateStatsDisplay() {
      const currentName = getHumanDisplayName();
      document.getElementById("currentPlayerName").textContent = currentName;
      
      // Current player stats (left column)
      document.getElementById("statCurrentGamesPlayed").textContent = currentPlayerStats.gamesPlayed;
      document.getElementById("statCurrentWins").textContent = currentPlayerStats.wins;
      document.getElementById("statCurrentLosses").textContent = currentPlayerStats.losses;
      document.getElementById("statCurrentDraws").textContent = currentPlayerStats.draws;
      
      const currentWinRate = currentPlayerStats.gamesPlayed > 0 
        ? Math.round((currentPlayerStats.wins / currentPlayerStats.gamesPlayed) * 100) 
        : 0;
      document.getElementById("statCurrentWinRate").textContent = currentWinRate + "%";
      
      document.getElementById("statCurrentStreak").textContent = currentStreak;
      
      // Global stats (right column)
      document.getElementById("statGlobalGamesPlayed").textContent = globalStats.gamesPlayed;
      document.getElementById("statGlobalWins").textContent = globalStats.wins;
      document.getElementById("statGlobalLosses").textContent = globalStats.losses;
      document.getElementById("statGlobalDraws").textContent = globalStats.draws;
      
      const globalWinRate = globalStats.gamesPlayed > 0 
        ? Math.round((globalStats.wins / globalStats.gamesPlayed) * 100) 
        : 0;
      document.getElementById("statGlobalWinRate").textContent = globalWinRate + "%";
      
      const globalBestStreakDisplay = bestStreak > 0 && bestStreakName 
        ? `${bestStreak} (${bestStreakName})`
        : bestStreak;
      document.getElementById("statGlobalBestStreak").textContent = globalBestStreakDisplay;
    }

    function showStats() {
      updateStatsDisplay();
      statsModal.classList.add("show");
    }

    function hideStats() {
      statsModal.classList.remove("show");
    }

    // ---- Achievements ----

    function loadAchievements() {
      try {
        const saved = localStorage.getItem("tictac9x9_achievements");
        if (saved) {
          const savedAchievements = JSON.parse(saved);
          Object.keys(achievements).forEach(key => {
            if (savedAchievements[key] !== undefined) {
              achievements[key].unlocked = savedAchievements[key];
            }
          });
        }
      } catch (e) {
        // ignore errors
      }
    }

    function saveAchievements() {
      try {
        const toSave = {};
        Object.keys(achievements).forEach(key => {
          toSave[key] = achievements[key].unlocked;
        });
        localStorage.setItem("tictac9x9_achievements", JSON.stringify(toSave));
      } catch (e) {
        // ignore errors
      }
    }

    function checkAchievements() {
      const newlyUnlocked = [];

      // First Win
      if (!achievements.firstWin.unlocked && currentPlayerStats.wins >= 1) {
        achievements.firstWin.unlocked = true;
        newlyUnlocked.push(achievements.firstWin);
      }

      // Streak Master
      if (!achievements.streakMaster.unlocked && currentStreak >= 5) {
        achievements.streakMaster.unlocked = true;
        newlyUnlocked.push(achievements.streakMaster);
      }

      // Defender - checked after game
      if (!achievements.defender.unlocked && gameState.blocksThisGame >= 3) {
        achievements.defender.unlocked = true;
        newlyUnlocked.push(achievements.defender);
      }

      // Centurion
      if (!achievements.centurion.unlocked && currentPlayerStats.gamesPlayed >= 100) {
        achievements.centurion.unlocked = true;
        newlyUnlocked.push(achievements.centurion);
      }

      // Unstoppable
      if (!achievements.unstoppable.unlocked && currentStreak >= 10) {
        achievements.unstoppable.unlocked = true;
        newlyUnlocked.push(achievements.unstoppable);
      }

      // Show notifications for newly unlocked achievements
      newlyUnlocked.forEach(achievement => {
        showAchievementNotification(achievement);
      });

      if (newlyUnlocked.length > 0) {
        saveAchievements();
        updateAchievementsDisplay();
      }
    }

    function checkWinAchievements() {
      const newlyUnlocked = [];

      // Perfect Game - win without opponent getting 4 in a row
      if (!achievements.perfectGame.unlocked && gameState.opponentMaxInRow < 4) {
        achievements.perfectGame.unlocked = true;
        newlyUnlocked.push(achievements.perfectGame);
      }

      // Comeback King - win after opponent had 4 in a row
      if (!achievements.comebackKing.unlocked && gameState.opponentHad4InRow) {
        achievements.comebackKing.unlocked = true;
        newlyUnlocked.push(achievements.comebackKing);
      }

      // Speed Demon - win in under 20 moves
      if (!achievements.speedDemon.unlocked && gameState.moveCount < 20) {
        achievements.speedDemon.unlocked = true;
        newlyUnlocked.push(achievements.speedDemon);
      }

      newlyUnlocked.forEach(achievement => {
        showAchievementNotification(achievement);
      });

      if (newlyUnlocked.length > 0) {
        saveAchievements();
        updateAchievementsDisplay();
      }
    }

    function showAchievementNotification(achievement) {
      const notification = document.createElement("div");
      notification.className = "achievement-notification";
      notification.innerHTML = `
        <div class="achievement-notification-header">
          <span class="achievement-notification-icon">${achievement.icon}</span>
          <span class="achievement-notification-title">Achievement Unlocked!</span>
        </div>
        <div class="achievement-notification-desc">
          <strong>${achievement.name}</strong><br>${achievement.description}
        </div>
      `;
      document.body.appendChild(notification);

      setTimeout(() => {
        notification.style.animation = "slideInRight 0.5s ease-out reverse";
        setTimeout(() => {
          notification.remove();
        }, 500);
      }, 3000);
    }

    function updateAchievementsDisplay() {
      const unlockedCount = Object.values(achievements).filter(a => a.unlocked).length;
      document.getElementById("trophyUnlockedCount").textContent = unlockedCount;

      // Update achievements grid
      const trophyGrid = document.getElementById("trophyAchievementsGrid");
      trophyGrid.innerHTML = "";
      Object.values(achievements).forEach(achievement => {
        const item = createAchievementItem(achievement);
        trophyGrid.appendChild(item);
      });
    }

    function createAchievementItem(achievement) {
      const item = document.createElement("div");
      item.className = `achievement-item ${achievement.unlocked ? "unlocked" : "locked"}`;
      item.innerHTML = `
        <div class="achievement-icon">${achievement.icon}</div>
        <div class="achievement-name">${achievement.name}</div>
        <div class="achievement-desc">${achievement.description}</div>
      `;
      return item;
    }

    function showTrophyCabinet() {
      updateAchievementsDisplay();
      trophyModal.classList.add("show");
    }

    function hideTrophyCabinet() {
      trophyModal.classList.remove("show");
    }

    // ---- Share ----
    function getShareUrl() {
      return window.location.href || "";
    }

    async function openShare(text, url) {
      const shareUrl = url || getShareUrl();
      const fullText = text ? `${text} ${shareUrl}` : shareUrl;

      if (navigator.share) {
        try {
          await navigator.share({
            title: "5-in-a-Row",
            text: text || "Check out 5-in-a-Row!",
            url: shareUrl
          });
          return;
        } catch (err) {
          if (err.name === "AbortError") return;
        }
      }
      showShareFallback(text, shareUrl);
    }

    function showShareFallback(title, url) {
      const fullText = title ? `${title} ${url}` : url;
      shareModalTitle.textContent = "Share";
      shareButtons.innerHTML = "";

      const networks = [
        { name: "Twitter / X", icon: "", href: `https://twitter.com/intent/tweet?text=${encodeURIComponent(fullText)}` },
        { name: "Facebook", icon: "f", href: `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}` },
        { name: "WhatsApp", icon: "WhatsApp", href: `https://wa.me/?text=${encodeURIComponent(fullText)}` }
      ];

      networks.forEach(({ name, icon, href }) => {
        const a = document.createElement("a");
        a.href = href;
        a.target = "_blank";
        a.rel = "noopener noreferrer";
        a.textContent = `${icon} ${name}`;
        shareButtons.appendChild(a);
      });

      const copyBtn = document.createElement("button");
      copyBtn.type = "button";
      copyBtn.textContent = " Copy link";
      copyBtn.addEventListener("click", () => {
        navigator.clipboard.writeText(fullText).then(() => {
          copyBtn.textContent = " Copied!";
          setTimeout(() => { copyBtn.textContent = " Copy link"; }, 2000);
        });
      });
      shareButtons.appendChild(copyBtn);

      shareModal.classList.add("show");
    }

    function hideShareModal() {
      shareModal.classList.remove("show");
    }

    // ---- Streak helpers ----

    function updateStreakDisplays() {
      currentStreakElem.textContent = `Streak: ${currentStreak}`;
      if (bestStreak > 0 && bestStreakName) {
        bestStreakElem.textContent = `Best streak: ${bestStreak} (${bestStreakName})`;
      } else {
        bestStreakElem.textContent = "Best streak: none";
      }
    }

    async function saveBestStreak() {
      // Only save to Firebase if it's a new record
      if (firebaseInitialized && db && bestStreak > 0) {
        try {
          const recordRef = db.collection("globalBestStreak").doc("record");
          const doc = await recordRef.get();
          
          // Only update if this is a new record
          if (!doc.exists || doc.data().streak < bestStreak) {
            await recordRef.set({
              streak: bestStreak,
              name: bestStreakName,
              timestamp: firebase.firestore.FieldValue.serverTimestamp()
            });
            console.log("Global best streak updated in Firebase!");
          }
        } catch (error) {
          console.error("Error saving to Firebase:", error);
          // Fallback to localStorage
          saveBestStreakLocal();
        }
      } else {
        // Fallback to localStorage if Firebase not configured
        saveBestStreakLocal();
      }
    }

    function saveBestStreakLocal() {
      try {
        const data = { name: bestStreakName, streak: bestStreak };
        localStorage.setItem("tictac9x9_best_streak", JSON.stringify(data));
      } catch (e) {
        // ignore storage errors
      }
    }

    async function loadBestStreak() {
      if (firebaseInitialized && db) {
        try {
          const doc = await db.collection("globalBestStreak").doc("record").get();
          if (doc.exists) {
            const data = doc.data();
            if (data && typeof data.streak === "number" && typeof data.name === "string") {
              bestStreak = data.streak;
              bestStreakName = data.name;
              updateStreakDisplays();
              console.log("Global best streak loaded from Firebase:", data);
              return;
            }
          }
        } catch (error) {
          console.error("Error loading from Firebase:", error);
          // Fallback to localStorage
          loadBestStreakLocal();
        }
      } else {
        // Fallback to localStorage if Firebase not configured
        loadBestStreakLocal();
      }
    }

    function loadBestStreakLocal() {
      try {
        const raw = localStorage.getItem("tictac9x9_best_streak");
        if (!raw) return;
        const data = JSON.parse(raw);
        if (typeof data.streak === "number" && typeof data.name === "string") {
          bestStreak = data.streak;
          bestStreakName = data.name;
        }
      } catch (e) {
        // ignore parse errors
      }
    }

    // ---- AI evaluation helpers ----

    function simulateLineLength(r, c, player, dr, dc) {
      // Temporarily treat (r,c) as player's stone without mutating board
      let count = 1;

      let nr = r + dr;
      let nc = c + dc;
      while (inBounds(nr, nc) && (board[nr][nc] === player || (nr === r && nc === c))) {
        if (board[nr][nc] !== "" || (nr === r && nc === c)) {
          count++;
        }
        nr += dr;
        nc += dc;
      }

      nr = r - dr;
      nc = c - dc;
      while (inBounds(nr, nc) && (board[nr][nc] === player || (nr === r && nc === c))) {
        if (board[nr][nc] !== "" || (nr === r && nc === c)) {
          count++;
        }
        nr -= dr;
        nc -= dc;
      }

      return count;
    }

    function scoreMove(r, c) {
      // Higher is better for computer
      if (board[r][c] !== "") return -Infinity;

      // 1) Immediate win for computer
      board[r][c] = computerPlayer;
      const winNow = getWinningLine(board, r, c, computerPlayer);
      board[r][c] = "";
      if (winNow) return 1_000_000;

      // 2) Immediate block of human win
      board[r][c] = humanPlayer;
      const blockHumanWin = getWinningLine(board, r, c, humanPlayer);
      board[r][c] = "";
      if (blockHumanWin) return 900_000;

      // 3) Positional heuristic: extend our lines and block opponent's
      const directions = [
        [0, 1],
        [1, 0],
        [1, 1],
        [1, -1],
      ];

      let score = 0;

      for (const [dr, dc] of directions) {
        const ourLen = simulateLineLength(r, c, computerPlayer, dr, dc);
        const theirLen = simulateLineLength(r, c, humanPlayer, dr, dc);

        // Offensive weights: strongly prefer building 4s and 3s
        if (ourLen >= WIN_LENGTH) {
          score += 100_000;
        } else if (ourLen === 4) {
          score += 8_000;
        } else if (ourLen === 3) {
          score += 1_500;
        } else if (ourLen === 2) {
          score += 400;
        } else if (ourLen === 1) {
          score += 50;
        }

        // Defensive weights: block strong human lines
        if (theirLen >= WIN_LENGTH) {
          score += 90_000;
        } else if (theirLen === 4) {
          score += 7_000;
        } else if (theirLen === 3) {
          score += 1_200;
        } else if (theirLen === 2) {
          score += 350;
        } else if (theirLen === 1) {
          score += 40;
        }
      }

      // Slight preference toward the center of the board
      const center = (BOARD_SIZE - 1) / 2;
      const distFromCenter = Math.abs(r - center) + Math.abs(c - center);
      score += (BOARD_SIZE * 2 - distFromCenter) * 5;

      return score;
    }

    function updateRestartButtonText() {
      if (!gameStarted) {
        restartBtn.textContent = "Start Game";
        restartBtn.title = "Start game (R or Space)";
      } else {
        restartBtn.textContent = "Restart game";
        restartBtn.title = "Restart game (R or Space)";
      }
    }

    function restartGame() {
      if (gameMode === "multiplayer" && currentRoomId) {
        alert("Cannot restart in multiplayer mode. Please leave the room first.");
        return;
      }
      
      // Hide play again modal if it's showing (in case it was somehow shown)
      hidePlayAgainModal();
      
      // Check if there's an active game that hasn't ended
      // An active game means: game has started, not over, and has moves on the board
      const hasMovesOnBoard = board.some(row => row.some(cell => cell !== ""));
      const hasActiveGame = !gameOver && gameStarted && hasMovesOnBoard;
      
      if (hasActiveGame) {
        // Show forfeit modal for restart
        showForfeitModal("restart");
        return;
      }
      
      // No active game - proceed with restart/start
      startNewRound();
      
      // If computer goes first, start the game immediately
      if (currentPlayer === computerPlayer && !gameOver && hasHumanName()) {
        gameStarted = true;
        updateRestartButtonText();
        setStatusForTurn();
        // Trigger computer's first move
        if (computerMoveTimeoutId !== null) {
          clearTimeout(computerMoveTimeoutId);
        }
        computerMoveTimeoutId = setTimeout(computerMove, 1000);
      }
    }

    function setStatusForTurn() {
      if (!hasHumanName()) {
        statusElem.textContent = "Enter your name above to start playing";
        statusRow.className = "status-neutral";
        return;
      }

      if (gameMode === "multiplayer" && currentRoomId) {
        if (currentPlayer === humanPlayer) {
          const name = getHumanDisplayName();
          setStatusWithMark(name, currentPlayer, "  your turn");
          statusRow.className = "status-your-turn";
        } else {
          setStatusWithMark(opponentName || "Opponent", currentPlayer, " is thinking...");
          statusRow.className = "status-computer-turn";
        }
      } else {
        // Training mode
        if (currentPlayer === humanPlayer) {
          const name = getHumanDisplayName();
          setStatusWithMark(name, currentPlayer, "  your turn");
          statusRow.className = "status-your-turn";
          computerThinking = false;
        } else {
          setStatusWithMark(getComputerDisplayName(), currentPlayer, " is thinking...");
          statusRow.className = "status-computer-turn";
          computerThinking = true;
        }
      }
    }

    // ---- Theme management ----

    function getTheme() {
      return localStorage.getItem("tictac9x9_theme") || "light";
    }

    function setTheme(theme) {
      document.documentElement.setAttribute("data-theme", theme);
      localStorage.setItem("tictac9x9_theme", theme);
      themeToggleBtn.textContent = theme === "dark" ? "" : "";
    }

    function toggleTheme() {
      const currentTheme = getTheme();
      const newTheme = currentTheme === "light" ? "dark" : "light";
      setTheme(newTheme);
    }

    // Initialize theme
    setTheme(getTheme());
    themeToggleBtn.addEventListener("click", toggleTheme);

    // ---- Multiplayer Mode ----

    function generateRoomId() {
      return Math.random().toString(36).substring(2, 8).toUpperCase();
    }

    function loadGameMode() {
      try {
        const saved = localStorage.getItem("tictac9x9_gameMode");
        if (saved === "multiplayer" || saved === "training") {
          gameMode = saved;
        }
      } catch (e) {
        // ignore errors
        gameMode = "training"; // Default to training on error
      }
    }

    function saveGameMode() {
      try {
        localStorage.setItem("tictac9x9_gameMode", gameMode);
      } catch (e) {
        // ignore errors
      }
    }

    function updateModeToggle() {
      // Ensure elements exist before trying to update them
      const toggleSwitch = document.getElementById("modeToggleSwitch");
      const toggleSwitchMultiplayer = document.getElementById("modeToggleSwitchMultiplayer");
      
      if (!toggleSwitch || !toggleSwitchMultiplayer) {
        console.warn("Mode toggle elements not found");
        return;
      }
      
      if (gameMode === "multiplayer") {
        toggleSwitch.classList.add("multiplayer");
        toggleSwitchMultiplayer.classList.add("multiplayer");
        toggleSwitch.title = "Multiplayer Mode - Click to switch to Training";
        toggleSwitchMultiplayer.title = "Multiplayer Mode - Click to switch to Training";
        // Hide streak displays, show multiplayer scores
        const streakBar = document.getElementById("streak-bar");
        const statsBtn = document.getElementById("statsBtn");
        const leaderboardBtn = document.getElementById("leaderboardBtn");
        const trophyBtn = document.getElementById("trophyBtn");
        
        if (streakBar) streakBar.style.display = "none";
        if (multiplayerScoreBar) multiplayerScoreBar.style.display = "block";
        if (statsBtn) statsBtn.style.display = "none";
        if (leaderboardBtn) leaderboardBtn.style.display = "block";
        if (trophyBtn) trophyBtn.style.display = "none";
      } else {
        toggleSwitch.classList.remove("multiplayer");
        toggleSwitchMultiplayer.classList.remove("multiplayer");
        toggleSwitch.title = "Training Mode - Click to switch to Multiplayer";
        toggleSwitchMultiplayer.title = "Training Mode - Click to switch to Multiplayer";
        // Show streak displays, hide multiplayer scores
        const streakBar = document.getElementById("streak-bar");
        const statsBtn = document.getElementById("statsBtn");
        const leaderboardBtn = document.getElementById("leaderboardBtn");
        const trophyBtn = document.getElementById("trophyBtn");
        
        if (streakBar) streakBar.style.display = "flex";
        if (multiplayerScoreBar) multiplayerScoreBar.style.display = "none";
        if (statsBtn) statsBtn.style.display = "block";
        if (leaderboardBtn) leaderboardBtn.style.display = "none";
        if (trophyBtn) trophyBtn.style.display = "block";
        // Reset multiplayer score display
        updateMultiplayerScoreDisplay();
      }
    }

    function updateMultiplayerScoreDisplay() {
      if (gameMode !== "multiplayer") return;
      
      const player1NameDisplay = document.getElementById("player1NameDisplay");
      const player2NameDisplay = document.getElementById("player2NameDisplay");
      const player1ScoreDisplay = document.getElementById("player1ScoreDisplay");
      const player2ScoreDisplay = document.getElementById("player2ScoreDisplay");
      
      if (!player1NameDisplay || !player2NameDisplay || !player1ScoreDisplay || !player2ScoreDisplay) return;
      
      // Update player names
      if (player1Name) {
        player1NameDisplay.textContent = player1Name;
      } else {
        player1NameDisplay.textContent = "-";
      }
      
      if (player2Name) {
        player2NameDisplay.textContent = player2Name;
        // Stop loading animation
        if (loadingDotsInterval) {
          clearInterval(loadingDotsInterval);
          loadingDotsInterval = null;
        }
      } else {
        // Show "Waiting" + loading dots animation
        if (!player2NameDisplay.querySelector(".loading-dots")) {
          player2NameDisplay.innerHTML = 'Waiting <span class="loading-dots"></span>';
        } else {
          // Update text but keep dots
          const loadingSpan = player2NameDisplay.querySelector(".loading-dots");
          if (loadingSpan && !player2NameDisplay.textContent.includes("Waiting")) {
            player2NameDisplay.innerHTML = 'Waiting <span class="loading-dots"></span>';
          }
        }
        // Animate dots
        const loadingSpan = player2NameDisplay.querySelector(".loading-dots");
        if (loadingSpan && !loadingDotsInterval) {
          let dotCount = 0;
          loadingDotsInterval = setInterval(() => {
            dotCount = (dotCount % 3) + 1;
            loadingSpan.textContent = '.'.repeat(dotCount);
          }, 500);
        }
      }
      
      // Update scores
      if (currentRoomId && player1Name) {
        const scores = calculateMatchScore(matchResults.player1Wins, matchResults.draws, matchResults.player2Wins);
        currentMatchScore = { player1: scores.player1Score, player2: scores.player2Score };
        player1ScoreDisplay.textContent = scores.player1Score;
        player2ScoreDisplay.textContent = scores.player2Score;
      } else {
        player1ScoreDisplay.textContent = "0";
        player2ScoreDisplay.textContent = "0";
      }
    }

    function toggleGameMode() {
      if (gameMode === "training") {
        // Switching to multiplayer - need name first
        if (!hasHumanName()) {
          alert("Please enter your name before switching to multiplayer mode.");
          return;
        }
        gameMode = "multiplayer";
        saveGameMode();
        updateModeToggle();
        showRoomModal();
      } else {
        // Switching to training - leave room if in one
        if (currentRoomId) {
          leaveRoom();
        }
        gameMode = "training";
        saveGameMode();
        updateModeToggle();
        restartGame();
      }
    }

    function showRoomModal() {
      roomModalBody.innerHTML = `
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <button id="createRoomBtn" class="button" style="width: 100%;">Create Room</button>
          <button id="joinRoomBtn" class="button" style="width: 100%;">Join Room</button>
          <button id="quickMatchBtn" class="button" style="width: 100%;">Quick Match</button>
        </div>
      `;
      roomIdSection.style.display = "none";
      waitingRoomSection.style.display = "none";
      joinRoomSection.style.display = "none";
      roomModal.classList.add("show");
      
      // Re-attach event listeners
      document.getElementById("createRoomBtn").addEventListener("click", createRoom);
      document.getElementById("joinRoomBtn").addEventListener("click", () => {
        roomModalBody.innerHTML = "";
        joinRoomSection.style.display = "block";
        joinRoomIdInput.focus();
      });
      document.getElementById("quickMatchBtn").addEventListener("click", quickMatch);
    }

    function hideRoomModal() {
      roomModal.classList.remove("show");
    }

    async function createRoom() {
      if (!firebaseInitialized || !db) {
        alert("Multiplayer requires Firebase. Please configure Firebase.");
        return;
      }
      if (!hasHumanName()) {
        alert("Please enter your name first.");
        return;
      }

      const roomId = generateRoomId();
      currentRoomId = roomId;
      isPlayer1 = true;
      matchGameNumber = 0;
      matchResults = { player1Wins: 0, draws: 0, player2Wins: 0 };

      try {
        const playerName = currentPlayerName || humanNameInput.value.trim();
        await db.collection("gameRooms").doc(roomId).set({
          roomId: roomId,
          player1: {
            name: playerName,
            mark: "X",
            ready: true
          },
          player2: null,
          board: createEmptyBoard(),
          currentPlayer: "X",
          gameOver: false,
          winner: null,
          matchGameNumber: 0,
          matchResults: { player1Wins: 0, draws: 0, player2Wins: 0 },
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          lastMove: firebase.firestore.FieldValue.serverTimestamp()
        });

        player1Name = playerName;
        player2Name = ""; // Reset until player2 joins
        
        // Update display immediately - check if we're in multiplayer mode
        if (gameMode === "multiplayer") {
          const player1NameDisplay = document.getElementById("player1NameDisplay");
          if (player1NameDisplay) {
            player1NameDisplay.textContent = playerName;
          }
          updateMultiplayerScoreDisplay();
        }
        roomIdDisplay.textContent = roomId;
        roomIdSection.style.display = "block";
        waitingRoomSection.style.display = "block";
        roomPlayer1.textContent = playerName;
        roomPlayer2.textContent = "Waiting...";
        roomModalBody.innerHTML = "";

        // Listen for room updates
        setupRoomListener(roomId);
      } catch (error) {
        console.error("Error creating room:", error);
        alert("Failed to create room. Please try again.");
      }
    }

    async function joinRoom(roomIdToJoin) {
      if (!firebaseInitialized || !db) {
        alert("Multiplayer requires Firebase. Please configure Firebase.");
        return;
      }
      if (!hasHumanName()) {
        alert("Please enter your name first.");
        return;
      }

      const roomId = roomIdToJoin || joinRoomIdInput.value.trim().toUpperCase();
      if (!roomId) {
        alert("Please enter a room ID.");
        return;
      }

      try {
        const roomRef = db.collection("gameRooms").doc(roomId);
        const roomDoc = await roomRef.get();

        if (!roomDoc.exists) {
          alert("Room not found. Please check the room ID.");
          return;
        }

        const roomData = roomDoc.data();
        if (roomData.player2) {
          alert("Room is full.");
          return;
        }

        const playerName = currentPlayerName || humanNameInput.value.trim();
        currentRoomId = roomId;
        isPlayer1 = false;
        matchGameNumber = 0;
        matchResults = { player1Wins: 0, draws: 0, player2Wins: 0 };

        await roomRef.update({
          player2: {
            name: playerName,
            mark: "O",
            ready: true
          },
          lastMove: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        player2Name = playerName;
        // Also set player1Name from room data if we're joining
        const roomDataJoin = roomDoc.data();
        if (roomDataJoin.player1) {
          player1Name = roomDataJoin.player1.name;
          // Update display immediately
          const player1NameDisplay = document.getElementById("player1NameDisplay");
          if (player1NameDisplay) {
            player1NameDisplay.textContent = player1Name;
          }
        }
        updateMultiplayerScoreDisplay();

        hideRoomModal();
        setupRoomListener(roomId);
      } catch (error) {
        console.error("Error joining room:", error);
        alert("Failed to join room. Please try again.");
      }
    }

    async function quickMatch() {
      if (!firebaseInitialized || !db) {
        alert("Multiplayer requires Firebase. Please configure Firebase.");
        return;
      }
      if (!hasHumanName()) {
        alert("Please enter your name first.");
        return;
      }

      try {
        // Look for rooms waiting for player2
        const waitingRooms = await db.collection("gameRooms")
          .where("player2", "==", null)
          .limit(1)
          .get();

        if (!waitingRooms.empty) {
          const roomDoc = waitingRooms.docs[0];
          await joinRoom(roomDoc.id);
        } else {
          // No waiting rooms, create one
          await createRoom();
        }
      } catch (error) {
        console.error("Error in quick match:", error);
        alert("Failed to find a match. Creating a room instead...");
        await createRoom();
      }
    }

    function setupRoomListener(roomId) {
      if (roomListener) {
        roomListener(); // Unsubscribe previous listener
      }

      roomListener = db.collection("gameRooms").doc(roomId).onSnapshot(
        async (doc) => {
          if (!doc.exists) {
            // Room was deleted
            if (currentRoomId === roomId) {
              alert("Room was closed.");
              leaveRoom();
            }
            return;
          }

          const roomData = doc.data();
          
          // Update UI
          if (roomData.player1) {
            roomPlayer1.textContent = roomData.player1.name;
            player1Name = roomData.player1.name;
            // Update display immediately
            const player1NameDisplay = document.getElementById("player1NameDisplay");
            if (player1NameDisplay) {
              player1NameDisplay.textContent = player1Name;
            }
          }
          if (roomData.player2) {
            roomPlayer2.textContent = roomData.player2.name;
            player2Name = roomData.player2.name;
            opponentName = isPlayer1 ? roomData.player2.name : roomData.player1.name;
            if (waitingRoomSection) {
              waitingRoomSection.style.display = "none";
            }
            hideRoomModal();
          } else {
            // Player 2 hasn't joined yet
            player2Name = "";
          }
          updateMultiplayerScoreDisplay();

          // Sync game state
          if (roomData.board && Array.isArray(roomData.board)) {
            syncBoardFromFirestore(roomData);
          } else if (roomData.player1 && roomData.player2 && !roomData.board) {
            // Both players joined but no board yet - initialize game
            const newBoard = createEmptyBoard();
            await roomRef.update({
              board: newBoard,
              currentPlayer: "X",
              gameOver: false,
              winner: null,
              matchGameNumber: 0,
              matchResults: { player1Wins: 0, draws: 0, player2Wins: 0 },
              lastMove: firebase.firestore.FieldValue.serverTimestamp()
            });
          }

          // Handle match progression
          if (roomData.matchGameNumber !== undefined) {
            matchGameNumber = roomData.matchGameNumber;
          }
          if (roomData.matchResults) {
            matchResults = roomData.matchResults;
          }
        },
        (error) => {
          console.error("Room listener error:", error);
        }
      );
    }

    function syncBoardFromFirestore(roomData) {
      if (!roomData.board) return;

      board = roomData.board;
      currentPlayer = roomData.currentPlayer || "X";
      gameOver = roomData.gameOver || false;

      // Update UI
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
          if (cell) {
            cell.textContent = board[r][c] || "";
            cell.classList.remove("X", "O", "last-move", "win");
            if (board[r][c]) {
              cell.classList.add(board[r][c]);
            }
          }
        }
      }

      // Update player assignments based on match game
      if (matchGameNumber === 0) {
        // First game: player1 is X, player2 is O
        humanPlayer = isPlayer1 ? "X" : "O";
        computerPlayer = isPlayer1 ? "O" : "X";
        myMarkInMatch = isPlayer1 ? "X" : "O";
      } else {
        // Second game: player1 is O, player2 is X
        humanPlayer = isPlayer1 ? "O" : "X";
        computerPlayer = isPlayer1 ? "X" : "O";
        myMarkInMatch = isPlayer1 ? "O" : "X";
      }

      // Update cells UI
      const cells = document.querySelectorAll(".cell");
      cells.forEach(cell => {
        const r = parseInt(cell.dataset.row, 10);
        const c = parseInt(cell.dataset.col, 10);
        cell.textContent = board[r][c] || "";
        cell.classList.remove("X", "O", "last-move", "win");
        if (board[r][c]) {
          cell.classList.add(board[r][c]);
        }
      });

      // Update status
      if (gameOver) {
        if (roomData.winner) {
          const winnerName = roomData.winner === humanPlayer 
            ? (currentPlayerName || "You")
            : opponentName;
          setStatusWithMark(winnerName, roomData.winner, " wins!");
        } else {
          statusElem.textContent = "It's a draw!";
        }
        statusRow.className = "status-neutral";
      } else {
        setStatusForTurn();
      }
      
      // Update score display
      if (roomData.matchResults) {
        matchResults = roomData.matchResults;
        updateMultiplayerScoreDisplay();
      }
    }

    async function leaveRoom() {
      if (roomListener) {
        roomListener();
        roomListener = null;
      }

      if (currentRoomId && firebaseInitialized && db) {
        try {
          const roomRef = db.collection("gameRooms").doc(currentRoomId);
          const roomDoc = await roomRef.get();
          
          if (roomDoc.exists) {
            const roomData = roomDoc.data();
            // Only delete if we're the only player, or update to remove us
            if (isPlayer1 && !roomData.player2) {
              await roomRef.delete();
            } else if (!isPlayer1) {
              await roomRef.update({ player2: null });
            }
          }
        } catch (error) {
          console.error("Error leaving room:", error);
        }
      }

      currentRoomId = null;
      isPlayer1 = false;
      opponentName = "";
      player1Name = "";
      player2Name = "";
      matchGameNumber = 0;
      matchResults = { player1Wins: 0, draws: 0, player2Wins: 0 };
      currentMatchScore = { player1: 0, player2: 0 };
      // Stop loading animation
      if (loadingDotsInterval) {
        clearInterval(loadingDotsInterval);
        loadingDotsInterval = null;
      }
      updateMultiplayerScoreDisplay();
    }

    // Scoring system: Win = 2pts, Draw = 1pt each, Loss = 0pts
    function calculateMatchScore(player1Wins, draws, player2Wins) {
      // Win=2, Draw=1, Loss=0
      const player1Score = (player1Wins * 2) + (draws * 1);
      const player2Score = (player2Wins * 2) + (draws * 1);
      return { player1Score, player2Score };
    }

    async function handleMultiplayerGameEnd(winner, result) {
      if (!currentRoomId || !firebaseInitialized || !db) return;

      try {
        const roomRef = db.collection("gameRooms").doc(currentRoomId);
        const roomDoc = await roomRef.get();
        if (!roomDoc.exists) return;

        const roomData = roomDoc.data();
        let updatedMatchResults = { ...matchResults };

        // Update match results based on game outcome
        if (result === "draw") {
          updatedMatchResults.draws++;
          playSound("draw");
          statusElem.textContent = "It's a draw!";
        } else if (winner) {
          const iWon = (isPlayer1 && winner === "X" && matchGameNumber === 0) ||
                      (isPlayer1 && winner === "O" && matchGameNumber === 1) ||
                      (!isPlayer1 && winner === "O" && matchGameNumber === 0) ||
                      (!isPlayer1 && winner === "X" && matchGameNumber === 1);
          
          if (iWon) {
            if (isPlayer1) {
              updatedMatchResults.player1Wins++;
            } else {
              updatedMatchResults.player2Wins++;
            }
            playSound("applause");
            createConfetti();
            const winnerName = getHumanDisplayName();
            setStatusWithMark(winnerName, winner, " wins!");
          } else {
            if (isPlayer1) {
              updatedMatchResults.player2Wins++;
            } else {
              updatedMatchResults.player1Wins++;
            }
            playSound("aw");
            setStatusWithMark(opponentName, winner, " wins!");
          }
        }

        matchResults = updatedMatchResults;
        updateMultiplayerScoreDisplay(); // Update score display

        // Update Firestore
        await roomRef.update({
          gameOver: true,
          winner: winner,
          matchResults: updatedMatchResults,
          lastMove: firebase.firestore.FieldValue.serverTimestamp()
        });

        // Check if match is complete (2 games played)
        const totalGames = updatedMatchResults.player1Wins + updatedMatchResults.player2Wins + updatedMatchResults.draws;
        
        if (totalGames >= 2) {
          // Match complete - calculate final scores and update leaderboard
          await completeMatch(updatedMatchResults, roomData);
        } else {
          // Start next game in match
          setTimeout(async () => {
            await startNextMatchGame();
          }, 3000);
        }

        statusRow.className = "status-neutral";
        resetGameState();
      } catch (error) {
        console.error("Error handling multiplayer game end:", error);
      }
    }

    async function startNextMatchGame() {
      if (!currentRoomId || !firebaseInitialized || !db) return;

      matchGameNumber = 1; // Second game
      gameOver = false;
      board = createEmptyBoard();
      resetGameState();

      // Swap marks: player1 becomes O, player2 becomes X
      const roomRef = db.collection("gameRooms").doc(currentRoomId);
      await roomRef.update({
        board: board,
        currentPlayer: "X",
        gameOver: false,
        winner: null,
        matchGameNumber: 1,
        lastMove: firebase.firestore.FieldValue.serverTimestamp()
      });

      // Update UI
      const cells = document.querySelectorAll(".cell");
      cells.forEach(cell => {
        cell.textContent = "";
        cell.classList.remove("X", "O", "last-move", "win");
      });

      // Update player assignments
      humanPlayer = isPlayer1 ? "O" : "X";
      computerPlayer = isPlayer1 ? "X" : "O";
      myMarkInMatch = humanPlayer;
      currentPlayer = "X";

      updateMultiplayerScoreDisplay();
      setStatusForTurn();
    }

    async function completeMatch(matchResults, roomData) {
      if (!firebaseInitialized || !db) return;

      const scores = calculateMatchScore(matchResults.player1Wins, matchResults.draws, matchResults.player2Wins);
      const player1Name = roomData.player1?.name || "";
      const player2Name = roomData.player2?.name || "";

      // Update leaderboard
      await updateLeaderboard(player1Name, player2Name, scores, matchResults);

      // Show match results
      const myName = isPlayer1 ? player1Name : player2Name;
      const myScore = isPlayer1 ? scores.player1Score : scores.player2Score;
      const opponentScore = isPlayer1 ? scores.player2Score : scores.player1Score;

      let resultMessage = `Match Complete!\n\n`;
      resultMessage += `Game 1: ${matchResults.player1Wins > 0 ? `${player1Name} (X) won` : matchResults.player2Wins > 0 ? `${player2Name} (O) won` : "Draw"}\n`;
      resultMessage += `Game 2: ${matchResults.player2Wins > 0 ? `${player2Name} (X) won` : matchResults.player1Wins > 0 ? `${player1Name} (O) won` : "Draw"}\n\n`;
      resultMessage += `Final Score:\n${myName}: ${myScore} pts\n${opponentName}: ${opponentScore} pts\n\n`;
      
      if (myScore > opponentScore) {
        resultMessage += " You won the match!";
      } else if (myScore < opponentScore) {
        resultMessage += " You lost the match.";
      } else {
        resultMessage += " Match is a tie!";
      }

      setTimeout(() => {
        alert(resultMessage);
        // Option to rematch or leave
        const rematch = confirm("Would you like to rematch?");
        if (rematch) {
          startNewMatch();
        } else {
          leaveRoom();
          gameMode = "training";
          saveGameMode();
          updateModeToggle();
          restartGame();
        }
      }, 2000);
    }

    async function startNewMatch() {
      if (!currentRoomId || !firebaseInitialized || !db) return;

      matchGameNumber = 0;
      matchResults = { player1Wins: 0, draws: 0, player2Wins: 0 };
      gameOver = false;
      board = createEmptyBoard();
      resetGameState();

      const roomRef = db.collection("gameRooms").doc(currentRoomId);
      await roomRef.update({
        board: board,
        currentPlayer: "X",
        gameOver: false,
        winner: null,
        matchGameNumber: 0,
        matchResults: { player1Wins: 0, draws: 0, player2Wins: 0 },
        lastMove: firebase.firestore.FieldValue.serverTimestamp()
      });

      // Update UI
      const cells = document.querySelectorAll(".cell");
      cells.forEach(cell => {
        cell.textContent = "";
        cell.classList.remove("X", "O", "last-move", "win");
      });

      // Reset player assignments
      humanPlayer = isPlayer1 ? "X" : "O";
      computerPlayer = isPlayer1 ? "O" : "X";
      myMarkInMatch = humanPlayer;
      currentPlayer = "X";

      updateMultiplayerScoreDisplay();
      setStatusForTurn();
    }

    async function updateLeaderboard(player1Name, player2Name, scores, matchResults) {
      if (!firebaseInitialized || !db) return;

      try {
        // Update player1 stats
        const p1Ref = db.collection("multiplayerLeaderboard").doc(player1Name.toLowerCase());
        const p1Doc = await p1Ref.get();
        const p1Data = p1Doc.exists ? p1Doc.data() : { name: player1Name, matchesPlayed: 0, wins: 0, draws: 0, losses: 0, totalPoints: 0 };
        
        p1Data.matchesPlayed = (p1Data.matchesPlayed || 0) + 1;
        p1Data.totalPoints = (p1Data.totalPoints || 0) + scores.player1Score;
        if (scores.player1Score > scores.player2Score) {
          p1Data.wins = (p1Data.wins || 0) + 1;
        } else if (scores.player1Score < scores.player2Score) {
          p1Data.losses = (p1Data.losses || 0) + 1;
        } else {
          p1Data.draws = (p1Data.draws || 0) + 1;
        }
        p1Data.lastUpdated = firebase.firestore.FieldValue.serverTimestamp();
        await p1Ref.set(p1Data, { merge: true });

        // Update player2 stats
        const p2Ref = db.collection("multiplayerLeaderboard").doc(player2Name.toLowerCase());
        const p2Doc = await p2Ref.get();
        const p2Data = p2Doc.exists ? p2Doc.data() : { name: player2Name, matchesPlayed: 0, wins: 0, draws: 0, losses: 0, totalPoints: 0 };
        
        p2Data.matchesPlayed = (p2Data.matchesPlayed || 0) + 1;
        p2Data.totalPoints = (p2Data.totalPoints || 0) + scores.player2Score;
        if (scores.player2Score > scores.player1Score) {
          p2Data.wins = (p2Data.wins || 0) + 1;
        } else if (scores.player2Score < scores.player1Score) {
          p2Data.losses = (p2Data.losses || 0) + 1;
        } else {
          p2Data.draws = (p2Data.draws || 0) + 1;
        }
        p2Data.lastUpdated = firebase.firestore.FieldValue.serverTimestamp();
        await p2Ref.set(p2Data, { merge: true });
      } catch (error) {
        console.error("Error updating leaderboard:", error);
      }
    }

    // Initialize sound
    const savedSound = localStorage.getItem("tictac9x9_sound");
    if (savedSound !== null) {
      soundEnabled = savedSound === "true";
    }
    soundToggleBtn.classList.toggle("muted", !soundEnabled);
    soundToggleBtn.addEventListener("click", toggleSound);

    // Mode toggle switches - initialize both with same content
    function initializeToggle(toggleElement) {
      if (toggleElement && !toggleElement.querySelector(".mode-option")) {
        toggleElement.innerHTML = `
          <div class="mode-option" data-mode="training"></div>
          <div class="mode-slider"></div>
          <div class="mode-option" data-mode="multiplayer"></div>
        `;
      }
    }

    if (modeToggleSwitch) {
      initializeToggle(modeToggleSwitch);
      // Disabled for now - multiplayer coming soon
      // modeToggleSwitch.addEventListener("click", toggleGameMode);
    }
    if (modeToggleSwitchMultiplayer) {
      initializeToggle(modeToggleSwitchMultiplayer);
      // Disabled for now - multiplayer coming soon
      // modeToggleSwitchMultiplayer.addEventListener("click", toggleGameMode);
    }
    
    // Room modal
    roomModalClose.addEventListener("click", hideRoomModal);
    roomModal.addEventListener("click", (e) => {
      if (e.target === roomModal) hideRoomModal();
    });
    copyRoomIdBtn.addEventListener("click", () => {
      navigator.clipboard.writeText(currentRoomId).then(() => {
        copyRoomIdBtn.textContent = " Copied!";
        setTimeout(() => { copyRoomIdBtn.textContent = " Copy Room ID"; }, 2000);
      });
    });
    joinRoomConfirmBtn.addEventListener("click", () => joinRoom());
    joinRoomIdInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") joinRoom();
    });

    // Stats modal
    statsBtn.addEventListener("click", showStats);
    closeStatsBtn.addEventListener("click", hideStats);
    statsModal.addEventListener("click", (e) => {
      if (e.target === statsModal) {
        hideStats();
      }
    });

    // Achievements modal
    trophyBtn.addEventListener("click", showTrophyCabinet);
    closeTrophyBtn.addEventListener("click", hideTrophyCabinet);
    trophyModal.addEventListener("click", (e) => {
      if (e.target === trophyModal) {
        hideTrophyCabinet();
      }
    });

    shareAchievementsBtn.addEventListener("click", () => {
      const unlocked = Object.values(achievements).filter(a => a.unlocked).length;
      const text = `I've unlocked ${unlocked}/8 achievements in 5-in-a-Row! Can you beat that?`;
      openShare(text);
    });

    shareGameResultBtn.addEventListener("click", () => {
      openShare(lastGameResultText);
    });

    shareModalClose.addEventListener("click", hideShareModal);
    shareModal.addEventListener("click", (e) => {
      if (e.target === shareModal) hideShareModal();
    });

    document.addEventListener("keydown", (e) => {
      
      // Normal restart shortcuts
      if (e.key === "r" || e.key === "R" || e.key === " ") {
        const active = document.activeElement;
        if (active && (active.tagName === "INPUT" || active.tagName === "TEXTAREA")) return;
        e.preventDefault();
        restartGame();
      }
    });

    restartBtn.addEventListener("click", restartGame);

    applyHumanNameBtn.addEventListener("click", async () => {
      const newName = humanNameInput.value.trim();
      if (!newName) {
        alert("Please enter your name before clicking Set.");
        return;
      }
      
      if (newName.length < 3) {
        alert("Name must be at least 3 characters long.");
        humanNameInput.focus();
        return;
      }

      const nameChanged = newName.toLowerCase() !== currentPlayerName.toLowerCase();

      // If name changed and streak > 0, warn user that counter will reset
      if (nameChanged && currentStreak > 0) {
        const confirmed = confirm(
          `Changing your name will reset your current streak of ${currentStreak}. Do you want to continue?`
        );
        if (!confirmed) {
          return;
        }
      }

      // If Firebase is not configured, allow name without registration
      if (!firebaseInitialized || !db) {
        await completeNameSetup(newName);
        return;
      }

      // Check if name is registered
      const isRegistered = await checkNameRegistered(newName);
      
      if (isRegistered) {
        // Name is registered - show login modal
        showRegisterModal(newName, true);
      } else {
        // Name is not registered - show registration modal
        showRegisterModal(newName, false);
      }
    });

    async function completeNameSetup(name, forceLoadStats = false) {
      if (!name || !name.trim()) return;
      const nameChanged = name.toLowerCase() !== currentPlayerName.toLowerCase();

      // Reset streak and current player stats when name changes, or force load stats
      if (nameChanged || forceLoadStats) {
        // Try to load player stats from Firestore first if registered
        let statsLoaded = false;
        if (firebaseInitialized && db) {
          const isRegistered = await checkNameRegistered(name);
          if (isRegistered) {
            statsLoaded = await loadPlayerStats(name);
          }
        }
        
        // Only reset if we didn't load stats (new name or not registered)
        if (!statsLoaded) {
          currentStreak = 0;
          currentPlayerStats = {
            gamesPlayed: 0,
            wins: 0,
            losses: 0,
            draws: 0
          };
        }
        
        if (gameMode === "training") {
          updateStreakDisplays();
        }
        updateStatsDisplay(); // Update stats modal display
      }
      
      currentPlayerName = name;
      
      // Save name to localStorage for persistence
      try {
        localStorage.setItem("tictac9x9_currentPlayerName", name);
      } catch (e) {
        // ignore errors
      }
      
      // Update status and potentially start/continue game
      setStatusForTurn();
      
      // If it's computer's turn and game has started, trigger computer move
      // (Don't trigger if game hasn't started yet - wait for player confirmation)
      if (gameStarted && currentPlayer === computerPlayer && !gameOver) {
        computerThinking = true;
        if (computerMoveTimeoutId !== null) {
          clearTimeout(computerMoveTimeoutId);
        }
        computerMoveTimeoutId = setTimeout(computerMove, 1000);
      }
    }

    registerConfirmBtn.addEventListener("click", async () => {
      const password = registerPassword.value.trim();
      if (!password) {
        alert("Please enter a password.");
        return;
      }

      if (isLoginMode) {
        // Login: verify password
        const nameToUse = pendingName; // Save name before hiding modal
        const isValid = await verifyPassword(nameToUse, password);
        if (isValid) {
          // Copy name to main input field
          humanNameInput.value = nameToUse;
          
          hideRegisterModal();
          await completeNameSetup(nameToUse, true); // Force load stats on login
          updateStatsDisplay(); // Update stats display after loading
          // Don't auto-start game - user must click "Start Game" button
        } else {
          alert("Incorrect password. Please try again.");
          registerPassword.value = "";
          registerPassword.focus();
        }
      } else {
        // Register: create new registration
        const nameToUse = pendingName; // Save name before hiding modal
        if (password.length < 4) {
          alert("Password must be at least 4 characters long.");
          return;
        }
        const success = await registerName(nameToUse, password);
        if (success) {
          // Copy name to main input field
          humanNameInput.value = nameToUse;
          
          hideRegisterModal();
          await completeNameSetup(nameToUse, true); // Force load stats on registration
          updateStatsDisplay(); // Update stats display after loading
          if (!gameOver && board.every(row => row.every(cell => cell === ""))) {
            startNewRound();
          }
        } else {
          alert("Registration failed. The name might already be registered.");
          registerPassword.value = "";
          registerPassword.focus();
        }
      }
    });

    registerCancelBtn.addEventListener("click", hideRegisterModal);
    registerSkipBtn.addEventListener("click", async () => {
      const nameToUse = pendingName; // Save name before hiding modal
      if (!nameToUse || !nameToUse.trim()) {
        hideRegisterModal();
        return;
      }
      // Copy name to main input field
      humanNameInput.value = nameToUse;
      
      hideRegisterModal();
      await completeNameSetup(nameToUse);
      // Don't auto-start game - user must click "Start Game" button
    });
    registerModal.addEventListener("click", (e) => {
      if (e.target === registerModal) hideRegisterModal();
    });

    registerPassword.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        registerConfirmBtn.click();
      }
    });

    // Name Selection Modal handlers - real-time checking with debounce
    nameSelectionInput.addEventListener("input", () => {
      // Clear previous timeout
      if (nameCheckTimeout) {
        clearTimeout(nameCheckTimeout);
      }
      
      // Debounce the check - wait 500ms after user stops typing
      nameCheckTimeout = setTimeout(() => {
        checkNameAndUpdateModal();
      }, 500);
    });

    nameSelectionStartBtn.addEventListener("click", async () => {
      const name = nameSelectionInput.value.trim();
      if (name.length < 3) {
        alert("Name must be at least 3 characters long.");
        nameSelectionInput.focus();
        return;
      }
      
      // Copy name to main input field
      humanNameInput.value = name;
      
      hideNameSelectionModal();
      await completeNameSetup(name);
      startNewRound();
    });

    nameSelectionRegisterBtn.addEventListener("click", async () => {
      const name = nameSelectionInput.value.trim();
      if (name.length < 3) {
        alert("Name must be at least 3 characters long.");
        nameSelectionInput.focus();
        return;
      }
      
      // Copy name to main input field
      humanNameInput.value = name;
      
      // Show registration modal
      pendingName = name;
      showRegisterModal(name, false);
      hideNameSelectionModal();
    });

    nameSelectionLoginBtn.addEventListener("click", async () => {
      const name = nameSelectionInput.value.trim();
      const password = nameSelectionPassword.value.trim();
      
      if (name.length < 3) {
        alert("Name must be at least 3 characters long.");
        nameSelectionInput.focus();
        return;
      }
      
      if (!password) {
        alert("Please enter your password.");
        nameSelectionPassword.focus();
        return;
      }
      
      // Verify password
      const isValid = await verifyPassword(name, password);
      if (isValid) {
        // Copy name to main input field
        humanNameInput.value = name;
        
        hideNameSelectionModal();
        await completeNameSetup(name, true); // Force load stats on login
        updateStatsDisplay();
        startNewRound();
      } else {
        alert("Incorrect password. Please try again.");
        nameSelectionPassword.value = "";
        nameSelectionPassword.focus();
      }
    });

    nameSelectionInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const name = nameSelectionInput.value.trim();
        if (name.length < 3) {
          return; // Don't proceed if name is too short
        }
        
        // If buttons are visible, trigger the appropriate one
        if (nameSelectionPasswordSection.style.display !== "none" && nameSelectionLoginBtn.style.display !== "none") {
          nameSelectionLoginBtn.click();
        } else if (nameSelectionStartBtn.style.display !== "none") {
          nameSelectionStartBtn.click();
        }
      }
    });

    nameSelectionPassword.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        nameSelectionLoginBtn.click();
      }
    });

    nameSelectionModal.addEventListener("click", (e) => {
      if (e.target === nameSelectionModal) {
        // Don't allow closing by clicking outside - user must enter name
      }
    });

    function startNewRound() {
      if (gameMode === "multiplayer" && currentRoomId) {
        // In multiplayer, don't reset - wait for sync from Firestore
        return;
      }

      // Cancel any pending computer move
      if (computerMoveTimeoutId !== null) {
        clearTimeout(computerMoveTimeoutId);
        computerMoveTimeoutId = null;
      }

      board = createEmptyBoard();
      gameOver = false;
      gameStarted = false; // Don't mark as started yet - wait for first move or user confirmation
      computerThinking = false;
      resetGameState();
      clearGameState(); // Clear saved game state when starting new round
      
      // Update button text
      updateRestartButtonText();

      // Alternate which mark the human controls each game
      humanPlayer = nextHumanPlayer;
      computerPlayer = humanPlayer === "X" ? "O" : "X";
      currentPlayer = "X"; // X always starts

      const cells = document.querySelectorAll(".cell");
      cells.forEach(cell => {
        cell.textContent = "";
        cell.classList.remove("X", "O", "last-move", "win");
      });

      shareGameResultBtn.classList.remove("visible");
      if (gameMode === "training") {
        updateStreakDisplays();
      } else if (gameMode === "multiplayer") {
        updateMultiplayerScoreDisplay();
      }

      // Prepare status - game hasn't started yet
      if (!hasHumanName()) {
        statusElem.textContent = "Enter your name above to start playing";
        statusRow.className = "status-neutral";
      } else if (currentPlayer === humanPlayer) {
        // Human goes first - can click on board to start
        const name = getHumanDisplayName();
        setStatusWithMark(name, currentPlayer, "  click on a square to start");
        statusRow.className = "status-your-turn";
      } else {
        // Computer goes first - ready to start when user clicks "Start Game"
        statusElem.textContent = "Computer goes first - click 'Start Game' to begin";
        statusRow.className = "status-neutral";
      }

      // Flip for next game
      nextHumanPlayer = nextHumanPlayer === "X" ? "O" : "X";
    }

    async function init() {
      // Reset current streak on page refresh
      currentStreak = 0;
      
      // Set initial state before any rendering
      gameMode = "training"; // Default to training mode
      // Don't load saved mode - always start with training
      // loadGameMode(); // Load game mode preference (may override default)
      
      // Initialize board first
      initBoardUI();
      
      // Initialize toggle switches
      if (modeToggleSwitch) {
        initializeToggle(modeToggleSwitch);
      }
      if (modeToggleSwitchMultiplayer) {
        initializeToggle(modeToggleSwitchMultiplayer);
      }
      
      // Initialize UI state after DOM elements exist
      if (modeToggleSwitch && modeToggleSwitchMultiplayer) {
        updateModeToggle();
      }
      
      await loadBestStreak(); // Load global best streak from Firebase
      await loadGlobalStats(); // Load global stats from Firestore
      loadAchievements();
      updateAchievementsDisplay();
      
      // Update toggle again after everything is loaded
      if (modeToggleSwitch && modeToggleSwitchMultiplayer) {
        updateModeToggle();
      }
      
      // Try to restore saved player name
      try {
        const savedName = localStorage.getItem("tictac9x9_currentPlayerName");
        if (savedName && savedName.trim()) {
          humanNameInput.value = savedName;
          // Check if registered and load stats
          if (firebaseInitialized && db) {
            const isRegistered = await checkNameRegistered(savedName);
            if (isRegistered) {
              // Auto-load stats for registered user (force load even if name hasn't changed)
              await completeNameSetup(savedName, true);
              updateStatsDisplay(); // Update stats display after loading
            } else {
              // Not registered, just set the name without loading stats
              currentPlayerName = savedName;
              if (gameMode === "training") {
                updateStreakDisplays();
              }
            }
          } else {
            // Firebase not configured, just set the name
            currentPlayerName = savedName;
            if (gameMode === "training") {
              updateStreakDisplays();
            }
          }
        } else {
          humanNameInput.value = "";
        }
      } catch (e) {
        humanNameInput.value = "";
      }
      
      if (gameMode === "training") {
        updateStreakDisplays();
      }
      
      // Clear any stale game state on init (forfeit modal will show on beforeunload if needed)
      clearGameState();
      
      // Initialize game state but don't start automatically
      gameStarted = false;
      gameOver = true; // Set to true so no moves can be made until game starts
      board = createEmptyBoard();
      updateRestartButtonText();
      
      // Clear board display
      const cells = document.querySelectorAll(".cell");
      cells.forEach(cell => {
        cell.textContent = "";
        cell.classList.remove("X", "O", "last-move", "win");
      });
      
      // Set initial status and prepare game
      if (!currentPlayerName) {
        statusElem.textContent = "Enter your name above to start playing";
        statusRow.className = "status-neutral";
        showNameSelectionModal();
      } else {
        // Name exists - prepare the game so player can click to start
        startNewRound();
      }
    }
    
    // Forfeit modal handlers
    forfeitContinueBtn.addEventListener("click", () => {
      hideForfeitModal();
      isNavigatingAway = false;
      const action = forfeitModal.dataset.action || "";
      delete forfeitModal.dataset.action;
      
      const savedGameState = loadGameState();
      if (savedGameState) {
        restoreGameState(savedGameState);
        // Continue saving game state
        saveGameState();
      } else if (action === "restart") {
        // If it was a restart action but no saved state, just continue current game
        // (shouldn't happen, but handle it gracefully)
      } else {
        startNewRound();
      }
    });
    
    forfeitConfirmBtn.addEventListener("click", async () => {
      hideForfeitModal();
      isNavigatingAway = false;
      const action = forfeitModal.dataset.action || "";
      delete forfeitModal.dataset.action;
      
      await handleForfeit();
      
      // If it was a restart action, start a new game after forfeit
      if (action === "restart") {
        startNewRound();
      }
      // Otherwise, allow page to refresh/close naturally
    });
    
    forfeitModal.addEventListener("click", (e) => {
      if (e.target === forfeitModal) {
        // Don't allow closing by clicking outside - user must choose
      }
    });

    // Play Again Modal handlers
    // Play again modal removed - game starts directly when "Start Game" is clicked

    // Handle page close/refresh - show forfeit modal if game is active
    let isNavigatingAway = false;
    
    window.addEventListener("beforeunload", (e) => {
      // Only trigger forfeit if game has actually started (not just prepared)
      const savedGameState = loadGameState();
      const hasMovesOnBoard = board.some(row => row.some(cell => cell !== ""));
      if (savedGameState && savedGameState.playerName && 
          savedGameState.playerName.toLowerCase() === (currentPlayerName || "").toLowerCase() &&
          !gameOver && gameStarted && hasMovesOnBoard) {
        // Show the forfeit modal immediately
        showForfeitModal();
        isNavigatingAway = true;
        
        // Trigger browser's confirmation dialog
        e.preventDefault();
        e.returnValue = ""; // Required for Chrome
        return ""; // Required for other browsers
      }
    });

    // Handle visibility change - hide modal if user cancels navigation
    document.addEventListener("visibilitychange", () => {
      if (!document.hidden && isNavigatingAway) {
        // User cancelled navigation - hide modal and reset flag
        hideForfeitModal();
        isNavigatingAway = false;
      }
    });

    // Leaderboard functions
    async function loadLeaderboard() {
      if (!firebaseInitialized || !db) return [];

      try {
        const snapshot = await db.collection("multiplayerLeaderboard")
          .orderBy("totalPoints", "desc")
          .limit(100)
          .get();
        
        return snapshot.docs.map(doc => doc.data());
      } catch (error) {
        console.error("Error loading leaderboard:", error);
        return [];
      }
    }

    async function showLeaderboardModal() {
      const leaderboard = await loadLeaderboard();
      
      // Create or update leaderboard modal
      let leaderboardModal = document.getElementById("leaderboardModal");
      if (!leaderboardModal) {
        leaderboardModal = document.createElement("div");
        leaderboardModal.id = "leaderboardModal";
        leaderboardModal.className = "modal";
        leaderboardModal.innerHTML = `
          <div class="modal-content" style="max-width: 500px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
              <h2 style="margin: 0;"> Leaderboard</h2>
              <button id="leaderboardModalClose" class="icon-button" style="font-size: 20px;"></button>
            </div>
            <div id="leaderboardContent" style="max-height: 500px; overflow-y: auto;"></div>
          </div>
        `;
        document.body.appendChild(leaderboardModal);
        
        document.getElementById("leaderboardModalClose").addEventListener("click", () => {
          leaderboardModal.classList.remove("show");
        });
        leaderboardModal.addEventListener("click", (e) => {
          if (e.target === leaderboardModal) leaderboardModal.classList.remove("show");
        });
      }
      
      const leaderboardContent = document.getElementById("leaderboardContent");
      leaderboardContent.innerHTML = leaderboard.length === 0 
        ? '<div style="text-align: center; color: var(--text-secondary); padding: 40px;">No matches played yet. Be the first!</div>'
        : leaderboard.map((player, idx) => `
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; border-bottom: 1px solid var(--app-border); ${idx < 3 ? 'background: var(--cell-bg);' : ''}">
            <div style="display: flex; align-items: center; gap: 12px;">
              <div style="font-weight: 700; font-size: 18px; width: 30px; text-align: center; color: ${idx === 0 ? '#FFD700' : idx === 1 ? '#C0C0C0' : idx === 2 ? '#CD7F32' : 'var(--text-primary)'};">${idx === 0 ? '' : idx === 1 ? '' : idx === 2 ? '' : `#${idx + 1}`}</div>
              <div>
                <div style="font-weight: 600; font-size: 16px;">${escapeHtml(player.name)}</div>
                <div style="font-size: 12px; color: var(--text-secondary); margin-top: 2px;">
                  ${player.wins || 0}W ${player.draws || 0}D ${player.losses || 0}L  ${player.matchesPlayed || 0} matches
                </div>
              </div>
            </div>
            <div style="text-align: right;">
              <div style="font-weight: 700; font-size: 20px; color: var(--accent);">${player.totalPoints || 0}</div>
              <div style="font-size: 11px; color: var(--text-secondary);">points</div>
            </div>
          </div>
        `).join('');
      
      leaderboardModal.classList.add("show");
    }

    if (leaderboardBtn) {
      leaderboardBtn.addEventListener("click", showLeaderboardModal);
    }

    init();
  </script>
</body>
</html>
